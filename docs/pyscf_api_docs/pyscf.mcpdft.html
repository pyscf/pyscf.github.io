
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pyscf.mcpdft package &#8212; PySCF</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=92fd9be5" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/css/pyscf-pst.css?v=ed6b5f64" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../_static/documentation_options.js?v=67920a36"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'pyscf_api_docs/pyscf.mcpdft';</script>
    <link rel="icon" href="../_static/favicon-32x32.png"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="2.10" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo-64x64.png" class="logo__image only-light" alt=""/>
    <img src="../_static/logo-64x64.png" class="logo__image only-dark pst-js-only" alt=""/>
  
  
    <p class="title logo__title">PySCF</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../quickstart.html">
    Quickstart
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../user/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../contributor/index.html">
    Contributor Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../about.html">
    About
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pyscf/pyscf" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../quickstart.html">
    Quickstart
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../user/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../contributor/index.html">
    Contributor Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../about.html">
    About
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pyscf/pyscf" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="pyscf.adc.html">pyscf.adc package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.agf2.html">pyscf.agf2 package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.ao2mo.html">pyscf.ao2mo package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.cc.html">pyscf.cc package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.ci.html">pyscf.ci package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.data.html">pyscf.data package</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="pyscf.df.html">pyscf.df package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="pyscf.df.grad.html">pyscf.df.grad package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.df.hessian.html">pyscf.df.hessian package</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="pyscf.dft.html">pyscf.dft package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="pyscf.dft.xc.html">pyscf.dft.xc package</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.eph.html">pyscf.eph package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.fci.html">pyscf.fci package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.geomopt.html">pyscf.geomopt package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.grad.html">pyscf.grad package</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="pyscf.gto.html">pyscf.gto package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="pyscf.gto.basis.html">pyscf.gto.basis package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="pyscf.gto.basis.dyall-basis.html">pyscf.gto.basis.dyall-basis package</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.gw.html">pyscf.gw package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.hessian.html">pyscf.hessian package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.lib.html">pyscf.lib package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.lo.html">pyscf.lo package</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">pyscf.mcpdft package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.mcscf.html">pyscf.mcscf package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.mp.html">pyscf.mp package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.mrpt.html">pyscf.mrpt package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.nac.html">pyscf.nac package</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="pyscf.pbc.html">pyscf.pbc package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.adc.html">pyscf.pbc.adc package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.ao2mo.html">pyscf.pbc.ao2mo package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.cc.html">pyscf.pbc.cc package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.ci.html">pyscf.pbc.ci package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.df.html">pyscf.pbc.df package</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="pyscf.pbc.dft.html">pyscf.pbc.dft package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="pyscf.pbc.dft.multigrid.html">pyscf.pbc.dft.multigrid package</a></li>
</ul>
</details></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.eph.html">pyscf.pbc.eph package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.geomopt.html">pyscf.pbc.geomopt package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.grad.html">pyscf.pbc.grad package</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="pyscf.pbc.gto.html">pyscf.pbc.gto package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="pyscf.pbc.gto.basis.html">pyscf.pbc.gto.basis package</a></li>
<li class="toctree-l3"><a class="reference internal" href="pyscf.pbc.gto.pseudo.html">pyscf.pbc.gto.pseudo package</a></li>
</ul>
</details></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.gw.html">pyscf.pbc.gw package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.lib.html">pyscf.pbc.lib package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.mp.html">pyscf.pbc.mp package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.mpicc.html">pyscf.pbc.mpicc package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.mpitools.html">pyscf.pbc.mpitools package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.scf.html">pyscf.pbc.scf package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.symm.html">pyscf.pbc.symm package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.tddft.html">pyscf.pbc.tddft package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.tdscf.html">pyscf.pbc.tdscf package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.tools.html">pyscf.pbc.tools package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.x2c.html">pyscf.pbc.x2c package</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.qmmm.html">pyscf.qmmm package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.scf.html">pyscf.scf package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.sgx.html">pyscf.sgx package</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="pyscf.solvent.html">pyscf.solvent package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="pyscf.solvent.grad.html">pyscf.solvent.grad package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.solvent.hessian.html">pyscf.solvent.hessian package</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.soscf.html">pyscf.soscf package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.symm.html">pyscf.symm package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.tddft.html">pyscf.tddft package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.tdscf.html">pyscf.tdscf package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.tools.html">pyscf.tools package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.x2c.html">pyscf.x2c package</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">pyscf.mcpdft package</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="pyscf-mcpdft-package">
<h1>pyscf.mcpdft package<a class="headerlink" href="#pyscf-mcpdft-package" title="Link to this heading">#</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">#</a></h2>
</section>
<section id="module-pyscf.mcpdft.chkfile">
<span id="pyscf-mcpdft-chkfile-module"></span><h2>pyscf.mcpdft.chkfile module<a class="headerlink" href="#module-pyscf.mcpdft.chkfile" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.chkfile.dump_lpdft">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.chkfile.</span></span><span class="sig-name descname"><span class="pre">dump_lpdft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pdft'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_tot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_mcscf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mcscf_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mcscf'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/chkfile.html#dump_lpdft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.chkfile.dump_lpdft" title="Link to this definition">#</a></dt>
<dd><p>Save L-PDFT calculation results in chkfile</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.chkfile.dump_mcpdft">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.chkfile.</span></span><span class="sig-name descname"><span class="pre">dump_mcpdft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pdft'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_tot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_mcscf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mcscf_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mcscf'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/chkfile.html#dump_mcpdft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.chkfile.dump_mcpdft" title="Link to this definition">#</a></dt>
<dd><p>Save MC-PDFT calculation results in chkfile</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.chkfile.load_pdft">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.chkfile.</span></span><span class="sig-name descname"><span class="pre">load_pdft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/chkfile.html#load_pdft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.chkfile.load_pdft" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="module-pyscf.mcpdft.cmspdft">
<span id="pyscf-mcpdft-cmspdft-module"></span><h2>pyscf.mcpdft.cmspdft module<a class="headerlink" href="#module-pyscf.mcpdft.cmspdft" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.cmspdft.coulomb_tensor">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.cmspdft.</span></span><span class="sig-name descname"><span class="pre">coulomb_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h2eff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eris</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/cmspdft.html#coulomb_tensor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.cmspdft.coulomb_tensor" title="Link to this definition">#</a></dt>
<dd><p>Compute w_IJKL = (tu|vx) D^IJ_tu D^KL_vx</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc : mcscf method instance</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">ndarray of shape (nao,nmo)</span></dt><dd><p>Contains molecular orbital coefficients</p>
</dd>
<dt>ci<span class="classifier">list of ndarrays of shape (ndeta,ndetb)</span></dt><dd><p>Contains CI vectors</p>
</dd>
<dt>h2eff<span class="classifier">ndarray of shape [ncas,]*4</span></dt><dd><p>Contains active-space ERIs</p>
</dd>
<dt>eris<span class="classifier">mc_ao2mo.ERI object</span></dt><dd><p>Contains active-space ERIs. Ignored if h2eff is passed; if
h2eff is not passed then it is constructed from eris.ppaa</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>w : ndarray of shape [nroots,]*4</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.cmspdft.e_coul">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.cmspdft.</span></span><span class="sig-name descname"><span class="pre">e_coul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h2eff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eris</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/cmspdft.html#e_coul"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.cmspdft.e_coul" title="Link to this definition">#</a></dt>
<dd><p>Compute the sum of active-space Coulomb energies (the diabatizer
function for CMS-PDFT) and its first and second derivatives</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc : mcscf method instance</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">ndarray of shape (nao,nmo)</span></dt><dd><p>Contains molecular orbital coefficients</p>
</dd>
<dt>ci<span class="classifier">list of ndarrays of shape (ndeta,ndetb)</span></dt><dd><p>Contains CI vectors</p>
</dd>
<dt>h2eff<span class="classifier">ndarray of shape [ncas,]*4</span></dt><dd><p>Contains active-space ERIs</p>
</dd>
<dt>eris<span class="classifier">mc_ao2mo.ERI object</span></dt><dd><p>Contains active-space ERIs. Ignored if h2eff is passed; if
h2eff is not passed then it is constructed from eris.ppaa</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Qaa<span class="classifier">float</span></dt><dd><p>sum of Coulomb energies</p>
</dd>
<dt>dQaa<span class="classifier">ndarray of shape npair = nroots*(nroots-1)/2</span></dt><dd><p>first derivatives of J wrt interstate rotation</p>
</dd>
<dt>d2Qaa<span class="classifier">ndarray of shape (npair,npair)</span></dt><dd><p>Hessian of J wrt interstate rotation</p>
</dd>
<dt>Qaa_update<span class="classifier">callable</span></dt><dd><p>Takes a unitary matrix of shape (nroots, nroots) and returns
Qaa, dQaa, and d2Qaa as above using the stored Coulomb
tensor intermediate from this function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.cmspdft.e_coul_o0">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.cmspdft.</span></span><span class="sig-name descname"><span class="pre">e_coul_o0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/cmspdft.html#e_coul_o0"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.cmspdft.e_coul_o0" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="module-pyscf.mcpdft.lpdft">
<span id="pyscf-mcpdft-lpdft-module"></span><h2>pyscf.mcpdft.lpdft module<a class="headerlink" href="#module-pyscf.mcpdft.lpdft" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.lpdft.get_lpdft_hconst">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.lpdft.</span></span><span class="sig-name descname"><span class="pre">get_lpdft_hconst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E_ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casdm1s_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casdm2_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hyb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">veff1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">veff2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/lpdft.html#get_lpdft_hconst"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.lpdft.get_lpdft_hconst" title="Link to this definition">#</a></dt>
<dd><p>Compute h_const for the L-PDFT Hamiltonian</p>
<dl>
<dt>Args:</dt><dd><p>mc : instance of class _PDFT</p>
<dl class="simple">
<dt>E_ot<span class="classifier">float</span></dt><dd><p>On-top energy</p>
</dd>
<dt>casdm1s_0<span class="classifier">ndarray of shape (2, ncas, ncas)</span></dt><dd><p>Spin-separated 1-RDM in the active space generated from expansion
density.</p>
</dd>
<dt>casdm2_0<span class="classifier">ndarray of shape (ncas, ncas, ncas, ncas)</span></dt><dd><p>Spin-summed 2-RDM in the active space generated from expansion
density.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>hyb<span class="classifier">float</span></dt><dd><p>Hybridization constant (lambda term)</p>
</dd>
<dt>ncas<span class="classifier">float</span></dt><dd><p>Number of active space MOs</p>
</dd>
<dt>ncore: float</dt><dd><p>Number of core MOs</p>
</dd>
<dt>veff1<span class="classifier">ndarray of shape (nao, nao)</span></dt><dd><p>1-body effective potential in the AO basis computed using the
zeroth-order densities.</p>
</dd>
<dt>veff2<span class="classifier">pyscf.mcscf.mc_ao2mo._ERIS instance</span></dt><dd><p>Relevant 2-body effective potential in the MO basis.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Constant term h_const for the expansion term.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.lpdft.get_transformed_h2eff_for_cas">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.lpdft.</span></span><span class="sig-name descname"><span class="pre">get_transformed_h2eff_for_cas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/lpdft.html#get_transformed_h2eff_for_cas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.lpdft.get_transformed_h2eff_for_cas" title="Link to this definition">#</a></dt>
<dd><p>Compute the CAS two-particle linear PDFT Hamiltonian</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>ncore<span class="classifier">int</span></dt><dd><p>Number of core MOs</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Number of active space MOs</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>ndarray of shape (ncas,ncas,ncas,ncas) which contain v_vwxy</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.lpdft.kernel">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.lpdft.</span></span><span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dump_chk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/lpdft.html#kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.lpdft.kernel" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.lpdft.linear_multi_state">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.lpdft.</span></span><span class="sig-name descname"><span class="pre">linear_multi_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.5,</span> <span class="pre">0.5)</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/lpdft.html#linear_multi_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.lpdft.linear_multi_state" title="Link to this definition">#</a></dt>
<dd><p>Build linearized multi-state MC-PDFT method object</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc : instance of class _PDFT</p>
</dd>
<dt>Kwargs:</dt><dd><p>weights : sequence of floats</p>
</dd>
<dt>Returns:</dt><dd><p>si : instance of class _LPDFT</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.lpdft.linear_multi_state_mix">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.lpdft.</span></span><span class="sig-name descname"><span class="pre">linear_multi_state_mix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fcisolvers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.5,</span> <span class="pre">0.5)</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/lpdft.html#linear_multi_state_mix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.lpdft.linear_multi_state_mix" title="Link to this definition">#</a></dt>
<dd><p>Build SA Mix linearized multi-state MC-PDFT method object</p>
<dl>
<dt>Args:</dt><dd><p>mc : instance of class _PDFT</p>
<p>fcisolvers : fcisolvers to construct StateAverageMixSolver with</p>
</dd>
<dt>Kwargs:</dt><dd><p>weights : sequence of floats</p>
</dd>
<dt>Returns:</dt><dd><p>si : instance of class _LPDFT</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.lpdft.make_lpdft_ham_">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.lpdft.</span></span><span class="sig-name descname"><span class="pre">make_lpdft_ham_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/lpdft.html#make_lpdft_ham_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.lpdft.make_lpdft_ham_" title="Link to this definition">#</a></dt>
<dd><p>Compute the L-PDFT Hamiltonian</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">ndarray of shape (nao, nmo)</span></dt><dd><p>A full set of molecular orbital coefficients. Taken from self if
not provided.</p>
</dd>
<dt>ci<span class="classifier">list of ndarrays of length nroots</span></dt><dd><p>CI vectors should be from a converged CASSCF/CASCI calculation</p>
</dd>
</dl>
<p>ot : an instance of on-top functional class - see otfnal.py</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>lpdft_ham<span class="classifier">ndarray of shape (nroots, nroots) or (nirreps, nroots, nroots)</span></dt><dd><p>Linear approximation to the MC-PDFT energy expressed as a
hamiltonian in the basis provided by the CI vectors. If
StateAverageMix, then returns the block diagonal of the lpdft
hamiltonian for each irrep.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.lpdft.transformed_h1e_for_cas">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.lpdft.</span></span><span class="sig-name descname"><span class="pre">transformed_h1e_for_cas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E_ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casdm1s_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casdm2_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hyb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/lpdft.html#transformed_h1e_for_cas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.lpdft.transformed_h1e_for_cas" title="Link to this definition">#</a></dt>
<dd><p>Compute the CAS one-particle L-PDFT Hamiltonian</p>
<dl>
<dt>Args:</dt><dd><p>mc : instance of a _PDFT object</p>
<dl class="simple">
<dt>E_ot<span class="classifier">float</span></dt><dd><p>On-top energy</p>
</dd>
<dt>casdm1s_0<span class="classifier">ndarray of shape (2,ncas,ncas)</span></dt><dd><p>Spin-separated 1-RDM in the active space generated from expansion
density</p>
</dd>
<dt>casdm2_0<span class="classifier">ndarray of shape (ncas,ncas,ncas,ncas)</span></dt><dd><p>Spin-summed 2-RDM in the active space generated from expansion
density</p>
</dd>
<dt>hyb<span class="classifier">float</span></dt><dd><p>Hybridization constant (lambda term)</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray of shape (nao,nmo)</span></dt><dd><p>A full set of molecular orbital coefficients. Taken from self if
not provided.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Number of active space molecular orbitals</p>
</dd>
<dt>ncore<span class="classifier">int</span></dt><dd><p>Number of core molecular orbitals</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A tuple, the first is the effective one-electron linear PDFT
Hamiltonian defined in CAS space, the second is the modified core
energy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.lpdft.weighted_average_densities">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.lpdft.</span></span><span class="sig-name descname"><span class="pre">weighted_average_densities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/lpdft.html#weighted_average_densities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.lpdft.weighted_average_densities" title="Link to this definition">#</a></dt>
<dd><p>Compute the weighted average 1- and 2-electron CAS densities.
1-electron CAS is returned as spin-separated.</p>
<dl>
<dt>Args:</dt><dd><p>mc : instance of class _PDFT</p>
<dl class="simple">
<dt>ci<span class="classifier">list of ndarrays of length nroots</span></dt><dd><p>CI vectors should be from a converged CASSCF/CASCI calculation</p>
</dd>
<dt>weights<span class="classifier">ndarray of length nroots</span></dt><dd><p>Weight for each state. If none, uses weights from SA-CASSCF
calculation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A tuple, the first is casdm1s and the second is casdm2 where they are
weighted averages where the weights are given.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyscf.mcpdft.mcpdft">
<span id="pyscf-mcpdft-mcpdft-module"></span><h2>pyscf.mcpdft.mcpdft module<a class="headerlink" href="#module-pyscf.mcpdft.mcpdft" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.mcpdft.energy_dft">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.mcpdft.</span></span><span class="sig-name descname"><span class="pre">energy_dft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casdm1s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casdm2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/mcpdft.html#energy_dft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.mcpdft.energy_dft" title="Link to this definition">#</a></dt>
<dd><p>Wrap to ot.energy_ot for subclassing.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.mcpdft.energy_elec">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.mcpdft.</span></span><span class="sig-name descname"><span class="pre">energy_elec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/mcpdft.html#energy_elec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.mcpdft.energy_elec" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.mcpdft.energy_mcwfn">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.mcpdft.</span></span><span class="sig-name descname"><span class="pre">energy_mcwfn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casdm1s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casdm2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/mcpdft.html#energy_mcwfn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.mcpdft.energy_mcwfn" title="Link to this definition">#</a></dt>
<dd><p>Compute the parts of the MC-PDFT energy arising from the wave
function</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>mc<span class="classifier">an instance of CASSCF or CASCI class</span></dt><dd><p>Note: this function does not currently run the CASSCF or
CASCI calculation itself prior to calculating the MC-PDFT
energy. Call mc.kernel () before passing to this function!</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">ndarray of shape (nao, nmo)</span></dt><dd><p>contains molecular orbital coefficients</p>
</dd>
<dt>ci<span class="classifier">list or ndarray</span></dt><dd><p>contains ci vectors</p>
</dd>
</dl>
<p>ot : an instance of on-top functional class - see otfnal.py
state : int</p>
<blockquote>
<div><p>If mc describes a state-averaged calculation, select the
state (0-indexed).</p>
</div></blockquote>
<dl class="simple">
<dt>casdm1s<span class="classifier">ndarray or compatible of shape (2,ncas,ncas)</span></dt><dd><p>Contains spin-separated active-space 1RDM</p>
</dd>
<dt>casdm2<span class="classifier">ndarray or compatible of shape [ncas,]*4</span></dt><dd><p>Contains spin-summed active-space 2RDM</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>e_mcwfn<span class="classifier">float</span></dt><dd><p>Energy from the multiconfigurational wave function:
nuclear repulsion + 1e + coulomb</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.mcpdft.energy_tot">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.mcpdft.</span></span><span class="sig-name descname"><span class="pre">energy_tot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/mcpdft.html#energy_tot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.mcpdft.energy_tot" title="Link to this definition">#</a></dt>
<dd><p>Calculate MC-PDFT total energy</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>mc<span class="classifier">an instance of CASSCF or CASCI class</span></dt><dd><p>Note: this function does not currently run the CASSCF or
CASCI calculation itself prior to calculating the MC-PDFT
energy. Call mc.kernel () before passing to this function!</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">ndarray of shape (nao, nmo)</span></dt><dd><p>Molecular orbital coefficients</p>
</dd>
<dt>ci<span class="classifier">ndarray or list of length (nroots)</span></dt><dd><p>CI vector or vectors.</p>
</dd>
</dl>
<p>ot : an instance of on-top functional class - see otfnal.py
state : int</p>
<blockquote>
<div><p>If mc describes a state-averaged calculation, select the
state (0-indexed).</p>
</div></blockquote>
<dl class="simple">
<dt>verbose<span class="classifier">int</span></dt><dd><p>Verbosity of logger output; defaults to mc.verbose</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MC-PDFT energy including nuclear repulsion energy</p>
</dd>
<dt>E_ot<span class="classifier">float</span></dt><dd><p>On-top (cf. exchange-correlation) energy</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.mcpdft.get_energy_decomposition">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.mcpdft.</span></span><span class="sig-name descname"><span class="pre">get_energy_decomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">otxc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_x_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/mcpdft.html#get_energy_decomposition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.mcpdft.get_energy_decomposition" title="Link to this definition">#</a></dt>
<dd><p>Compute a decomposition of the MC-PDFT energy into nuclear
potential (E0), one-electron (E1), Coulomb (E2c), exchange (EOTx),
correlation (EOTc) terms, and additionally the nonclassical part
(E2nc) of the MC-SCF energy:</p>
<p>E(MC-SCF) = E0 + E1 + E2c + Enc
E(MC-PDFT) = E0 + E1 + E2c + EOTx + EOTc</p>
<p>For hybrid functionals,</p>
<p>E(MC-PDFT) = E0 + E1 + E2c + EOTx + EOTc + Enc</p>
<p>Where the Enc and EOTx/c terms are premultiplied by the hybrid factor. If
mc.fcisolver.nroots &gt; 1, lists are returned for everything except the
nuclear potential energy.</p>
<dl>
<dt>Args:</dt><dd><p>mc : an instance of CASSCF or CASCI class</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>Contains MO coefficients</p>
</dd>
<dt>ci<span class="classifier">ndarray or list of length nroots</span></dt><dd><p>Contains CI vectors</p>
</dd>
</dl>
<p>ot : an instance of (translated) on-top density fnal class
otxc : string</p>
<blockquote>
<div><p>identity of translated functional; overrides ot</p>
</div></blockquote>
<dl class="simple">
<dt>grids_level<span class="classifier">integer</span></dt><dd><p>level preset for DFT quadrature grids</p>
</dd>
<dt>grids_attr<span class="classifier">dictionary</span></dt><dd><p>general attributes for DFT quadrature grids</p>
</dd>
<dt>split_x_c<span class="classifier">logical</span></dt><dd><p>whether to split the exchange and correlation parts of the
ot functional into two separate contributions</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>e_nuc<span class="classifier">float</span></dt><dd><p>E0 = sum_A&gt;B ZA*ZB/rAB</p>
</dd>
<dt>e_1e<span class="classifier">float or list of length nroots</span></dt><dd><p>E1 = &lt;T+sum_A ZA/rA&gt;</p>
</dd>
<dt>e_coul<span class="classifier">float or list of length nroots</span></dt><dd><p>E2c = 1/2 int rho(1)rho(2)/r12 d1d2</p>
</dd>
<dt>e_otxc<span class="classifier">float or list of length nroots</span></dt><dd><p>EOTxc = translated functional energy
if split_x_c == True, this is instead
EOTx = exchange part of translated functional energy</p>
</dd>
<dt>e_otc<span class="classifier">float or list of length nroots</span></dt><dd><p>only returned if split_x_c == True
EOTc = correlation part of translated functional</p>
</dd>
<dt>e_ncwfn<span class="classifier">float or list of length nroots</span></dt><dd><p>E2ncc = &lt;H&gt; - E0 - E1 - E2c
If hybrid functional, this term is weighted appropriately. For pure
functionals, it is the full NC component</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.mcpdft.get_mcpdft_child_class">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.mcpdft.</span></span><span class="sig-name descname"><span class="pre">get_mcpdft_child_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/mcpdft.html#get_mcpdft_child_class"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.mcpdft.get_mcpdft_child_class" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.mcpdft.kernel">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.mcpdft.</span></span><span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcpdft.mcpdft.kernel" title="Link to this definition">#</a></dt>
<dd><p>Calculate MC-PDFT total energy</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>mc<span class="classifier">an instance of CASSCF or CASCI class</span></dt><dd><p>Note: this function does not currently run the CASSCF or
CASCI calculation itself prior to calculating the MC-PDFT
energy. Call mc.kernel () before passing to this function!</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">ndarray of shape (nao, nmo)</span></dt><dd><p>Molecular orbital coefficients</p>
</dd>
<dt>ci<span class="classifier">ndarray or list of length (nroots)</span></dt><dd><p>CI vector or vectors.</p>
</dd>
</dl>
<p>ot : an instance of on-top functional class - see otfnal.py
state : int</p>
<blockquote>
<div><p>If mc describes a state-averaged calculation, select the
state (0-indexed).</p>
</div></blockquote>
<dl class="simple">
<dt>verbose<span class="classifier">int</span></dt><dd><p>Verbosity of logger output; defaults to mc.verbose</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MC-PDFT energy including nuclear repulsion energy</p>
</dd>
<dt>E_ot<span class="classifier">float</span></dt><dd><p>On-top (cf. exchange-correlation) energy</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyscf.mcpdft.mspdft">
<span id="pyscf-mcpdft-mspdft-module"></span><h2>pyscf.mcpdft.mspdft module<a class="headerlink" href="#module-pyscf.mcpdft.mspdft" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.mspdft.get_diabfns">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.mspdft.</span></span><span class="sig-name descname"><span class="pre">get_diabfns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/mspdft.html#get_diabfns"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.mspdft.get_diabfns" title="Link to this definition">#</a></dt>
<dd><p>Interpret the name of the MS-PDFT method as a pair of functions
which optimize the intermediate states and calculate the power
series in the corresponding objective function to second order.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>obj<span class="classifier">string</span></dt><dd><p>Specify particular MS-PDFT method. Currently, only CMS is
supported. Not case-sensitive.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>diabatizer<span class="classifier">callable</span></dt><dd><p>Takes model-space CI vectors in a trial intermediate-state
basis and returns the value and first and second derivatives
of the objective function specified by obj</p>
</dd>
<dt>diabatize<span class="classifier">callable</span></dt><dd><p>Takes model-space CI vectors and returns CI vectors in the
optimized intermediate-state basis</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.mspdft.make_heff_mcscf">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.mspdft.</span></span><span class="sig-name descname"><span class="pre">make_heff_mcscf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/mspdft.html#make_heff_mcscf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.mspdft.make_heff_mcscf" title="Link to this definition">#</a></dt>
<dd><p>Build Hamiltonian matrix in basis of ci vector</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc : an instance of MCPDFT class</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">ndarray of shape (nao, nmo)</span></dt><dd><p>MO coefficients</p>
</dd>
<dt>ci<span class="classifier">ndarray or list of len (nroots)</span></dt><dd><p>CI vectors describing the model space, presumed to be in the
optimized intermediate-state basis</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>heff_mcscf<span class="classifier">ndarray of shape (nroots, nroots)</span></dt><dd><p>Effective MC-SCF hamiltonian matrix in the basis of the
provided CI vectors</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.mspdft.multi_state">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.mspdft.</span></span><span class="sig-name descname"><span class="pre">multi_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.5,</span> <span class="pre">0.5)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diabatization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'CMS'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/mspdft.html#multi_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.mspdft.multi_state" title="Link to this definition">#</a></dt>
<dd><p>Build multi-state MC-PDFT method object</p>
<dl>
<dt>Args:</dt><dd><p>mc : instance of class _PDFT</p>
</dd>
<dt>Kwargs:</dt><dd><p>weights : sequence of floats
diabatization : objective-function type</p>
<blockquote>
<div><p>Currently supports only cms</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>si : instance of class _MSPDFT</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.mspdft.si_newton">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.mspdft.</span></span><span class="sig-name descname"><span class="pre">si_newton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objfn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_cyc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sing_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nudge_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/mspdft.html#si_newton"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.mspdft.si_newton" title="Link to this definition">#</a></dt>
<dd><p>Optimize the intermediate states describing the model space of
an MS-PDFT calculation by maximizing the provided objective function
using a gradient-ascent algorithm</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mc : an instance of MSPDFT class</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>ci<span class="classifier">ndarray or list of len (nroots)</span></dt><dd><p>CI vectors spanning the model space</p>
</dd>
<dt>objfn<span class="classifier">callable</span></dt><dd><p>Takes CI vectors as a kwarg and returns the value, gradient,
and Hessian of a chosen objective function wrt rotation
between pairs of CI vectors</p>
</dd>
<dt>max_cyc<span class="classifier">integer</span></dt><dd><p>Maximum number of cycles of the gradient-ascent algorithm</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Maximum value of both gradient and step vectors at
convergence</p>
</dd>
<dt>sing_tol<span class="classifier">float</span></dt><dd><p>Tolerance for determining when normal coordinate belongs to
the null space (df = d2f = 0) or when the Hessian is
singular (df != 0, d2f = 0).</p>
</dd>
<dt>nudge_tol<span class="classifier">float</span></dt><dd><p>Minimum step size along a normal coordinate when the surface
is locally concave.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>conv<span class="classifier">logical</span></dt><dd><p>True if the optimization is converged</p>
</dd>
<dt>ci<span class="classifier">list of len (nroots)</span></dt><dd><p>Optimized CI vectors describing intermediate states</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyscf.mcpdft.otfnal">
<span id="pyscf-mcpdft-otfnal-module"></span><h2>pyscf.mcpdft.otfnal module<a class="headerlink" href="#module-pyscf.mcpdft.otfnal" title="Link to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.colle_salvetti_corr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">colle_salvetti_corr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#colle_salvetti_corr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.colle_salvetti_corr" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.mcpdft.otfnal.otfnal" title="pyscf.mcpdft.otfnal.otfnal"><code class="xref py py-class docutils literal notranslate"><span class="pre">otfnal</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.colle_salvetti_corr.get_E_ot">
<span class="sig-name descname"><span class="pre">get_E_ot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#colle_salvetti_corr.get_E_ot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.colle_salvetti_corr.get_E_ot" title="Link to this definition">#</a></dt>
<dd><p>Colle &amp; Salvetti, Theor. Chim. Acta 37, 329 (1975)
see also Lee, Yang, Parr, Phys. Rev. B 37, 785 (1988)
[Eq. (3)]</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.energy_ot">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">energy_ot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casdm1s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casdm2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncore</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#energy_ot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.energy_ot" title="Link to this definition">#</a></dt>
<dd><p>Compute the on-top energy - the last term in</p>
<p>E_MCPDFT = h_pq l_pq + 1/2 v_pqrs l_pq l_rs + E_ot[rho,Pi]</p>
<dl>
<dt>Args:</dt><dd><p>ot : an instance of otfnal class
casdm1s : ndarray of shape (2, ncas, ncas)</p>
<blockquote>
<div><p>Contains spin-separated one-body density matrices in an
active-orbital basis</p>
</div></blockquote>
<dl class="simple">
<dt>casdm2<span class="classifier">ndarray of shape (ncas, ncas, ncas, ncas)</span></dt><dd><p>Contains spin-summed two-body density matrix in an active-
orbital basis</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray of shape (nao, nmo)</span></dt><dd><p>Contains molecular orbital coefficients for active-space
orbitals. Columns ncore through ncore+ncas give the basis
in which casdm1s and casdm2 are expressed.</p>
</dd>
<dt>ncore<span class="classifier">integer</span></dt><dd><p>Number of doubly occupied inactive core orbitals not
explicitly included in casdm1s and casdm2</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>max_memory<span class="classifier">int or float</span></dt><dd><p>maximum cache size in MB
default is 2000</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>1 if 1rdms are assumed hermitian, 0 otherwise</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">float</span></dt><dd><p>The MC-PDFT on-top (nonclassical) energy</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.ft_eval_xc">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">ft_eval_xc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ni</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relativity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deriv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#ft_eval_xc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.ft_eval_xc" title="Link to this definition">#</a></dt>
<dd><p>For fully translated functionals, otxc string = ft+xc string
Interface to call libxc library to evaluate XC functional, potential</p>
<blockquote>
<div><p>and functional derivatives.</p>
<ul>
<li><p>The given functional xc_code must be a one-line string.</p></li>
<li><p>The functional xc_code is case-insensitive.</p></li>
<li><p>The functional xc_code string has two parts, separated by ,.  The
first part describes the exchange functional, the second part sets the
correlation functional.</p>
<ul>
<li><p>If , not appeared in string, the entire string is treated as the
name of a compound functional (containing both the exchange and
the correlation functional) which was declared in the functional
aliases list. The full list of functional aliases can be obtained by
calling the function pyscf.dft.xcfun.XC_ALIAS.keys() .</p>
<p>If the string was not found in the aliased functional list, it is
treated as X functional.</p>
</li>
<li><p>To input only X functional (without C functional), leave the second
part blank. E.g. description=slater, means a functional with LDA
contribution only.</p></li>
<li><p>To neglect the contribution of X functional (just apply C functional),
leave blank in the first part, e.g. description=,vwn means a
functional with VWN only.</p></li>
<li><p>If compound XC functional is specified, no matter whether it is in the
X part (the string in front of comma) or the C part (the string behind
comma), both X and C functionals of the compound XC functional will be
used.</p></li>
</ul>
</li>
<li><p>The functional name can be placed in arbitrary order.  Two names need to
be separated by operators + or -.  Blank spaces are ignored.
NOTE the parser only reads operators + - *.  / is not supported.</p></li>
<li><p>A functional name can have at most one factor.  If the factor is not
given, it is set to 1.  Compound functional can be scaled as a unit. For
example 0.5*b3lyp is equivalent to
HF*0.1 + .04*LDA + .36*B88, .405*LYP + .095*VWN</p></li>
<li><p>String HF stands for exact exchange (HF K matrix).  HF can be put in
the correlation functional part (after comma). Putting HF in the
correlation part is the same to putting HF in the exchange part.</p></li>
<li><p>String RSH means range-separated operator. Its format is
RSH(omega, alpha, beta).  Another way to input RSH is to use keywords
SR_HF and LR_HF: SR_HF(0.1) * alpha_plus_beta and LR_HF(0.1) *
alpha where the number in parenthesis is the value of omega.</p></li>
<li><p>Be careful with the libxc convention of GGA functional, in which the LDA
contribution is included.</p></li>
</ul>
<dl>
<dt>Args:</dt><dd><dl>
<dt>xc_code<span class="classifier">str</span></dt><dd><p>A string to describe the linear combination of different XC functionals.
The X and C functional are separated by comma like .8*LDA+.2*B86,VWN.
If HF (exact exchange) is appeared in the string, the HF part will
be skipped.  If an empty string  is given, the returns exc, vxc,
will be vectors of zeros.</p>
</dd>
<dt>rho<span class="classifier">ndarray</span></dt><dd><p>Shape of ((<em>,N)) for electron density (and derivatives) if spin = 0;
Shape of ((</em>,N),(<em>,N)) for alpha/beta electron density (and derivatives) if spin &gt; 0;
where N is number of grids.
rho (</em>,N) are ordered as (den,grad_x,grad_y,grad_z,laplacian,tau)
where grad_x = d/dx den, laplacian = nabla^2 den, tau = 1/2(nabla f)^2
In spin unrestricted case,
rho is ((den_u,grad_xu,grad_yu,grad_zu,laplacian_u,tau_u)</p>
<blockquote>
<div><p>(den_d,grad_xd,grad_yd,grad_zd,laplacian_d,tau_d))</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>spin<span class="classifier">int</span></dt><dd><p>spin polarized if spin &gt; 0</p>
</dd>
<dt>relativity<span class="classifier">int</span></dt><dd><p>No effects.</p>
</dd>
<dt>verbose<span class="classifier">int or object of <code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></span></dt><dd><p>No effects.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>ex, vxc, fxc, kxc</p>
<p>where</p>
<ul>
<li><p>vxc = (vrho, vsigma, vlapl, vtau) for restricted case</p></li>
<li><p>vxc for unrestricted case
| vrho[:,2]   = (u, d)
| vsigma[:,3] = (uu, ud, dd)
| vlapl[:,2]  = (u, d)
| vtau[:,2]   = (u, d)</p></li>
<li><p>fxc for restricted case:
(v2rho2, v2rhosigma, v2sigma2, v2lapl2, v2tau2, v2rholapl, v2rhotau, v2lapltau, v2sigmalapl, v2sigmatau)</p></li>
<li><p>fxc for unrestricted case:
| v2rho2[:,3]     = (u_u, u_d, d_d)
| v2rhosigma[:,6] = (u_uu, u_ud, u_dd, d_uu, d_ud, d_dd)
| v2sigma2[:,6]   = (uu_uu, uu_ud, uu_dd, ud_ud, ud_dd, dd_dd)
| v2lapl2[:,3]
| v2tau2[:,3]     = (u_u, u_d, d_d)
| v2rholapl[:,4]
| v2rhotau[:,4]   = (u_u, u_d, d_u, d_d)
| v2lapltau[:,4]
| v2sigmalapl[:,6]
| v2sigmatau[:,6] = (uu_u, uu_d, ud_u, ud_d, dd_u, dd_d)</p></li>
<li><p>kxc for restricted case:
(v3rho3, v3rho2sigma, v3rhosigma2, v3sigma3,</p>
<blockquote>
<div><p>v3rho2lapl, v3rho2tau,
v3rhosigmalapl, v3rhosigmatau,
v3rholapl2, v3rholapltau, v3rhotau2,
v3sigma2lapl, v3sigma2tau,
v3sigmalapl2, v3sigmalapltau, v3sigmatau2,
v3lapl3, v3lapl2tau, v3lapltau2, v3tau3)</p>
</div></blockquote>
</li>
<li><p>kxc for unrestricted case:
| v3rho3[:,4]         = (u_u_u, u_u_d, u_d_d, d_d_d)
| v3rho2sigma[:,9]    = (u_u_uu, u_u_ud, u_u_dd, u_d_uu, u_d_ud, u_d_dd, d_d_uu, d_d_ud, d_d_dd)
| v3rhosigma2[:,12]   = (u_uu_uu, u_uu_ud, u_uu_dd, u_ud_ud, u_ud_dd, u_dd_dd, d_uu_uu, d_uu_ud, d_uu_dd, d_ud_ud, d_ud_dd, d_dd_dd)
| v3sigma3[:,10]      = (uu_uu_uu, uu_uu_ud, uu_uu_dd, uu_ud_ud, uu_ud_dd, uu_dd_dd, ud_ud_ud, ud_ud_dd, ud_dd_dd, dd_dd_dd)
| v3rho2lapl[:,6]
| v3rho2tau[:,6]      = (u_u_u, u_u_d, u_d_u, u_d_d, d_d_u, d_d_d)
| v3rhosigmalapl[:,12]
| v3rhosigmatau[:,12] = (u_uu_u, u_uu_d, u_ud_u, u_ud_d, u_dd_u, u_dd_d,</p>
<blockquote>
<div><p>d_uu_u, d_uu_d, d_ud_u, d_ud_d, d_dd_u, d_dd_d)</p>
</div></blockquote>
<div class="line-block">
<div class="line">v3rholapl2[:,6]</div>
<div class="line">v3rholapltau[:,8]</div>
<div class="line">v3rhotau2[:,6]      = (u_u_u, u_u_d, u_d_d, d_u_u, d_u_d, d_d_d)</div>
<div class="line">v3sigma2lapl[:,12]</div>
<div class="line">v3sigma2tau[:,12]   = (uu_uu_u, uu_uu_d, uu_ud_u, uu_ud_d, uu_dd_u, uu_dd_d,
ud_ud_u, ud_ud_d, ud_dd_u, ud_dd_d, dd_dd_u, dd_dd_d)</div>
<div class="line">v3sigmalapl2[:,9]</div>
<div class="line">v3sigmalapltau[:,12]</div>
<div class="line">v3sigmatau2[:,9]    = (uu_u_u, uu_u_d, uu_d_d, ud_u_u, ud_u_d, ud_d_d, dd_u_u, dd_u_d, dd_d_d)</div>
<div class="line">v3lapl3[:,4]</div>
<div class="line">v3lapl2tau[:,6]</div>
<div class="line">v3lapltau2[:,6]</div>
<div class="line">v3tau3[:,4]         = (u_u_u, u_u_d, u_d_d, d_d_d)</div>
</div>
</li>
</ul>
<p>see also libxc_itrf.c</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.ft_hybrid_coeff">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">ft_hybrid_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ni</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#ft_hybrid_coeff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.ft_hybrid_coeff" title="Link to this definition">#</a></dt>
<dd><p>For fully translated functionals, otxc string = ft+xc string
None</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.ft_nlc_coeff">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">ft_nlc_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ni</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#ft_nlc_coeff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.ft_nlc_coeff" title="Link to this definition">#</a></dt>
<dd><p>For fully translated functionals, otxc string = ft+xc string
None</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.ft_rsh_and_hybrid_coeff">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">ft_rsh_and_hybrid_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ni</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#ft_rsh_and_hybrid_coeff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.ft_rsh_and_hybrid_coeff" title="Link to this definition">#</a></dt>
<dd><p>For fully translated functionals, otxc string = ft+xc string
Range-separated parameter and HF exchange components: omega, alpha, beta</p>
<blockquote>
<div><dl class="simple">
<dt>Exc_RSH = c_SR * SR_HFX + c_LR * LR_HFX + (1-c_SR) * Ex_SR + (1-c_LR) * Ex_LR + Ec</dt><dd><p>= alpha * HFX + beta * SR_HFX + (1-c_SR) * Ex_SR + (1-c_LR) * Ex_LR + Ec
= alpha * LR_HFX + hyb * SR_HFX + (1-c_SR) * Ex_SR + (1-c_LR) * Ex_LR + Ec</p>
</dd>
</dl>
<p>SR_HFX = &lt; pi | (1-erf(-omega r_{12}))/r_{12} | iq &gt;
LR_HFX = &lt; pi | erf(-omega r_{12})/r_{12} | iq &gt;
alpha = c_LR
beta = c_SR - c_LR</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.ft_rsh_coeff">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">ft_rsh_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ni</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#ft_rsh_coeff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.ft_rsh_coeff" title="Link to this definition">#</a></dt>
<dd><p>For fully translated functionals, otxc string = ft+xc string
None</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.ft_xc_type">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">ft_xc_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ni</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#ft_xc_type"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.ft_xc_type" title="Link to this definition">#</a></dt>
<dd><p>For fully translated functionals, otxc string = ft+xc string
None</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.ftransfnal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">ftransfnal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ks</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#ftransfnal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.ftransfnal" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.mcpdft.otfnal.transfnal" title="pyscf.mcpdft.otfnal.transfnal"><code class="xref py py-class docutils literal notranslate"><span class="pre">transfnal</span></code></a></p>
<p>Parent class of on-top pair-density functional. The main
callable is <a href="#id1"><span class="problematic" id="id2">``</span></a>eval_ot, which is comparable to pyscf.dft.libxc
<a href="#id3"><span class="problematic" id="id4">``</span></a>eval_xc. A true <a href="#id5"><span class="problematic" id="id6">``</span></a>kernel method, which would take arbitrary
1- and 2-RDMs and return the total PDFT energy, awaits design
decisions on how far Im willing/able to generalize the otpd
functions. For instance, in MP2 or CCSD, the 2-RDM spans the
whole orbital space and it may not be possible to hold it in
memory. At present, its all designed around MC-SCF, which is
why the <a href="#id7"><span class="problematic" id="id8">``</span></a>kernel function that actually calculates the energy
is in mcpdft.py instead of here.</p>
<dl>
<dt>Attributes:</dt><dd><p>mol : object of class pyscf.gto.mole
grids : object of class pyscf.dft.gen_grid.Grids
eval_ot : function with calling signature shown below
_numint : object of class pyscf.dft.NumInt</p>
<blockquote>
<div><p>member functions hybrid_coeff, nlc_coeff, rsh_coeff,
and _xc_type (at least) must be overloaded; see below</p>
</div></blockquote>
<dl class="simple">
<dt>otxc<span class="classifier">string</span></dt><dd><p>name of on-top pair-density exchange-correlation functional</p>
</dd>
</dl>
</dd>
</dl>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a>translated functional of Li Manni et al., JCTC 10, 3669 (2014).
The extra attributes are all callables; see their docstrings for
more information.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>ks<span class="classifier">object of <code class="xref py py-class docutils literal notranslate"><span class="pre">dft.RKS</span></code></span></dt><dd><p>ks.xc is the Kohn-Sham functional being <a href="#id11"><span class="problematic" id="id12">``</span></a>translated</p>
</dd>
</dl>
</dd>
</dl>
<p>Extra attributes for <a href="#id13"><span class="problematic" id="id14">``</span></a>fully-translated extension of Carlson
et al., JCTC 11, 4077 (2015):</p>
<blockquote>
<div><dl class="simple">
<dt>R0<span class="classifier">float</span></dt><dd><p>connecting point to polynomial smoothing function;
R0 &lt;= 1.0. Default is 0.9.</p>
</dd>
<dt>R1<span class="classifier">float</span></dt><dd><p>endpoint of polynomial smoothing function, zeta(R1) =
zeta(R1) = zeta(R1) = 0.0; R1 &gt;= 1.0. Default is 1.15.</p>
</dd>
<dt>A<span class="classifier">float</span></dt><dd><p>Quintic coefficient of polynomial smoothing function.
Default = -475.60656009 is chosen to make zeta continuous
through its second derivative at given the default R0 and R1.</p>
</dd>
<dt>B<span class="classifier">float</span></dt><dd><p>Quartic coefficient of polynomial smoothing function.
Default = -379.47331922 is chosen to make zeta continuous
through its second derivative given the default R0 and R1.</p>
</dd>
<dt>C<span class="classifier">float</span></dt><dd><p>Cubic coefficient of polynomial smoothing function.
Default = -85.38149682 chosen to make zeta continuous
through its second derivative given the default R0 and R1.</p>
</dd>
</dl>
</div></blockquote>
<dl class="py property">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.ftransfnal.Pi_deriv">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Pi_deriv</span></span><a class="headerlink" href="#pyscf.mcpdft.otfnal.ftransfnal.Pi_deriv" title="Link to this definition">#</a></dt>
<dd><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by + or - and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
&gt;&gt;&gt; int(0b100, base=0)
4</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.ftransfnal.d_jT_op">
<span class="sig-name descname"><span class="pre">d_jT_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#ftransfnal.d_jT_op"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.ftransfnal.d_jT_op" title="Link to this definition">#</a></dt>
<dd><p>Evaluate the x.(nabla j) contribution to the second density
derivatives of the on-top energy in terms of the untranslated
density and pair density</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>x<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Usually, a functional derivative of the on-top xc energy
wrt translated densities</p>
</dd>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id15"><span class="problematic" id="id16">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
</dl>
</dd>
<dt>Returns: ndarray of shape (<a href="#id17"><span class="problematic" id="id18">*</span></a>,ngrids)</dt><dd><p>second derivative of the translation dotted with x
3 rows for tLDA and 5 rows for tGGA</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.ftransfnal.get_rho_translated">
<span class="sig-name descname"><span class="pre">get_rho_translated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#ftransfnal.get_rho_translated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.ftransfnal.get_rho_translated" title="Link to this definition">#</a></dt>
<dd><p>Compute the fully-translated alpha and beta densities
and their derivatives. This is the same as translated except</p>
<p>rho_t^a += zeta * rho / 2
rho_t^b -= zeta * rho / 2</p>
<p>And the functional form of zeta is changed (see get_zeta)</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>Pi<span class="classifier">ndarray of shape (<a href="#id19"><span class="problematic" id="id20">*</span></a>, ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
<dt>rho<span class="classifier">ndarray of shape (2, <a href="#id21"><span class="problematic" id="id22">*</span></a>, ngrids)</span></dt><dd><p>containing spin density [and derivatives]</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>rho_ft<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Fully-translated spin density (and derivatives)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.ftransfnal.get_zeta">
<span class="sig-name descname"><span class="pre">get_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fn_deriv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#ftransfnal.get_zeta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.ftransfnal.get_zeta" title="Link to this definition">#</a></dt>
<dd><p>Compute the intermediate zeta used to compute the translated spin
densities and its functional derivatives</p>
<p>From the full translation [Carlson et al., JCTC 11, 4077 (2015)]:
zeta = (1-R)^(1/2)                          ; R &lt; R0</p>
<blockquote>
<div><p>= A*(R-R1)^5 + B*(R-R1)^4 + C*(R-R1)^3 ; R0 &lt;= R &lt; R1
= 0                                    ; otherwise</p>
</div></blockquote>
<dl>
<dt>Args:</dt><dd><dl>
<dt>R<span class="classifier">ndarray of shape (<a href="#id23"><span class="problematic" id="id24">*</span></a>,ngrids)</span></dt><dd><p>Ratio (4Pi/rho^2) and possibly its spatial derivatives
Only the first row is used in this function</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>fn_deriv<span class="classifier">integer</span></dt><dd><p>order of functional derivative (d^n z / dR^n) to return
along with the value of zeta</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>zeta : ndarray of shape (fn_deriv+1, ngrids)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.ftransfnal.jT_op">
<span class="sig-name descname"><span class="pre">jT_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#ftransfnal.jT_op"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.ftransfnal.jT_op" title="Link to this definition">#</a></dt>
<dd><p>Evaluate jTx = (x.j)T where j is the Jacobian of the
translated densities in terms of the untranslated density and
pair density</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>x<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Usually, a functional derivative of the on-top xc energy
wrt translated densities</p>
</dd>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id25"><span class="problematic" id="id26">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
</dl>
</dd>
<dt>Returns: ndarray of shape (<a href="#id27"><span class="problematic" id="id28">*</span></a>,ngrids)</dt><dd><p>Usually, a functional derivative of the on-top pair density
exchange-correlation energy wrt to total density and its
derivatives. The potential must be spin-symmetric in
pair-density functional theory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.ftransfnal.transl_prefix">
<span class="sig-name descname"><span class="pre">transl_prefix</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'ft'</span></em><a class="headerlink" href="#pyscf.mcpdft.otfnal.ftransfnal.transl_prefix" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.get_transfnal">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">get_transfnal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">otxc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#get_transfnal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.get_transfnal" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.make_hybrid_fnal">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">make_hybrid_fnal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hyb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hyb_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#make_hybrid_fnal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.make_hybrid_fnal" title="Link to this definition">#</a></dt>
<dd><p>Convenience function to write hybrid xc functional in terms of
only one parameter</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>xc_code<span class="classifier">string</span></dt><dd><p>As used in pyscf.dft.libxc. An exception is raised if it
is already a hybrid or contains a kinetic-energy
functional component.</p>
</dd>
<dt>hyb<span class="classifier">float</span></dt><dd><p>Parameter(s) defining the hybridization which is
handled in various ways according to hyb_type</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hyb_type<span class="classifier">int or string</span></dt><dd><p>The type of hybrid functional. Current options are:
- 0 or translation: Hybrid fnal is</p>
<blockquote>
<div><p>hyb*HF + (1-hyb)*x_code, hyb*HF + c_code.
Based on the idea that exact exchange of the
translated functional corresponds to exchange plus
correlation energy of the underlying wave function.
Requires len (hyb) == 1.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>1 or average: Hybrid fnal is</dt><dd><p>hyb*HF + (1-hyb)*x_code, hyb*HF + (1-hyb)*c_code.
Based on the idea that hyb = 1 recovers the wave
function energy itself. Requires len (hyb) == 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>2 or diagram: Hybrid fnal is</dt><dd><p>hyb*HF + (1-hyb)*x_code, c_code.
Based on the idea that the exchange energy of the
wave function somehow can be meaningfully separated
from the correlation energy. Requires len (hyb) == 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>3 or lambda: as in arXiv:1911.11162v1. Based on</dt><dd><p>existing double-hybrid functionals. Requires
len (hyb) == 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>4 or scaling: Hybrid fnal is</dt><dd><p>a*HF + (1-a)*x_code, a*HF + (1-a**b)*c_code
where a = hyb[0] and b = 1 + hyb[1]. Based on the
scaling inequalities proven by Levy and Perdew in
PRA 32, 2010 (1985):
E_c[rho_a] &lt; a*E_c[rho] if a &lt; 1 and
E_c[rho_a] &gt; a*E_c[rho] if a &gt; 1;
BUT
E_c[rho_a] ~/~ a^2 E_c[rho], implying that
E_c[rho_a] ~ a^b E_c[rho] with b &gt; 1 unknown.
Requires len (hyb) == 2.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.make_scaled_fnal">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">make_scaled_fnal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hyb_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hyb_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fnal_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fnal_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#make_scaled_fnal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.make_scaled_fnal" title="Link to this definition">#</a></dt>
<dd><p>Convenience function to write the xc_code corresponding to a
functional of the type</p>
<dl class="simple">
<dt>Exc = hyb_x*E_x[Psi] + fnal_x*E_x[rho] + hyb_c*E_c[Psi]</dt><dd><ul class="simple">
<li><p>fnal_c*E_c[rho]</p></li>
</ul>
</dd>
</dl>
<p>where E[Psi] is an energy from a wave function, and E[rho] is a
density functional from libxc. The decomposition of E[Psi] into
exchange (E_x) and correlation (E_c) components is arbitrary.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>xc_code<span class="classifier">string</span></dt><dd><p>As used in pyscf.dft.libxc. An exception is raised if it
is already a hybrid or contains a kinetic-energy
functional component.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>hyb_x<span class="classifier">float</span></dt><dd><p>fraction of wave function exchange to be included</p>
</dd>
<dt>hyb_c<span class="classifier">float</span></dt><dd><p>fraction of wave function correlation to be included</p>
</dd>
<dt>fnal_x<span class="classifier">float</span></dt><dd><p>fraction of density functional exchange to be included.
Defaults to 1 - hyb_x.</p>
</dd>
<dt>fnal_c<span class="classifier">float</span></dt><dd><p>fraction of density functional correlation to be
included. Defaults to 1 - hyb_c.</p>
</dd>
</dl>
</dd>
<dt>returns:</dt><dd><dl class="simple">
<dt>xc_code<span class="classifier">string</span></dt><dd><p>If xc_code has exchange part x_code and correlation part
c_code, the return value is
fnal_x * x_code + hyb_x * HF,
fnal_c * c_code + hyb_c * HF
You STILL HAVE TO PREPEND t OR ft!!!</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">otfnal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#otfnal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Parent class of on-top pair-density functional. The main
callable is <a href="#id29"><span class="problematic" id="id30">``</span></a>eval_ot, which is comparable to pyscf.dft.libxc
<a href="#id31"><span class="problematic" id="id32">``</span></a>eval_xc. A true <a href="#id33"><span class="problematic" id="id34">``</span></a>kernel method, which would take arbitrary
1- and 2-RDMs and return the total PDFT energy, awaits design
decisions on how far Im willing/able to generalize the otpd
functions. For instance, in MP2 or CCSD, the 2-RDM spans the
whole orbital space and it may not be possible to hold it in
memory. At present, its all designed around MC-SCF, which is
why the <a href="#id35"><span class="problematic" id="id36">``</span></a>kernel function that actually calculates the energy
is in mcpdft.py instead of here.</p>
<dl>
<dt>Attributes:</dt><dd><p>mol : object of class pyscf.gto.mole
grids : object of class pyscf.dft.gen_grid.Grids
eval_ot : function with calling signature shown below
_numint : object of class pyscf.dft.NumInt</p>
<blockquote>
<div><p>member functions hybrid_coeff, nlc_coeff, rsh_coeff,
and _xc_type (at least) must be overloaded; see below</p>
</div></blockquote>
<dl class="simple">
<dt>otxc<span class="classifier">string</span></dt><dd><p>name of on-top pair-density exchange-correlation functional</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.Pi_deriv">
<span class="sig-name descname"><span class="pre">Pi_deriv</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.Pi_deriv" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.dens_deriv">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dens_deriv</span></span><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.dens_deriv" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.energy_ot">
<span class="sig-name descname"><span class="pre">energy_ot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">casdm1s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casdm2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncore</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.energy_ot" title="Link to this definition">#</a></dt>
<dd><p>Compute the on-top energy - the last term in</p>
<p>E_MCPDFT = h_pq l_pq + 1/2 v_pqrs l_pq l_rs + E_ot[rho,Pi]</p>
<dl>
<dt>Args:</dt><dd><p>ot : an instance of otfnal class
casdm1s : ndarray of shape (2, ncas, ncas)</p>
<blockquote>
<div><p>Contains spin-separated one-body density matrices in an
active-orbital basis</p>
</div></blockquote>
<dl class="simple">
<dt>casdm2<span class="classifier">ndarray of shape (ncas, ncas, ncas, ncas)</span></dt><dd><p>Contains spin-summed two-body density matrix in an active-
orbital basis</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray of shape (nao, nmo)</span></dt><dd><p>Contains molecular orbital coefficients for active-space
orbitals. Columns ncore through ncore+ncas give the basis
in which casdm1s and casdm2 are expressed.</p>
</dd>
<dt>ncore<span class="classifier">integer</span></dt><dd><p>Number of doubly occupied inactive core orbitals not
explicitly included in casdm1s and casdm2</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>max_memory<span class="classifier">int or float</span></dt><dd><p>maximum cache size in MB
default is 2000</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>1 if 1rdms are assumed hermitian, 0 otherwise</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">float</span></dt><dd><p>The MC-PDFT on-top (nonclassical) energy</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.eval_ot">
<span class="sig-name descname"><span class="pre">eval_ot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dderiv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#otfnal.eval_ot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.eval_ot" title="Link to this definition">#</a></dt>
<dd><dl>
<dt>Evaluate the on-dop energy and its functional derivatives</dt><dd><p>on a grid</p>
</dd>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id37"><span class="problematic" id="id38">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dderiv<span class="classifier">integer</span></dt><dd><p>Order of derivatives to return</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl>
<dt>eot<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>integrand of the on-top exchange-correlation energy</p>
</dd>
<dt>vot<span class="classifier">(array_like (rho), array_like (Pi)) or None</span></dt><dd><p>first functional derivative of Eot wrt (density, pair-
density) and their derivatives</p>
</dd>
<dt>fot<span class="classifier">ndarray of shape (<a href="#id39"><span class="problematic" id="id40">*</span></a>,ngrids) or None</span></dt><dd><p>second functional derivative of Eot wrt density, pair-
density, and derivatives; first dimension is lower-
triangular matrix elements corresponding to the basis
(rho, Pi, <a href="#id299"><span class="problematic" id="id300">|drho|^2, drho'.dPi, |dPi|</span></a>) stopping at Pi (3
elements) for t-LDA and <a href="#id41"><span class="problematic" id="id42">|</span></a>drho|^2 (6 elements) for t-GGA.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.get_eff_1body">
<span class="sig-name descname"><span class="pre">get_eff_1body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.get_eff_1body" title="Link to this definition">#</a></dt>
<dd><p>Contract the kern with d vrho/ dDpq.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>ao<span class="classifier">ndarray or 2 ndarrays of shape (<a href="#id43"><span class="problematic" id="id44">*</span></a>,ngrids,nao)</span></dt><dd><p>contains values and derivatives of nao.
2 different ndarrays can have different nao but not
different ngrids</p>
</dd>
<dt>weight<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>containing numerical integration weights</p>
</dd>
<dt>kern<span class="classifier">ndarray of shape (<a href="#id45"><span class="problematic" id="id46">*</span></a>,ngrids)</span></dt><dd><p>the derivative of the on-top potential with respect to
density (vrho)/ If not provided, it is calculated.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>non0tab<span class="classifier">ndarray of shape (nblk, nbas)</span></dt><dd><p>Identifies blocks of grid points which are nonzero on
each AO shell so as to exploit sparsity.
If you want the ao array to be in the MO basis, just
leave this as None. If hermi == 0, it only applies
to the bra index ao array, even if the ket index ao
array is the same (so probably always pass hermi = 1
in that case)</p>
</dd>
<dt>shls_slice<span class="classifier">sequence of integers of len 2</span></dt><dd><p>Identifies starting and stopping indices of AO shells</p>
</dd>
<dt>ao_loc<span class="classifier">ndarray of length nbas</span></dt><dd><p>Offset to first AO of each shell</p>
</dd>
<dt>hermi<span class="classifier">integer or logical</span></dt><dd><p>Toggle whether veff is supposed to be a Hermitian matrix
You can still pass two different ao arrays for the bra and
the ket indices, for instance if one of them is supposed to
be a higher derivative. They just have to have the same nao
in that case.</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">ndarray of shape (nao[0],nao[1])</span></dt><dd><p>The 1-body effective term corresponding to kernel times the AOs,
in the atomic-orbital basis. In PDFT this functional is always
spin-symmetric.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.get_eff_2body">
<span class="sig-name descname"><span class="pre">get_eff_2body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aosym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s4'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eff_ao</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.get_eff_2body" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.get_eff_2body_kl">
<span class="sig-name descname"><span class="pre">get_eff_2body_kl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.get_eff_2body_kl" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.get_feff_1body">
<span class="sig-name descname"><span class="pre">get_feff_1body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cPi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.get_feff_1body" title="Link to this definition">#</a></dt>
<dd><p>Get the terms [Delta F]_{pq}</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id47"><span class="problematic" id="id48">*</span></a>,ngrids)</span></dt><dd><p>On-top pair density [and derivatives]</p>
</dd>
<dt>crho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Spin-density [and derivatives] to contract the hessian with</p>
</dd>
<dt>cPi<span class="classifier">ndarray with shape (<a href="#id49"><span class="problematic" id="id50">*</span></a>,ngrids)</span></dt><dd><p>On-top pair density [and derivatives] to contract Hessian with</p>
</dd>
<dt>ao<span class="classifier">ndarray or 2 ndarrays of shape (<a href="#id51"><span class="problematic" id="id52">*</span></a>,ngrids,nao)</span></dt><dd><p>contains values and derivatives of nao. 2 different ndarrays can
have different nao but not different ngrids</p>
</dd>
<dt>weight<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>containing numerical integration weights</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>kern<span class="classifier">ndarray of shape (<a href="#id53"><span class="problematic" id="id54">*</span></a>,ngrids)</span></dt><dd><p>the hessian-vector product. If not provided, it is calculated.</p>
</dd>
<dt>non0tab<span class="classifier">ndarray of shape (nblk, nbas)</span></dt><dd><p>Identifies blocks of grid points which are nonzero on each AO shell
so as to exploit sparsity. If you want the ao array to be in the
MO basis, just leave this as None. If hermi == 0, it only applies
to the bra index ao array, even if the ket index ao array is the
same (so probably always pass hermi = 1 in that case)</p>
</dd>
<dt>shls_slice<span class="classifier">sequence of integers of len 2</span></dt><dd><p>Identifies starting and stopping indices of AO shells</p>
</dd>
<dt>ao_loc<span class="classifier">ndarray of length nbas</span></dt><dd><p>Offset to first AO of each shell</p>
</dd>
<dt>hermi<span class="classifier">integer or logical</span></dt><dd><p>Toggle whether feff is supposed to be a Hermitian matrix You can
still pass two different ao arrays for the bra and the ket indices,
for instance if one of them is supposed to be a higher derivative.
They just have to have the same nao in that case.</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">ndarray of shape (nao[0],nao[1])</span></dt><dd><p>The 1-body effective gradient response corresponding to this on-top
pair density exchange-correlation functional, in the atomic-orbital
basis. In PDFT this functional is always spin-symmetric.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.get_feff_2body">
<span class="sig-name descname"><span class="pre">get_feff_2body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cPi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aosym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s4'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fao</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.get_feff_2body" title="Link to this definition">#</a></dt>
<dd><p>Get the terms [Delta F]_{pqrs}</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id55"><span class="problematic" id="id56">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
<dt>crho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Spin-density [and derivatives] to contract the hessian with</p>
</dd>
<dt>cPi<span class="classifier">ndarray with shape (<a href="#id57"><span class="problematic" id="id58">*</span></a>,ngrids)</span></dt><dd><p>On-top pair density [and derivatives] to contract Hessian with</p>
</dd>
<dt>ao<span class="classifier">ndarray of shape (<a href="#id59"><span class="problematic" id="id60">*</span></a>,ngrids,nao)</span></dt><dd><p>OR list of ndarrays of shape (<em>,ngrids,</em>) values and
derivatives of atomic or molecular orbitals in which space to
calculate the 2-body veff If a list of length 4, the
corresponding set of eri-like elements are returned</p>
</dd>
<dt>weight<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>containing numerical integration weights</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>aosym<span class="classifier">int or str</span></dt><dd><p>Index permutation symmetry of the desired integrals. Valid
options are 1 (or 1 or s1), 4 (or 4 or s4), 2ij (or
s2ij), and 2kl (or s2kl). These have the same meaning as
in PySCFs ao2mo module. Currently all symmetry exploitation is
extremely slow and unparallelizable for some reason so trying
to use this is not recommended until I come up with a C
routine.</p>
</dd>
<dt>kern<span class="classifier">ndarray of shape (<a href="#id61"><span class="problematic" id="id62">*</span></a>,ngrids)</span></dt><dd><p>the hessian-vector product. If not provided, it is calculated.</p>
</dd>
<dt>fao<span class="classifier">ndarray of shape (<a href="#id63"><span class="problematic" id="id64">*</span></a>,ngrids,nao,nao) or</span></dt><dd><p>(<a href="#id65"><span class="problematic" id="id66">*</span></a>,ngrids,nao*(nao+1)//2). An intermediate in which the kernel
and the k,l orbital indices have been contracted. Overrides
kl_symm</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">eri-like ndarray</span></dt><dd><p>The two-body effective gradient response corresponding to this on-top
pair density exchange-correlation functional or elements
thereof, in the provided basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.get_veff_1body">
<span class="sig-name descname"><span class="pre">get_veff_1body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.get_veff_1body" title="Link to this definition">#</a></dt>
<dd><p>get the derivatives dEot / dDpq
Can also be abused to get semidiagonal dEot / dPppqq if you pass the
right kern and squared aos/mos</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id67"><span class="problematic" id="id68">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
<dt>ao<span class="classifier">ndarray or 2 ndarrays of shape (<a href="#id69"><span class="problematic" id="id70">*</span></a>,ngrids,nao)</span></dt><dd><p>contains values and derivatives of nao.
2 different ndarrays can have different nao but not
different ngrids</p>
</dd>
<dt>weight<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>containing numerical integration weights</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>kern<span class="classifier">ndarray of shape (<a href="#id71"><span class="problematic" id="id72">*</span></a>,ngrids)</span></dt><dd><p>the derivative of the on-top potential with respect to
density (vrho)/ If not provided, it is calculated.</p>
</dd>
<dt>non0tab<span class="classifier">ndarray of shape (nblk, nbas)</span></dt><dd><p>Identifies blocks of grid points which are nonzero on
each AO shell so as to exploit sparsity.
If you want the ao array to be in the MO basis, just
leave this as None. If hermi == 0, it only applies
to the bra index ao array, even if the ket index ao
array is the same (so probably always pass hermi = 1
in that case)</p>
</dd>
<dt>shls_slice<span class="classifier">sequence of integers of len 2</span></dt><dd><p>Identifies starting and stopping indices of AO shells</p>
</dd>
<dt>ao_loc<span class="classifier">ndarray of length nbas</span></dt><dd><p>Offset to first AO of each shell</p>
</dd>
<dt>hermi<span class="classifier">integer or logical</span></dt><dd><p>Toggle whether veff is supposed to be a Hermitian matrix
You can still pass two different ao arrays for the bra and
the ket indices, for instance if one of them is supposed to
be a higher derivative. They just have to have the same nao
in that case.</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">ndarray of shape (nao[0],nao[1])</span></dt><dd><p>The 1-body effective potential corresponding to this on-top pair
density exchange-correlation functional, in the atomic-orbital
basis. In PDFT this functional is always spin-symmetric.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.get_veff_2body">
<span class="sig-name descname"><span class="pre">get_veff_2body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aosym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s4'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vao</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.get_veff_2body" title="Link to this definition">#</a></dt>
<dd><p>get the derivatives dEot / dPijkl</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id73"><span class="problematic" id="id74">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
<dt>ao<span class="classifier">ndarray of shape (<a href="#id75"><span class="problematic" id="id76">*</span></a>,ngrids,nao)</span></dt><dd><p>OR list of ndarrays of shape (<em>,ngrids,</em>)
values and derivatives of atomic or molecular orbitals in
which space to calculate the 2-body veff
If a list of length 4, the corresponding set of eri-like
elements are returned</p>
</dd>
<dt>weight<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>containing numerical integration weights</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>aosym<span class="classifier">int or str</span></dt><dd><p>Index permutation symmetry of the desired integrals. Valid
options are 1 (or 1 or s1), 4 (or 4 or s4), 2ij
(or s2ij), and 2kl (or s2kl). These have the same
meaning as in PySCFs ao2mo module. Currently all symmetry
exploitation is extremely slow and unparallelizable for some
reason so trying to use this is not recommended until I come
up with a C routine.</p>
</dd>
<dt>kern<span class="classifier">ndarray of shape (<a href="#id77"><span class="problematic" id="id78">*</span></a>,ngrids)</span></dt><dd><p>the derivative of the on-top potential with respect to pair
density (vot). If not provided, it is calculated.</p>
</dd>
<dt>vao<span class="classifier">ndarray of shape (<a href="#id79"><span class="problematic" id="id80">*</span></a>,ngrids,nao,nao) or</span></dt><dd><p>(<a href="#id81"><span class="problematic" id="id82">*</span></a>,ngrids,nao*(nao+1)//2). An intermediate in which the
kernel and the k,l orbital indices have been contracted.
Overrides kl_symm</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">eri-like ndarray</span></dt><dd><p>The two-body effective potential corresponding to this on-top
pair density exchange-correlation functional or elements
thereof, in the provided basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.get_veff_2body_kl">
<span class="sig-name descname"><span class="pre">get_veff_2body_kl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.get_veff_2body_kl" title="Link to this definition">#</a></dt>
<dd><p>get the two-index intermediate Mkl of dEot/dPijkl</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id83"><span class="problematic" id="id84">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
<dt>ao_k<span class="classifier">ndarray of shape (<a href="#id85"><span class="problematic" id="id86">*</span></a>,ngrids,nao)</span></dt><dd><p>OR list of ndarrays of shape (<em>,ngrids,</em>)
values and derivatives of atomic or molecular orbitals
corresponding to index k</p>
</dd>
<dt>ao_l<span class="classifier">ndarray of shape (<a href="#id87"><span class="problematic" id="id88">*</span></a>,ngrids,nao)</span></dt><dd><p>OR list of ndarrays of shape (<em>,ngrids,</em>)
values and derivatives of atomic or molecular orbitals
corresponding to index l</p>
</dd>
<dt>weight<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>containing numerical integration weights</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>symm<span class="classifier">logical</span></dt><dd><p>Index permutation symmetry of the desired integral wrt k,l</p>
</dd>
<dt>kern<span class="classifier">ndarray of shape (<a href="#id89"><span class="problematic" id="id90">*</span></a>,ngrids)</span></dt><dd><p>the derivative of the on-top potential with respect to pair
density (vot). If not provided, it is calculated.</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">ndarray of shape (<a href="#id91"><span class="problematic" id="id92">*</span></a>,ngrids,nao,nao)</span></dt><dd><p>or (<a href="#id93"><span class="problematic" id="id94">*</span></a>,ngrids,nao*(nao+1)//2). An intermediate for calculating
the two-body effective potential corresponding to this on-top
pair density exchange-correlation functional in the provided
basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#otfnal.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.reset" title="Link to this definition">#</a></dt>
<dd><p>Discard cached grid data and optionally update the mol</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.otfnal.xctype">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">xctype</span></span><a class="headerlink" href="#pyscf.mcpdft.otfnal.otfnal.xctype" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.register_otfnal">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">register_otfnal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preset</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#register_otfnal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.register_otfnal" title="Link to this definition">#</a></dt>
<dd><p>This function registers the new on-top functional if it hasnt been
registered previously.
Args:</p>
<blockquote>
<div><dl>
<dt>xc_code: str</dt><dd><p>The name of the on-top functional to be registered.</p>
</dd>
<dt>preset: dict</dt><dd><p>The dictionary containing the information about the on-top functional
to be registered.
xc_base: str</p>
<blockquote>
<div><p>The name of the underylying KS-functional in the libxc library.</p>
</div></blockquote>
<dl class="simple">
<dt>ext_params: dict, with LibXC exchange and correlation functional integer ID as key, and</dt><dd><p>an array-like object containing the functional parameters as value.</p>
</dd>
<dt>hyb: tuple</dt><dd><p>The hybrid functional parameters.</p>
</dd>
<dt>facs: tuple</dt><dd><p>The mixing factors.</p>
</dd>
<dt>kwargs: dict</dt><dd><p>The additional keyword arguments.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.t_eval_xc">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">t_eval_xc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ni</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relativity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deriv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#t_eval_xc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.t_eval_xc" title="Link to this definition">#</a></dt>
<dd><p>For translated functionals, otxc string = t+xc string
Interface to call libxc library to evaluate XC functional, potential</p>
<blockquote>
<div><p>and functional derivatives.</p>
<ul>
<li><p>The given functional xc_code must be a one-line string.</p></li>
<li><p>The functional xc_code is case-insensitive.</p></li>
<li><p>The functional xc_code string has two parts, separated by ,.  The
first part describes the exchange functional, the second part sets the
correlation functional.</p>
<ul>
<li><p>If , not appeared in string, the entire string is treated as the
name of a compound functional (containing both the exchange and
the correlation functional) which was declared in the functional
aliases list. The full list of functional aliases can be obtained by
calling the function pyscf.dft.xcfun.XC_ALIAS.keys() .</p>
<p>If the string was not found in the aliased functional list, it is
treated as X functional.</p>
</li>
<li><p>To input only X functional (without C functional), leave the second
part blank. E.g. description=slater, means a functional with LDA
contribution only.</p></li>
<li><p>To neglect the contribution of X functional (just apply C functional),
leave blank in the first part, e.g. description=,vwn means a
functional with VWN only.</p></li>
<li><p>If compound XC functional is specified, no matter whether it is in the
X part (the string in front of comma) or the C part (the string behind
comma), both X and C functionals of the compound XC functional will be
used.</p></li>
</ul>
</li>
<li><p>The functional name can be placed in arbitrary order.  Two names need to
be separated by operators + or -.  Blank spaces are ignored.
NOTE the parser only reads operators + - *.  / is not supported.</p></li>
<li><p>A functional name can have at most one factor.  If the factor is not
given, it is set to 1.  Compound functional can be scaled as a unit. For
example 0.5*b3lyp is equivalent to
HF*0.1 + .04*LDA + .36*B88, .405*LYP + .095*VWN</p></li>
<li><p>String HF stands for exact exchange (HF K matrix).  HF can be put in
the correlation functional part (after comma). Putting HF in the
correlation part is the same to putting HF in the exchange part.</p></li>
<li><p>String RSH means range-separated operator. Its format is
RSH(omega, alpha, beta).  Another way to input RSH is to use keywords
SR_HF and LR_HF: SR_HF(0.1) * alpha_plus_beta and LR_HF(0.1) *
alpha where the number in parenthesis is the value of omega.</p></li>
<li><p>Be careful with the libxc convention of GGA functional, in which the LDA
contribution is included.</p></li>
</ul>
<dl>
<dt>Args:</dt><dd><dl>
<dt>xc_code<span class="classifier">str</span></dt><dd><p>A string to describe the linear combination of different XC functionals.
The X and C functional are separated by comma like .8*LDA+.2*B86,VWN.
If HF (exact exchange) is appeared in the string, the HF part will
be skipped.  If an empty string  is given, the returns exc, vxc,
will be vectors of zeros.</p>
</dd>
<dt>rho<span class="classifier">ndarray</span></dt><dd><p>Shape of ((<em>,N)) for electron density (and derivatives) if spin = 0;
Shape of ((</em>,N),(<em>,N)) for alpha/beta electron density (and derivatives) if spin &gt; 0;
where N is number of grids.
rho (</em>,N) are ordered as (den,grad_x,grad_y,grad_z,laplacian,tau)
where grad_x = d/dx den, laplacian = nabla^2 den, tau = 1/2(nabla f)^2
In spin unrestricted case,
rho is ((den_u,grad_xu,grad_yu,grad_zu,laplacian_u,tau_u)</p>
<blockquote>
<div><p>(den_d,grad_xd,grad_yd,grad_zd,laplacian_d,tau_d))</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>spin<span class="classifier">int</span></dt><dd><p>spin polarized if spin &gt; 0</p>
</dd>
<dt>relativity<span class="classifier">int</span></dt><dd><p>No effects.</p>
</dd>
<dt>verbose<span class="classifier">int or object of <code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></span></dt><dd><p>No effects.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>ex, vxc, fxc, kxc</p>
<p>where</p>
<ul>
<li><p>vxc = (vrho, vsigma, vlapl, vtau) for restricted case</p></li>
<li><p>vxc for unrestricted case
| vrho[:,2]   = (u, d)
| vsigma[:,3] = (uu, ud, dd)
| vlapl[:,2]  = (u, d)
| vtau[:,2]   = (u, d)</p></li>
<li><p>fxc for restricted case:
(v2rho2, v2rhosigma, v2sigma2, v2lapl2, v2tau2, v2rholapl, v2rhotau, v2lapltau, v2sigmalapl, v2sigmatau)</p></li>
<li><p>fxc for unrestricted case:
| v2rho2[:,3]     = (u_u, u_d, d_d)
| v2rhosigma[:,6] = (u_uu, u_ud, u_dd, d_uu, d_ud, d_dd)
| v2sigma2[:,6]   = (uu_uu, uu_ud, uu_dd, ud_ud, ud_dd, dd_dd)
| v2lapl2[:,3]
| v2tau2[:,3]     = (u_u, u_d, d_d)
| v2rholapl[:,4]
| v2rhotau[:,4]   = (u_u, u_d, d_u, d_d)
| v2lapltau[:,4]
| v2sigmalapl[:,6]
| v2sigmatau[:,6] = (uu_u, uu_d, ud_u, ud_d, dd_u, dd_d)</p></li>
<li><p>kxc for restricted case:
(v3rho3, v3rho2sigma, v3rhosigma2, v3sigma3,</p>
<blockquote>
<div><p>v3rho2lapl, v3rho2tau,
v3rhosigmalapl, v3rhosigmatau,
v3rholapl2, v3rholapltau, v3rhotau2,
v3sigma2lapl, v3sigma2tau,
v3sigmalapl2, v3sigmalapltau, v3sigmatau2,
v3lapl3, v3lapl2tau, v3lapltau2, v3tau3)</p>
</div></blockquote>
</li>
<li><p>kxc for unrestricted case:
| v3rho3[:,4]         = (u_u_u, u_u_d, u_d_d, d_d_d)
| v3rho2sigma[:,9]    = (u_u_uu, u_u_ud, u_u_dd, u_d_uu, u_d_ud, u_d_dd, d_d_uu, d_d_ud, d_d_dd)
| v3rhosigma2[:,12]   = (u_uu_uu, u_uu_ud, u_uu_dd, u_ud_ud, u_ud_dd, u_dd_dd, d_uu_uu, d_uu_ud, d_uu_dd, d_ud_ud, d_ud_dd, d_dd_dd)
| v3sigma3[:,10]      = (uu_uu_uu, uu_uu_ud, uu_uu_dd, uu_ud_ud, uu_ud_dd, uu_dd_dd, ud_ud_ud, ud_ud_dd, ud_dd_dd, dd_dd_dd)
| v3rho2lapl[:,6]
| v3rho2tau[:,6]      = (u_u_u, u_u_d, u_d_u, u_d_d, d_d_u, d_d_d)
| v3rhosigmalapl[:,12]
| v3rhosigmatau[:,12] = (u_uu_u, u_uu_d, u_ud_u, u_ud_d, u_dd_u, u_dd_d,</p>
<blockquote>
<div><p>d_uu_u, d_uu_d, d_ud_u, d_ud_d, d_dd_u, d_dd_d)</p>
</div></blockquote>
<div class="line-block">
<div class="line">v3rholapl2[:,6]</div>
<div class="line">v3rholapltau[:,8]</div>
<div class="line">v3rhotau2[:,6]      = (u_u_u, u_u_d, u_d_d, d_u_u, d_u_d, d_d_d)</div>
<div class="line">v3sigma2lapl[:,12]</div>
<div class="line">v3sigma2tau[:,12]   = (uu_uu_u, uu_uu_d, uu_ud_u, uu_ud_d, uu_dd_u, uu_dd_d,
ud_ud_u, ud_ud_d, ud_dd_u, ud_dd_d, dd_dd_u, dd_dd_d)</div>
<div class="line">v3sigmalapl2[:,9]</div>
<div class="line">v3sigmalapltau[:,12]</div>
<div class="line">v3sigmatau2[:,9]    = (uu_u_u, uu_u_d, uu_d_d, ud_u_u, ud_u_d, ud_d_d, dd_u_u, dd_u_d, dd_d_d)</div>
<div class="line">v3lapl3[:,4]</div>
<div class="line">v3lapl2tau[:,6]</div>
<div class="line">v3lapltau2[:,6]</div>
<div class="line">v3tau3[:,4]         = (u_u_u, u_u_d, u_d_d, d_d_d)</div>
</div>
</li>
</ul>
<p>see also libxc_itrf.c</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.t_hybrid_coeff">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">t_hybrid_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ni</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#t_hybrid_coeff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.t_hybrid_coeff" title="Link to this definition">#</a></dt>
<dd><p>For translated functionals, otxc string = t+xc string
None</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.t_nlc_coeff">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">t_nlc_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ni</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#t_nlc_coeff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.t_nlc_coeff" title="Link to this definition">#</a></dt>
<dd><p>For translated functionals, otxc string = t+xc string
None</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.t_rsh_and_hybrid_coeff">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">t_rsh_and_hybrid_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ni</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#t_rsh_and_hybrid_coeff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.t_rsh_and_hybrid_coeff" title="Link to this definition">#</a></dt>
<dd><p>For translated functionals, otxc string = t+xc string
Range-separated parameter and HF exchange components: omega, alpha, beta</p>
<blockquote>
<div><dl class="simple">
<dt>Exc_RSH = c_SR * SR_HFX + c_LR * LR_HFX + (1-c_SR) * Ex_SR + (1-c_LR) * Ex_LR + Ec</dt><dd><p>= alpha * HFX + beta * SR_HFX + (1-c_SR) * Ex_SR + (1-c_LR) * Ex_LR + Ec
= alpha * LR_HFX + hyb * SR_HFX + (1-c_SR) * Ex_SR + (1-c_LR) * Ex_LR + Ec</p>
</dd>
</dl>
<p>SR_HFX = &lt; pi | (1-erf(-omega r_{12}))/r_{12} | iq &gt;
LR_HFX = &lt; pi | erf(-omega r_{12})/r_{12} | iq &gt;
alpha = c_LR
beta = c_SR - c_LR</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.t_rsh_coeff">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">t_rsh_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ni</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#t_rsh_coeff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.t_rsh_coeff" title="Link to this definition">#</a></dt>
<dd><p>For translated functionals, otxc string = t+xc string
None</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.t_xc_type">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">t_xc_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ni</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#t_xc_type"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.t_xc_type" title="Link to this definition">#</a></dt>
<dd><p>For translated functionals, otxc string = t+xc string
None</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.transfnal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">transfnal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ks</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#transfnal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.transfnal" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.mcpdft.otfnal.otfnal" title="pyscf.mcpdft.otfnal.otfnal"><code class="xref py py-class docutils literal notranslate"><span class="pre">otfnal</span></code></a></p>
<p>Parent class of on-top pair-density functional. The main
callable is <a href="#id95"><span class="problematic" id="id96">``</span></a>eval_ot, which is comparable to pyscf.dft.libxc
<a href="#id97"><span class="problematic" id="id98">``</span></a>eval_xc. A true <a href="#id99"><span class="problematic" id="id100">``</span></a>kernel method, which would take arbitrary
1- and 2-RDMs and return the total PDFT energy, awaits design
decisions on how far Im willing/able to generalize the otpd
functions. For instance, in MP2 or CCSD, the 2-RDM spans the
whole orbital space and it may not be possible to hold it in
memory. At present, its all designed around MC-SCF, which is
why the <a href="#id101"><span class="problematic" id="id102">``</span></a>kernel function that actually calculates the energy
is in mcpdft.py instead of here.</p>
<dl>
<dt>Attributes:</dt><dd><p>mol : object of class pyscf.gto.mole
grids : object of class pyscf.dft.gen_grid.Grids
eval_ot : function with calling signature shown below
_numint : object of class pyscf.dft.NumInt</p>
<blockquote>
<div><p>member functions hybrid_coeff, nlc_coeff, rsh_coeff,
and _xc_type (at least) must be overloaded; see below</p>
</div></blockquote>
<dl class="simple">
<dt>otxc<span class="classifier">string</span></dt><dd><p>name of on-top pair-density exchange-correlation functional</p>
</dd>
</dl>
</dd>
</dl>
<p><a href="#id103"><span class="problematic" id="id104">``</span></a>translated functional of Li Manni et al., JCTC 10, 3669 (2014).
The extra attributes are all callables; see their docstrings for
more information.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>ks<span class="classifier">object of <code class="xref py py-class docutils literal notranslate"><span class="pre">dft.RKS</span></code></span></dt><dd><p>ks.xc is the Kohn-Sham functional being <a href="#id105"><span class="problematic" id="id106">``</span></a>translated</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.transfnal.d_jT_op">
<span class="sig-name descname"><span class="pre">d_jT_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#transfnal.d_jT_op"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.transfnal.d_jT_op" title="Link to this definition">#</a></dt>
<dd><p>Evaluate the x.(nabla j) contribution to the second density
derivatives of the on-top energy in terms of the untranslated
density and pair density</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>x<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Usually, a functional derivative of the on-top xc energy
wrt translated densities</p>
</dd>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id107"><span class="problematic" id="id108">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
</dl>
</dd>
<dt>Returns: ndarray of shape (<a href="#id109"><span class="problematic" id="id110">*</span></a>,ngrids)</dt><dd><p>second derivative of the translation dotted with x
3 rows for tLDA and 5 rows for tGGA</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.transfnal.eval_ot">
<span class="sig-name descname"><span class="pre">eval_ot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dderiv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_unpack_vot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#transfnal.eval_ot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.transfnal.eval_ot" title="Link to this definition">#</a></dt>
<dd><dl>
<dt>Evaluate the on-dop energy and its functional derivatives</dt><dd><p>on a grid</p>
</dd>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id111"><span class="problematic" id="id112">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dderiv<span class="classifier">integer</span></dt><dd><p>Order of derivatives to return</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl>
<dt>eot<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>integrand of the on-top exchange-correlation energy</p>
</dd>
<dt>vot<span class="classifier">(array_like (rho), array_like (Pi)) or None</span></dt><dd><p>first functional derivative of Eot wrt (density, pair-
density) and their derivatives</p>
</dd>
<dt>fot<span class="classifier">ndarray of shape (<a href="#id113"><span class="problematic" id="id114">*</span></a>,ngrids) or None</span></dt><dd><p>second functional derivative of Eot wrt density, pair-
density, and derivatives; first dimension is lower-
triangular matrix elements corresponding to the basis
(rho, Pi, <a href="#id301"><span class="problematic" id="id302">|drho|^2, drho'.dPi, |dPi|</span></a>) stopping at Pi (3
elements) for t-LDA and <a href="#id115"><span class="problematic" id="id116">|</span></a>drho|^2 (6 elements) for t-GGA.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.transfnal.get_ratio">
<span class="sig-name descname"><span class="pre">get_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho_avg</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#transfnal.get_ratio"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.transfnal.get_ratio" title="Link to this definition">#</a></dt>
<dd><p>R = Pi / [rho/2]^2 = Pi / rho_avg^2
An intermediate quantity when computing the translated spin
densities</p>
<p>Note this function returns 1 for values and 0 for
derivatives for every point where the charge density is
close to zero (i.e., convention: 0/0 = 1)</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>Pi<span class="classifier">ndarray of shape (<a href="#id117"><span class="problematic" id="id118">*</span></a>,ngrids)</span></dt><dd><p>Contains on-top pair density on a grid</p>
</dd>
<dt>rho_avg<span class="classifier">ndarray of shape (<a href="#id119"><span class="problematic" id="id120">*</span></a>,ngrids)</span></dt><dd><p>Contains the average of the spin-up and spin-down
charge densities on a grid, (rho[0]+rho[1])/2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl>
<dt>R<span class="classifier">ndarray of shape (<a href="#id121"><span class="problematic" id="id122">*</span></a>,ngrids)</span></dt><dd><p>on-top ratio</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.transfnal.get_rho_translated">
<span class="sig-name descname"><span class="pre">get_rho_translated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_fn_deriv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#transfnal.get_rho_translated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.transfnal.get_rho_translated" title="Link to this definition">#</a></dt>
<dd><p>Compute the translated alpha and beta densities:
For the unrestricted case,
rho = [rho^a, rho^b]
Here:</p>
<blockquote>
<div><p>rho^a will have dim of 1,4 or 6 depends on the functional. For MGGA,
rho^a = [rho_u,grad_xu, grad_yu, grad_zu, laplacian_u, tau_u]
Similar for rho_b.</p>
</div></blockquote>
<p>The translation is done as follows:</p>
<p>rho_t^a = (rho/2) * (1 + zeta)
rho_t^b = (rho/2) * (1 - zeta)
rho_t^a = (rho/2) * (1 + zeta)
rho_t^b = (rho/2) * (1 - zeta)
tau_t^a = (tau/2) * (1 + zeta)
tau_t^b = (tau/2) * (1 - zeta)</p>
<p>See get_zeta for the meaning of zeta</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>Pi<span class="classifier">ndarray of shape (<a href="#id123"><span class="problematic" id="id124">*</span></a>, ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
<dt>rho<span class="classifier">ndarray of shape (2, <a href="#id125"><span class="problematic" id="id126">*</span></a>, ngrids)</span></dt><dd><p>containing spin density [and derivatives]</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>_fn_deriv<span class="classifier">integer</span></dt><dd><p>Order of functional derivatives of zeta to compute.
In translated functionals, no functional derivatives
of zeta are used. This kwarg is used for convenience
when calling from children classes. It changes the
return signature and should not normally be touched by
users.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>rho_t<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Translated spin density (and derivatives) in case of LDA or GGAs
Translated spin density, derivatives, and kinetic energy density in case of MGGA</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.transfnal.get_zeta">
<span class="sig-name descname"><span class="pre">get_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fn_deriv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_Rmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#transfnal.get_zeta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.transfnal.get_zeta" title="Link to this definition">#</a></dt>
<dd><p>Compute the intermediate zeta used to compute the
translated spin densities and its functional derivatives</p>
<p>From the original translation [Li Manni et al., JCTC 10, 3669
(2014)]:</p>
<dl>
<dt>zeta = (1-ratio)^(1/2) ; ratio &lt; 1</dt><dd><p>= 0               ; otherwise</p>
</dd>
<dt>Args:</dt><dd><dl>
<dt>R<span class="classifier">ndarray of shape (<a href="#id127"><span class="problematic" id="id128">*</span></a>,ngrids)</span></dt><dd><p>Ratio (4Pi/rho^2) and possibly its spatial derivatives
Only the first row is used in this function</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>fn_deriv<span class="classifier">integer</span></dt><dd><p>order of functional derivative (d^n z / dR^n) to return
along with the value of zeta</p>
</dd>
<dt>_Rmax<span class="classifier">float</span></dt><dd><p>maximum value of R for which to compute zeta or its
derivatives; columns of zeta with R[0]&gt;_Rmax are zero.
This is a hook for the <a href="#id129"><span class="problematic" id="id130">``</span></a>fully-translated child class
and should not be touched normally.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>zeta : ndarray of shape (fn_deriv+1, ngrids)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.transfnal.jT_op">
<span class="sig-name descname"><span class="pre">jT_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#transfnal.jT_op"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.transfnal.jT_op" title="Link to this definition">#</a></dt>
<dd><p>Evaluate jTx = (x.j)T where j is the Jacobian of the
translated densities in terms of the untranslated density and
pair density</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>x<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Usually, a functional derivative of the on-top xc energy
wrt translated densities</p>
</dd>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id131"><span class="problematic" id="id132">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
</dl>
</dd>
<dt>Returns: ndarray of shape (<a href="#id133"><span class="problematic" id="id134">*</span></a>,ngrids)</dt><dd><p>Usually, a functional derivative of the on-top pair density
exchange-correlation energy wrt to total density and its
derivatives. The potential must be spin-symmetric in
pair-density functional theory.
2 rows for tLDA, 3 rows for tGGA, and 4 rows for meta-GGA</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.transfnal.split_x_c">
<span class="sig-name descname"><span class="pre">split_x_c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#transfnal.split_x_c"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.transfnal.split_x_c" title="Link to this definition">#</a></dt>
<dd><p>Get one translated functional for just the exchange and one
for just the correlation part of the energy.</p>
<dl>
<dt>Returns:</dt><dd><dl>
<dt>xfnal<span class="classifier">object of <a class="reference internal" href="#pyscf.mcpdft.otfnal.transfnal" title="pyscf.mcpdft.otfnal.transfnal"><code class="xref py py-class docutils literal notranslate"><span class="pre">transfnal</span></code></a></span></dt><dd><p>this functional, but only the exchange part</p>
</dd>
<dt>cfnal<span class="classifier">object of <a class="reference internal" href="#pyscf.mcpdft.otfnal.transfnal" title="pyscf.mcpdft.otfnal.transfnal"><code class="xref py py-class docutils literal notranslate"><span class="pre">transfnal</span></code></a></span></dt><dd><p>this functional, but only the correlation part</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.transfnal.transl_prefix">
<span class="sig-name descname"><span class="pre">transl_prefix</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'t'</span></em><a class="headerlink" href="#pyscf.mcpdft.otfnal.transfnal.transl_prefix" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otfnal.unregister_otfnal">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otfnal.</span></span><span class="sig-name descname"><span class="pre">unregister_otfnal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otfnal.html#unregister_otfnal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otfnal.unregister_otfnal" title="Link to this definition">#</a></dt>
<dd><p>This function unregisters the on-top functional if it has been registered
previously.
Args:</p>
<blockquote>
<div><dl class="simple">
<dt>xc_code: str</dt><dd><p>The name of the on-top functional to be unregistered.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

</section>
<section id="module-pyscf.mcpdft.otpd">
<span id="pyscf-mcpdft-otpd-module"></span><h2>pyscf.mcpdft.otpd module<a class="headerlink" href="#module-pyscf.mcpdft.otpd" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otpd.density_orbital_derivative">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otpd.</span></span><span class="sig-name descname"><span class="pre">density_orbital_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncore</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">casdm1s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cascm2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deriv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otpd.html#density_orbital_derivative"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otpd.density_orbital_derivative" title="Link to this definition">#</a></dt>
<dd><p>Compute the half-transformed density and 3/4-transformed pair-
density matrix:</p>
<p>D_i(r) = sum_j D_ij phi_j(r)
d_i(r) = sum_jkl d_ijkl phi_j(r) phi_k(r) phi_l(r)</p>
<p>so that, for instance, the derivative with respect to orbital
rotations of the density and pair density are</p>
<p>d/dk_ij rho(r) = phi_i(r) D_j(r) - phi_j(r) D_k(r)
d/dk_ij Pi(r) = i(r) d_j(r) - j(r) d_i(r)</p>
<p>and the derivatives with respect to nuclear displacement are</p>
<p>drho/dRA|(r not in A) = -sum_(mu in A) phi_mu(r) D_mu(r)
drho/dRA|(r in A) = +sum_(mu not in A) phi_mu(r) D_mu(r)
dPi/dRA|(r not in A) = -sum_(mu in A) phi_mu(r) d_mu(r)
dPi/dRA|(r in A) = +sum_(mu not in A) phi_mu(r) d_mu(r)</p>
<p>There is a mismatch between the ndarray shape and the data layout in
the arg <cite>mo</cite> and the two return arrays. For performance reasons, the
grid index should be contiguous in memory for every array with a
a grid dimension. However, by convention, in PySCF ndarrays with
grid and orbital indices place the latter index in the last
position, the former in the second-to-last position, and any other
before that in row-major order. That is, for a four-index array of
this type, transpose (2,3,1,0) gives a contiguous column-major array,
and transpose (0,1,3,2) results in a contiguous row-major array.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>ot<span class="classifier">object of <code class="xref py py-class docutils literal notranslate"><span class="pre">otfnal</span></code></span></dt><dd><p>The on-top density functional containing grid information</p>
</dd>
<dt>ncore<span class="classifier">integer</span></dt><dd><p>Number of doubly-occupied core orbitals</p>
</dd>
<dt>ncas<span class="classifier">integer</span></dt><dd><p>Number of active orbitals</p>
</dd>
<dt>casdm1s<span class="classifier">ndarray of shape (2,ncas,ncas)</span></dt><dd><p>Spin-separated one-body reduced density matrix</p>
</dd>
<dt>cascm2<span class="classifier">ndarray of shape [ncas,]*4</span></dt><dd><p>Spin-summed cumulant of two-body reduced density matrix</p>
</dd>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Spin-separated density (and derivatives) on a grid</p>
</dd>
<dt>mo<span class="classifier">ndarray of shape (<a href="#id135"><span class="problematic" id="id136">*</span></a>,ngrids,nmo)</span></dt><dd><p>Molecular orbitals (and derivatives) evaluated on a grid.
Data stride must be 0&gt;2&gt;1; i.e., mo.transpose (0,2,1) must
be a contiguous row-major array.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>deriv<span class="classifier">integer</span></dt><dd><p>Order of derivatives of half-transformed density to compute;
i.e., 0 for LDA and 1 for GGA</p>
</dd>
<dt>non0tab<span class="classifier">2D boolean array</span></dt><dd><p>Mask array to determine whether densities are considered to
be numerically zero</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl>
<dt>drho<span class="classifier">ndarray of shape (2,*,ngrids,nmo)</span></dt><dd><p>Half-transformed density matrix on a grid and its
derivatives. Data stride is 0&gt;1&gt;3&gt;2; i.e.,
drho.transpose (0,1,3,2) is a contiguous row-major array.</p>
</dd>
<dt>dPi<span class="classifier">ndarray of shape (<a href="#id137"><span class="problematic" id="id138">*</span></a>,ngrids,nmo)</span></dt><dd><p>3/4-transformed pair density matrix on a grid and its
derivatives. Data stride is 0&gt;2&gt;1; i.e.,
dPi.transpose (0,2,1) is a contiguous row-major array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.otpd.get_ontop_pair_density">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.otpd.</span></span><span class="sig-name descname"><span class="pre">get_ontop_pair_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cascm2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_cas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deriv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/otpd.html#get_ontop_pair_density"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.otpd.get_ontop_pair_density" title="Link to this definition">#</a></dt>
<dd><p>Compute the on-top pair density and its derivatives on a grid:</p>
<dl>
<dt>Pi(r) = i(r)*j(r)*k(r)*l(r)*d_ijkl / 2</dt><dd><p>= rho[0](r)*rho[1](r) + i(r)*j(r)*k(r)*l(r)*l_ijkl / 2</p>
</dd>
<dt>Args:</dt><dd><p>ot : on-top pair density functional object
rho : ndarray of shape (2,*,ngrids)</p>
<blockquote>
<div><p>Contains spin-separated density [and derivatives]. The dm1s
underlying these densities must correspond to the dm1s/dm1
in the expression for cascm2 below.</p>
</div></blockquote>
<dl>
<dt>ao<span class="classifier">ndarray of shape (<a href="#id139"><span class="problematic" id="id140">*</span></a>, ngrids, nao)</span></dt><dd><p>contains values of aos [and derivatives]</p>
</dd>
<dt>cascm2<span class="classifier">ndarray of shape [ncas,]*4</span></dt><dd><p>contains spin-summed two-body cumulant density matrix in an
active-orbital basis given by mo_cas:</p>
<blockquote>
<div><dl class="simple">
<dt>cm2[u,v,x,y] = dm2[u,v,x,y] - dm1[u,v]*dm1[x,y]</dt><dd><ul class="simple">
<li><p>dm1s[0][u,y]*dm1s[0][x,v]</p></li>
<li><p>dm1s[1][u,y]*dm1s[1][x,v]</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>where dm1 = dm1s[0] + dm1s[1]. The cumulant (cm2) has no
nonzero elements for any index outside the active space,
unlike the density matrix (dm2), which formally has elements
involving uncorrelated, doubly-occupied <a href="#id141"><span class="problematic" id="id142">``</span></a>core orbitals
which are not usually computed explicitly:</p>
<blockquote>
<div><p>dm2[i,i,u,v] = dm2[u,v,i,i] = 2*dm1[u,v]
dm2[u,i,i,v] = dm2[i,v,u,i] = -dm1[u,v]</p>
</div></blockquote>
</dd>
<dt>mo_cas<span class="classifier">ndarray of shape (nao, ncas)</span></dt><dd><p>molecular-orbital coefficients for active-space orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>deriv<span class="classifier">derivative order through which to calculate.</span></dt><dd><p>deriv &gt; 1 not implemented</p>
</dd>
</dl>
<p>non0tab : as in pyscf.dft.gen_grid and pyscf.dft.numint</p>
</dd>
<dt>Returns<span class="classifier">ndarray of shape (<a href="#id143"><span class="problematic" id="id144">*</span></a>,ngrids)</span></dt><dd><p>The on-top pair density and its derivatives if requested
deriv = 0 : value (1d array)
deriv = 1 : value, d/dx, d/dy, d/dz
deriv = 2 : value, d/dx, d/dy, d/dz, d^2/d|r1-r2|^2_(r1=r2)</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyscf.mcpdft.pdft_eff">
<span id="pyscf-mcpdft-pdft-eff-module"></span><h2>pyscf.mcpdft.pdft_eff module<a class="headerlink" href="#module-pyscf.mcpdft.pdft_eff" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.pdft_eff.get_eff_1body">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.pdft_eff.</span></span><span class="sig-name descname"><span class="pre">get_eff_1body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">otfnal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/pdft_eff.html#get_eff_1body"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.pdft_eff.get_eff_1body" title="Link to this definition">#</a></dt>
<dd><p>Contract the kern with d vrho/ dDpq.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>ao<span class="classifier">ndarray or 2 ndarrays of shape (<a href="#id145"><span class="problematic" id="id146">*</span></a>,ngrids,nao)</span></dt><dd><p>contains values and derivatives of nao.
2 different ndarrays can have different nao but not
different ngrids</p>
</dd>
<dt>weight<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>containing numerical integration weights</p>
</dd>
<dt>kern<span class="classifier">ndarray of shape (<a href="#id147"><span class="problematic" id="id148">*</span></a>,ngrids)</span></dt><dd><p>the derivative of the on-top potential with respect to
density (vrho)/ If not provided, it is calculated.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>non0tab<span class="classifier">ndarray of shape (nblk, nbas)</span></dt><dd><p>Identifies blocks of grid points which are nonzero on
each AO shell so as to exploit sparsity.
If you want the ao array to be in the MO basis, just
leave this as None. If hermi == 0, it only applies
to the bra index ao array, even if the ket index ao
array is the same (so probably always pass hermi = 1
in that case)</p>
</dd>
<dt>shls_slice<span class="classifier">sequence of integers of len 2</span></dt><dd><p>Identifies starting and stopping indices of AO shells</p>
</dd>
<dt>ao_loc<span class="classifier">ndarray of length nbas</span></dt><dd><p>Offset to first AO of each shell</p>
</dd>
<dt>hermi<span class="classifier">integer or logical</span></dt><dd><p>Toggle whether veff is supposed to be a Hermitian matrix
You can still pass two different ao arrays for the bra and
the ket indices, for instance if one of them is supposed to
be a higher derivative. They just have to have the same nao
in that case.</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">ndarray of shape (nao[0],nao[1])</span></dt><dd><p>The 1-body effective term corresponding to kernel times the AOs,
in the atomic-orbital basis. In PDFT this functional is always
spin-symmetric.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.pdft_eff.get_eff_2body">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.pdft_eff.</span></span><span class="sig-name descname"><span class="pre">get_eff_2body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">otfnal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aosym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s4'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eff_ao</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/pdft_eff.html#get_eff_2body"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.pdft_eff.get_eff_2body" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.pdft_eff.get_eff_2body_kl">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.pdft_eff.</span></span><span class="sig-name descname"><span class="pre">get_eff_2body_kl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/pdft_eff.html#get_eff_2body_kl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.pdft_eff.get_eff_2body_kl" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="module-pyscf.mcpdft.pdft_feff">
<span id="pyscf-mcpdft-pdft-feff-module"></span><h2>pyscf.mcpdft.pdft_feff module<a class="headerlink" href="#module-pyscf.mcpdft.pdft_feff" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.pdft_feff.get_feff_1body">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.pdft_feff.</span></span><span class="sig-name descname"><span class="pre">get_feff_1body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">otfnal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cPi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/pdft_feff.html#get_feff_1body"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.pdft_feff.get_feff_1body" title="Link to this definition">#</a></dt>
<dd><p>Get the terms [Delta F]_{pq}</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id149"><span class="problematic" id="id150">*</span></a>,ngrids)</span></dt><dd><p>On-top pair density [and derivatives]</p>
</dd>
<dt>crho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Spin-density [and derivatives] to contract the hessian with</p>
</dd>
<dt>cPi<span class="classifier">ndarray with shape (<a href="#id151"><span class="problematic" id="id152">*</span></a>,ngrids)</span></dt><dd><p>On-top pair density [and derivatives] to contract Hessian with</p>
</dd>
<dt>ao<span class="classifier">ndarray or 2 ndarrays of shape (<a href="#id153"><span class="problematic" id="id154">*</span></a>,ngrids,nao)</span></dt><dd><p>contains values and derivatives of nao. 2 different ndarrays can
have different nao but not different ngrids</p>
</dd>
<dt>weight<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>containing numerical integration weights</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>kern<span class="classifier">ndarray of shape (<a href="#id155"><span class="problematic" id="id156">*</span></a>,ngrids)</span></dt><dd><p>the hessian-vector product. If not provided, it is calculated.</p>
</dd>
<dt>non0tab<span class="classifier">ndarray of shape (nblk, nbas)</span></dt><dd><p>Identifies blocks of grid points which are nonzero on each AO shell
so as to exploit sparsity. If you want the ao array to be in the
MO basis, just leave this as None. If hermi == 0, it only applies
to the bra index ao array, even if the ket index ao array is the
same (so probably always pass hermi = 1 in that case)</p>
</dd>
<dt>shls_slice<span class="classifier">sequence of integers of len 2</span></dt><dd><p>Identifies starting and stopping indices of AO shells</p>
</dd>
<dt>ao_loc<span class="classifier">ndarray of length nbas</span></dt><dd><p>Offset to first AO of each shell</p>
</dd>
<dt>hermi<span class="classifier">integer or logical</span></dt><dd><p>Toggle whether feff is supposed to be a Hermitian matrix You can
still pass two different ao arrays for the bra and the ket indices,
for instance if one of them is supposed to be a higher derivative.
They just have to have the same nao in that case.</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">ndarray of shape (nao[0],nao[1])</span></dt><dd><p>The 1-body effective gradient response corresponding to this on-top
pair density exchange-correlation functional, in the atomic-orbital
basis. In PDFT this functional is always spin-symmetric.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.pdft_feff.get_feff_2body">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.pdft_feff.</span></span><span class="sig-name descname"><span class="pre">get_feff_2body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">otfnal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cPi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aosym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s4'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fao</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/pdft_feff.html#get_feff_2body"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.pdft_feff.get_feff_2body" title="Link to this definition">#</a></dt>
<dd><p>Get the terms [Delta F]_{pqrs}</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id157"><span class="problematic" id="id158">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
<dt>crho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Spin-density [and derivatives] to contract the hessian with</p>
</dd>
<dt>cPi<span class="classifier">ndarray with shape (<a href="#id159"><span class="problematic" id="id160">*</span></a>,ngrids)</span></dt><dd><p>On-top pair density [and derivatives] to contract Hessian with</p>
</dd>
<dt>ao<span class="classifier">ndarray of shape (<a href="#id161"><span class="problematic" id="id162">*</span></a>,ngrids,nao)</span></dt><dd><p>OR list of ndarrays of shape (<em>,ngrids,</em>) values and
derivatives of atomic or molecular orbitals in which space to
calculate the 2-body veff If a list of length 4, the
corresponding set of eri-like elements are returned</p>
</dd>
<dt>weight<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>containing numerical integration weights</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>aosym<span class="classifier">int or str</span></dt><dd><p>Index permutation symmetry of the desired integrals. Valid
options are 1 (or 1 or s1), 4 (or 4 or s4), 2ij (or
s2ij), and 2kl (or s2kl). These have the same meaning as
in PySCFs ao2mo module. Currently all symmetry exploitation is
extremely slow and unparallelizable for some reason so trying
to use this is not recommended until I come up with a C
routine.</p>
</dd>
<dt>kern<span class="classifier">ndarray of shape (<a href="#id163"><span class="problematic" id="id164">*</span></a>,ngrids)</span></dt><dd><p>the hessian-vector product. If not provided, it is calculated.</p>
</dd>
<dt>fao<span class="classifier">ndarray of shape (<a href="#id165"><span class="problematic" id="id166">*</span></a>,ngrids,nao,nao) or</span></dt><dd><p>(<a href="#id167"><span class="problematic" id="id168">*</span></a>,ngrids,nao*(nao+1)//2). An intermediate in which the kernel
and the k,l orbital indices have been contracted. Overrides
kl_symm</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">eri-like ndarray</span></dt><dd><p>The two-body effective gradient response corresponding to this on-top
pair density exchange-correlation functional or elements
thereof, in the provided basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.pdft_feff.get_feff_2body_kl">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.pdft_feff.</span></span><span class="sig-name descname"><span class="pre">get_feff_2body_kl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">otfnal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cPi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/pdft_feff.html#get_feff_2body_kl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.pdft_feff.get_feff_2body_kl" title="Link to this definition">#</a></dt>
<dd><p>get the two-index intermediate Mkl of [Delta cdot F]_{pqrs}</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id169"><span class="problematic" id="id170">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
<dt>crho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>Spin-density [and derivatives] to contract the hessian with</p>
</dd>
<dt>cPi<span class="classifier">ndarray with shape (<a href="#id171"><span class="problematic" id="id172">*</span></a>,ngrids)</span></dt><dd><p>On-top pair density [and derivatives] to contract Hessian with</p>
</dd>
<dt>ao_k<span class="classifier">ndarray of shape (<a href="#id173"><span class="problematic" id="id174">*</span></a>,ngrids,nao)</span></dt><dd><p>OR list of ndarrays of shape (<em>,ngrids,</em>) values and
derivatives of atomic or molecular orbitals corresponding to
index k</p>
</dd>
<dt>ao_l<span class="classifier">ndarray of shape (<a href="#id175"><span class="problematic" id="id176">*</span></a>,ngrids,nao)</span></dt><dd><p>OR list of ndarrays of shape (<em>,ngrids,</em>) values and
derivatives of atomic or molecular orbitals corresponding to
index l</p>
</dd>
<dt>weight<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>containing numerical integration weights</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>symm<span class="classifier">logical</span></dt><dd><p>Index permutation symmetry of the desired integral wrt k,l</p>
</dd>
<dt>kern<span class="classifier">ndarray of shape (<a href="#id177"><span class="problematic" id="id178">*</span></a>,ngrids)</span></dt><dd><p>the hessian-vector product. If not provided, it is calculated.</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">ndarray of shape (<a href="#id179"><span class="problematic" id="id180">*</span></a>,ngrids,nao,nao)</span></dt><dd><p>or (<a href="#id181"><span class="problematic" id="id182">*</span></a>,ngrids,nao*(nao+1)//2). An intermediate for calculating the
two-body effective gradient response corresponding to this on-top
pair density exchange-correlation functional in the provided basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.pdft_feff.kernel">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.pdft_feff.</span></span><span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cascm2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_dm1s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_cascm2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncore</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paaa_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aaaa_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jk_pc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/pdft_feff.html#kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.pdft_feff.kernel" title="Link to this definition">#</a></dt>
<dd><p>Get the 1- and 2-body effective gradient responses from MC-PDFT. The
$rho cdot mathbf{F}$ terms, or Hessian vector products.</p>
<dl>
<dt>Args:</dt><dd><p>ot : an instance of otfnal class
dm1s : ndarray of shape (2, nao, nao)</p>
<blockquote>
<div><p>Contains the spin-separated one-body density matrices to evaluate
the kernel at</p>
</div></blockquote>
<dl class="simple">
<dt>cascm2<span class="classifier">ndarray of shape (ncas, ncas, ncas, ncas)</span></dt><dd><p>Spin-summed two-body cumulant density matrix in the active space to
evaluate the kernel at</p>
</dd>
<dt>c_dm1s<span class="classifier">ndarray of shape (2, nao, nao)</span></dt><dd><p>Contains the spin-separated one-body density matrices to contract
the kernel with.</p>
</dd>
<dt>c_cascm2<span class="classifier">ndarray of shape (ncas, ncas, ncas, ncas)</span></dt><dd><p>Spin-summed two-body cumulant density matrix in the active space to
contract the kernel with.</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray of shape (nao, nmo)</span></dt><dd><p>containing molecular orbital coefficients</p>
</dd>
<dt>ncore<span class="classifier">integer</span></dt><dd><p>number of inactive orbitals</p>
</dd>
<dt>ncas<span class="classifier">integer</span></dt><dd><p>number of active orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>max_memory<span class="classifier">int or float</span></dt><dd><p>maximum cache size in MB
default is 2000</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>1 if 1rdms are assumed hermitian, 0 otherwise</p>
</dd>
<dt>paaa_only<span class="classifier">logical</span></dt><dd><p>If true, only compute the paaa range of papa and ppaa (all other
elements set to zero)</p>
</dd>
<dt>aaaa_only<span class="classifier">logical</span></dt><dd><p>If true, only compute the aaaa range of papa and ppaa (all other
elements set to zero; overrides paaa_only)</p>
</dd>
<dt>jk_pc<span class="classifier">logical</span></dt><dd><p>If true, compute the ppii=pipi elements of veff2 (otherwise, these
are set to zero)</p>
</dd>
<dt>delta<span class="classifier">logical</span></dt><dd><p>If true, then contract with the delta density. The delta density is the c_dm1s-dm1s and similarly for the
2rdm element (though care is taken since 2rdm elements are expressed in cumulant form).</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>feff1<span class="classifier">ndarray of shape (nao, nao)</span></dt><dd><p>1-body effective gradient response</p>
</dd>
<dt>feff2<span class="classifier">object of class pdft_eff._ERIS</span></dt><dd><p>2-body effective gradient response</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.pdft_feff.lazy_kernel">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.pdft_feff.</span></span><span class="sig-name descname"><span class="pre">lazy_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cascm2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_dm1s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_cascm2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_cas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/pdft_feff.html#lazy_kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.pdft_feff.lazy_kernel" title="Link to this definition">#</a></dt>
<dd><p>1- and 2-body gradient response (hessian-vector products) from MC-PDFT.
This is the lazy way and doesnt care about memory.</p>
</dd></dl>

</section>
<section id="module-pyscf.mcpdft.pdft_veff">
<span id="pyscf-mcpdft-pdft-veff-module"></span><h2>pyscf.mcpdft.pdft_veff module<a class="headerlink" href="#module-pyscf.mcpdft.pdft_veff" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.pdft_veff.get_veff_1body">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.pdft_veff.</span></span><span class="sig-name descname"><span class="pre">get_veff_1body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">otfnal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/pdft_veff.html#get_veff_1body"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.pdft_veff.get_veff_1body" title="Link to this definition">#</a></dt>
<dd><p>get the derivatives dEot / dDpq
Can also be abused to get semidiagonal dEot / dPppqq if you pass the
right kern and squared aos/mos</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id183"><span class="problematic" id="id184">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
<dt>ao<span class="classifier">ndarray or 2 ndarrays of shape (<a href="#id185"><span class="problematic" id="id186">*</span></a>,ngrids,nao)</span></dt><dd><p>contains values and derivatives of nao.
2 different ndarrays can have different nao but not
different ngrids</p>
</dd>
<dt>weight<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>containing numerical integration weights</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>kern<span class="classifier">ndarray of shape (<a href="#id187"><span class="problematic" id="id188">*</span></a>,ngrids)</span></dt><dd><p>the derivative of the on-top potential with respect to
density (vrho)/ If not provided, it is calculated.</p>
</dd>
<dt>non0tab<span class="classifier">ndarray of shape (nblk, nbas)</span></dt><dd><p>Identifies blocks of grid points which are nonzero on
each AO shell so as to exploit sparsity.
If you want the ao array to be in the MO basis, just
leave this as None. If hermi == 0, it only applies
to the bra index ao array, even if the ket index ao
array is the same (so probably always pass hermi = 1
in that case)</p>
</dd>
<dt>shls_slice<span class="classifier">sequence of integers of len 2</span></dt><dd><p>Identifies starting and stopping indices of AO shells</p>
</dd>
<dt>ao_loc<span class="classifier">ndarray of length nbas</span></dt><dd><p>Offset to first AO of each shell</p>
</dd>
<dt>hermi<span class="classifier">integer or logical</span></dt><dd><p>Toggle whether veff is supposed to be a Hermitian matrix
You can still pass two different ao arrays for the bra and
the ket indices, for instance if one of them is supposed to
be a higher derivative. They just have to have the same nao
in that case.</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">ndarray of shape (nao[0],nao[1])</span></dt><dd><p>The 1-body effective potential corresponding to this on-top pair
density exchange-correlation functional, in the atomic-orbital
basis. In PDFT this functional is always spin-symmetric.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.pdft_veff.get_veff_2body">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.pdft_veff.</span></span><span class="sig-name descname"><span class="pre">get_veff_2body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">otfnal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aosym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s4'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vao</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/pdft_veff.html#get_veff_2body"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.pdft_veff.get_veff_2body" title="Link to this definition">#</a></dt>
<dd><p>get the derivatives dEot / dPijkl</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id189"><span class="problematic" id="id190">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
<dt>ao<span class="classifier">ndarray of shape (<a href="#id191"><span class="problematic" id="id192">*</span></a>,ngrids,nao)</span></dt><dd><p>OR list of ndarrays of shape (<em>,ngrids,</em>)
values and derivatives of atomic or molecular orbitals in
which space to calculate the 2-body veff
If a list of length 4, the corresponding set of eri-like
elements are returned</p>
</dd>
<dt>weight<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>containing numerical integration weights</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>aosym<span class="classifier">int or str</span></dt><dd><p>Index permutation symmetry of the desired integrals. Valid
options are 1 (or 1 or s1), 4 (or 4 or s4), 2ij
(or s2ij), and 2kl (or s2kl). These have the same
meaning as in PySCFs ao2mo module. Currently all symmetry
exploitation is extremely slow and unparallelizable for some
reason so trying to use this is not recommended until I come
up with a C routine.</p>
</dd>
<dt>kern<span class="classifier">ndarray of shape (<a href="#id193"><span class="problematic" id="id194">*</span></a>,ngrids)</span></dt><dd><p>the derivative of the on-top potential with respect to pair
density (vot). If not provided, it is calculated.</p>
</dd>
<dt>vao<span class="classifier">ndarray of shape (<a href="#id195"><span class="problematic" id="id196">*</span></a>,ngrids,nao,nao) or</span></dt><dd><p>(<a href="#id197"><span class="problematic" id="id198">*</span></a>,ngrids,nao*(nao+1)//2). An intermediate in which the
kernel and the k,l orbital indices have been contracted.
Overrides kl_symm</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">eri-like ndarray</span></dt><dd><p>The two-body effective potential corresponding to this on-top
pair density exchange-correlation functional or elements
thereof, in the provided basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.pdft_veff.get_veff_2body_kl">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.pdft_veff.</span></span><span class="sig-name descname"><span class="pre">get_veff_2body_kl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">otfnal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/pdft_veff.html#get_veff_2body_kl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.pdft_veff.get_veff_2body_kl" title="Link to this definition">#</a></dt>
<dd><p>get the two-index intermediate Mkl of dEot/dPijkl</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id199"><span class="problematic" id="id200">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
<dt>ao_k<span class="classifier">ndarray of shape (<a href="#id201"><span class="problematic" id="id202">*</span></a>,ngrids,nao)</span></dt><dd><p>OR list of ndarrays of shape (<em>,ngrids,</em>)
values and derivatives of atomic or molecular orbitals
corresponding to index k</p>
</dd>
<dt>ao_l<span class="classifier">ndarray of shape (<a href="#id203"><span class="problematic" id="id204">*</span></a>,ngrids,nao)</span></dt><dd><p>OR list of ndarrays of shape (<em>,ngrids,</em>)
values and derivatives of atomic or molecular orbitals
corresponding to index l</p>
</dd>
<dt>weight<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>containing numerical integration weights</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>symm<span class="classifier">logical</span></dt><dd><p>Index permutation symmetry of the desired integral wrt k,l</p>
</dd>
<dt>kern<span class="classifier">ndarray of shape (<a href="#id205"><span class="problematic" id="id206">*</span></a>,ngrids)</span></dt><dd><p>the derivative of the on-top potential with respect to pair
density (vot). If not provided, it is calculated.</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">ndarray of shape (<a href="#id207"><span class="problematic" id="id208">*</span></a>,ngrids,nao,nao)</span></dt><dd><p>or (<a href="#id209"><span class="problematic" id="id210">*</span></a>,ngrids,nao*(nao+1)//2). An intermediate for calculating
the two-body effective potential corresponding to this on-top
pair density exchange-correlation functional in the provided
basis.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.pdft_veff.kernel">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.pdft_veff.</span></span><span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cascm2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncore</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">paaa_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aaaa_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jk_pc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/pdft_veff.html#kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.pdft_veff.kernel" title="Link to this definition">#</a></dt>
<dd><p>Get the 1- and 2-body effective potential from MC-PDFT.</p>
<dl>
<dt>Args:</dt><dd><p>ot : an instance of otfnal class
dm1s : ndarray of shape (2, nao, nao)</p>
<blockquote>
<div><p>containing spin-separated one-body density matrices</p>
</div></blockquote>
<dl class="simple">
<dt>cascm2<span class="classifier">ndarray of shape (ncas, ncas, ncas, ncas)</span></dt><dd><p>containing spin-summed two-body cumulant density matrix in
an active space</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray of shape (nao, nmo)</span></dt><dd><p>containing molecular orbital coefficients</p>
</dd>
<dt>ncore<span class="classifier">integer</span></dt><dd><p>number of inactive orbitals</p>
</dd>
<dt>ncas<span class="classifier">integer</span></dt><dd><p>number of active orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>max_memory<span class="classifier">int or float</span></dt><dd><p>maximum cache size in MB
default is 2000</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>1 if 1rdms are assumed hermitian, 0 otherwise</p>
</dd>
<dt>paaa_only<span class="classifier">logical</span></dt><dd><p>If true, only compute the paaa range of papa and ppaa
(all other elements set to zero)</p>
</dd>
<dt>aaaa_only<span class="classifier">logical</span></dt><dd><p>If true, only compute the aaaa range of papa and ppaa
(all other elements set to zero; overrides paaa_only)</p>
</dd>
<dt>jk_pc<span class="classifier">logical</span></dt><dd><p>If true, compute the ppii=pipi elements of veff2
(otherwise, these are set to zero)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>veff1<span class="classifier">ndarray of shape (nao, nao)</span></dt><dd><p>1-body effective potential</p>
</dd>
<dt>veff2<span class="classifier">object of class pdft_eff._ERIS</span></dt><dd><p>2-body effective potential and related quantities</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.pdft_veff.lazy_kernel">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.pdft_veff.</span></span><span class="sig-name descname"><span class="pre">lazy_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cascm2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_cas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">veff2_mo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/pdft_veff.html#lazy_kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.pdft_veff.lazy_kernel" title="Link to this definition">#</a></dt>
<dd><p>Get the 1- and 2-body effective potential from MC-PDFT.
Eventually Ill be able to specify mo slices for the 2-body part</p>
<dl>
<dt>Args:</dt><dd><p>ot : an instance of otfnal class
dm1s : ndarray of shape (2, nao, nao)</p>
<blockquote>
<div><p>containing spin-separated one-body density matrices</p>
</div></blockquote>
<dl class="simple">
<dt>cascm2<span class="classifier">ndarray of shape (ncas, ncas, ncas, ncas)</span></dt><dd><p>containing spin-summed two-body cumulant density matrix
in an active space</p>
</dd>
<dt>mo_cas<span class="classifier">ndarray of shape (nao, ncas)</span></dt><dd><p>containing molecular orbital coefficients for
active-space orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>max_memory<span class="classifier">int or float</span></dt><dd><p>maximum cache size in MB
default is 2000</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>1 if 1rdms are assumed hermitian, 0 otherwise</p>
</dd>
</dl>
</dd>
<dt>Returns<span class="classifier">float</span></dt><dd><p>The MC-PDFT on-top exchange-correlation energy</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyscf.mcpdft.tfnal_derivs">
<span id="pyscf-mcpdft-tfnal-derivs-module"></span><h2>pyscf.mcpdft.tfnal_derivs module<a class="headerlink" href="#module-pyscf.mcpdft.tfnal_derivs" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.tfnal_derivs.contract_fot">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.tfnal_derivs.</span></span><span class="sig-name descname"><span class="pre">contract_fot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">otfnal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unpack</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vot_packed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/tfnal_derivs.html#contract_fot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.tfnal_derivs.contract_fot" title="Link to this definition">#</a></dt>
<dd><p>Evaluate the product of a packed lower-triangular matrix
with perturbed density, pair density, and derivatives.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>fot<span class="classifier">ndarray of shape (<a href="#id211"><span class="problematic" id="id212">*</span></a>,ngrids)</span></dt><dd><p>Lower-triangular matrix elements corresponding to the basis
(rho, Pi, <a href="#id213"><span class="problematic" id="id214">|</span></a>drho|^2, drho.dPi, <a href="#id215"><span class="problematic" id="id216">|</span></a>dPi|^2) stopping at Pi (3
elements) for <a href="#id217"><span class="problematic" id="id218">*</span></a>tLDA and <a href="#id219"><span class="problematic" id="id220">|</span></a>drho|^2 (6 elements) for tGGA.</p>
</dd>
<dt>rho0<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing density [and derivatives]
the density at which fot was evaluated</p>
</dd>
<dt>Pi0<span class="classifier">ndarray with shape (<a href="#id221"><span class="problematic" id="id222">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]
the density at which fot was evaluated</p>
</dd>
<dt>rho1<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing density [and derivatives]
the density contracted with fot</p>
</dd>
<dt>Pi1<span class="classifier">ndarray with shape (<a href="#id223"><span class="problematic" id="id224">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]
the density contracted with fot</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>unpack<span class="classifier">logical</span></dt><dd><dl class="simple">
<dt>If True, returns vot1 in unpacked shape:</dt><dd><dl class="simple">
<dt>(ndarray of shape (<a href="#id225"><span class="problematic" id="id226">*</span></a>,ngrids),</dt><dd><p>ndarray of shape (<a href="#id227"><span class="problematic" id="id228">*</span></a>,ngrids))</p>
</dd>
</dl>
</dd>
</dl>
<p>corresponding to (density, pair density) and their
derivatives. This requires vot_packed for <a href="#id229"><span class="problematic" id="id230">*</span></a>tGGA functionals
Otherwise, returns vot1 in packed shape:</p>
<blockquote>
<div><p>(rho, Pi, <a href="#id231"><span class="problematic" id="id232">|</span></a>rho<a href="#id233"><span class="problematic" id="id234">|</span></a>^2, rho.Pi, <a href="#id235"><span class="problematic" id="id236">|</span></a>Pi<a href="#id237"><span class="problematic" id="id238">|</span></a>^2)</p>
</div></blockquote>
<p>stopping at Pi (3 elements) for <a href="#id239"><span class="problematic" id="id240">*</span></a>tLDA and <a href="#id241"><span class="problematic" id="id242">|</span></a>rho<a href="#id243"><span class="problematic" id="id244">|</span></a>^2 (6
elements) for tGGA.</p>
</dd>
<dt>vot_packed<span class="classifier">ndarray of shape (<a href="#id245"><span class="problematic" id="id246">*</span></a>,ngrids)</span></dt><dd><p>Vector elements corresponding to the basis
(rho, Pi, <a href="#id247"><span class="problematic" id="id248">|</span></a>drho|^2, drho.dPi, <a href="#id249"><span class="problematic" id="id250">|</span></a>dPi|^2) stopping at Pi (2
elements) for <a href="#id251"><span class="problematic" id="id252">*</span></a>tLDA and <a href="#id253"><span class="problematic" id="id254">|</span></a>drho|^2 (3 elements) for tGGA.
Required if unpack == True for <a href="#id255"><span class="problematic" id="id256">*</span></a>tGGA functionals
(because vot_|drho|^2 contributes to fot_rho,rho, etc.)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl>
<dt>vot1<span class="classifier">(ndarray of shape (<a href="#id257"><span class="problematic" id="id258">*</span></a>,ngrids),</span></dt><dd><blockquote>
<div><p>ndarray of shape (<a href="#id259"><span class="problematic" id="id260">*</span></a>,ngrids))</p>
</div></blockquote>
<p>product of fot wrt (density, pair density)
and their derivatives</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.tfnal_derivs.contract_vot">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.tfnal_derivs.</span></span><span class="sig-name descname"><span class="pre">contract_vot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/tfnal_derivs.html#contract_vot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.tfnal_derivs.contract_vot" title="Link to this definition">#</a></dt>
<dd><p>Evalute the product of unpacked vot with perturbed density, pair density, and derivatives.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>vot<span class="classifier">(ndarray of shape (<em>,ngrids), ndarray of shape (</em>, ngrids))</span></dt><dd><p>format is ([a, ngrids], [b, ngrids]) : (vrho, vPi)
ftGGA: a=4, b=4
tGGA: a=4, b=1
<a href="#id261"><span class="problematic" id="id262">*</span></a>tLDA: a=1, b=1</p>
</dd>
<dt>rho<span class="classifier">ndarray of shape (<a href="#id263"><span class="problematic" id="id264">*</span></a>,ngrids)</span></dt><dd><p>containing density [and derivatives]
the density contracted with vot</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id265"><span class="problematic" id="id266">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]
the density contracted with vot</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>cvot<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>product of vot wrt (density, pair density) and their derivatives</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.tfnal_derivs.eval_ot">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.tfnal_derivs.</span></span><span class="sig-name descname"><span class="pre">eval_ot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">otfnal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dderiv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_unpack_vot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/tfnal_derivs.html#eval_ot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.tfnal_derivs.eval_ot" title="Link to this definition">#</a></dt>
<dd><p>get the integrand of the on-top xc energy and its functional
derivatives wrt rho and Pi</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>rho<span class="classifier">ndarray of shape (2,*,ngrids)</span></dt><dd><p>containing spin-density [and derivatives]</p>
</dd>
<dt>Pi<span class="classifier">ndarray with shape (<a href="#id267"><span class="problematic" id="id268">*</span></a>,ngrids)</span></dt><dd><p>containing on-top pair density [and derivatives]</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dderiv<span class="classifier">integer</span></dt><dd><p>Order of derivatives to return</p>
</dd>
<dt>weights<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>used ONLY for debugging the total number of <a href="#id269"><span class="problematic" id="id270">``</span></a>translated
electrons in the calculation of rho_t
Not multiplied into anything!</p>
</dd>
<dt>_unpack_vot<span class="classifier">logical</span></dt><dd><p>If True, derivatives with respect to density gradients are
reported as de/drho and de/dPi; otherwise, they are
reported as de/d|rho<a href="#id271"><span class="problematic" id="id272">|</span></a>^2, de/d(rho.Pi), and de/d|Pi<a href="#id273"><span class="problematic" id="id274">|</span></a>^2</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl>
<dt>eot<span class="classifier">ndarray of shape (ngrids)</span></dt><dd><p>integrand of the on-top exchange-correlation energy</p>
</dd>
<dt>vot<span class="classifier">ndarrays of shape (<a href="#id275"><span class="problematic" id="id276">*</span></a>,ngrids) or None</span></dt><dd><p>first functional derivative of Eot wrt (density, pair
density) and their derivatives. If _unpack_vot = True, shape
and format is ([a, ngrids], [b, ngrids]) : (vrho, vPi);
otherwise, [c, ngrids] : [rho,Pi,|rho<a href="#id277"><span class="problematic" id="id278">|</span></a>^2,tau,rho.Pi,|Pi<a href="#id279"><span class="problematic" id="id280">|</span></a>^2]
ftGGA: a=4, b=4, c=5 (drop tau)
tmGGA: a=5, b=1, c=4 (drop Pi)
tGGA: a=4, b=1, c=3 (drop Pi, tau)
<a href="#id281"><span class="problematic" id="id282">*</span></a>tLDA: a=1, b=1, c=2 (drop rho, tau)</p>
</dd>
<dt>fot<span class="classifier">ndarray of shape (<a href="#id283"><span class="problematic" id="id284">*</span></a>,ngrids) or None</span></dt><dd><p>second functional derivative of Eot wrt density, pair
density, and derivatives; first dimension is lower-
triangular matrix elements corresponding to the basis
(rho, Pi, <a href="#id285"><span class="problematic" id="id286">|</span></a>rho<a href="#id287"><span class="problematic" id="id288">|</span></a>^2, rho.Pi, <a href="#id289"><span class="problematic" id="id290">|</span></a>Pi<a href="#id291"><span class="problematic" id="id292">|</span></a>^2)
stopping at Pi (3 elements) for <a href="#id293"><span class="problematic" id="id294">*</span></a>tLDA and <a href="#id295"><span class="problematic" id="id296">|</span></a>rho<a href="#id297"><span class="problematic" id="id298">|</span></a>^2 (6
elements) for tGGA.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.tfnal_derivs.unpack_vot">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.tfnal_derivs.</span></span><span class="sig-name descname"><span class="pre">unpack_vot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">packed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/tfnal_derivs.html#unpack_vot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.tfnal_derivs.unpack_vot" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="module-pyscf.mcpdft.xmspdft">
<span id="pyscf-mcpdft-xmspdft-module"></span><h2>pyscf.mcpdft.xmspdft module<a class="headerlink" href="#module-pyscf.mcpdft.xmspdft" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.xmspdft.diagonalize_safock">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.xmspdft.</span></span><span class="sig-name descname"><span class="pre">diagonalize_safock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/xmspdft.html#diagonalize_safock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.xmspdft.diagonalize_safock" title="Link to this definition">#</a></dt>
<dd><p>Diagonalizes the SA-Fock matrix. Returns the eigenvalues and
eigenvectors.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.xmspdft.fock_h1e_for_cas">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.xmspdft.</span></span><span class="sig-name descname"><span class="pre">fock_h1e_for_cas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sa_casdm1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/xmspdft.html#fock_h1e_for_cas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.xmspdft.fock_h1e_for_cas" title="Link to this definition">#</a></dt>
<dd><p>Compute the CAS SA Fock Matrix 1-electron integrals.</p>
<dl>
<dt>Args:</dt><dd><p>mc : instance of class _PDFT</p>
<dl class="simple">
<dt>sa_casdm1<span class="classifier">ndarray of shape (ncas,ncas)</span></dt><dd><p>1-RDM in the active space generated from the state-average
density.</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray of shape (nao,nmo)</span></dt><dd><p>A full set of molecular orbital coefficients. Taken from
self if not provided.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Number of active space molecular orbitals</p>
</dd>
<dt>ncore<span class="classifier">int</span></dt><dd><p>Number of core molecular orbitals</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A tuple, the first is the one-electron integrals defined in the CAS
space and the second is the constant, core part.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.xmspdft.make_fock_mcscf">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.xmspdft.</span></span><span class="sig-name descname"><span class="pre">make_fock_mcscf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/xmspdft.html#make_fock_mcscf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.xmspdft.make_fock_mcscf" title="Link to this definition">#</a></dt>
<dd><p>Compute the SA-Fock Hamiltonian/Matrix</p>
<dl>
<dt>Args:</dt><dd><p>mc : instance of class _PDFT</p>
<dl class="simple">
<dt>mo_coeff<span class="classifier">ndarray of shape (nao,nmo)</span></dt><dd><p>A full set of molecular orbital coefficients. Taken from
self if not provided.</p>
</dd>
<dt>ci<span class="classifier">ndarray of shape (nroots)</span></dt><dd><p>CI vectors should be from a converged CASSCF/CASCI calculation</p>
</dd>
<dt>weights<span class="classifier">ndarray of length nroots</span></dt><dd><p>Weight for each state. If none, uses weights from SA-CASSCF
calculation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>safock_ham<span class="classifier">ndarray of shape (nroots,nroots)</span></dt><dd><p>State-average Fock matrix expressed in the basis provided by the CI
vectors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.xmspdft.safock_energy">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.xmspdft.</span></span><span class="sig-name descname"><span class="pre">safock_energy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/xmspdft.html#safock_energy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.xmspdft.safock_energy" title="Link to this definition">#</a></dt>
<dd><p>Diabatizer Function</p>
<p>The objective function we are optimizing when solving for the
SA-Fock eigenstates is that the SA-Fock energy (average) is
minimized with the constraint to the final states being orthonormal.
Its the whole saddle point thing similar to in SA-MC-PDFT gradients. For now
I just omit this whole issue since the first derivative is by default 0 and
dont worry about the Hessian (or second derivatives) since I dont care.
It should fail if we try and do gradients but I can put a hard
RaiseImplementation error</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>SA-Fock Energy<span class="classifier">float</span></dt><dd><p>weighted sum of SA-Fock energies</p>
</dd>
<dt>dSA-Fock Energy<span class="classifier">ndarray of shape npair = nroots*(nroots - 1)/2</span></dt><dd><p>first derivative of the SA-Fock energy wrt interstate rotation
This is zero by default since we diagonalize a matrix</p>
</dd>
<dt>d2SA-Fock Energy<span class="classifier">ndarray of shape (npair,npair)</span></dt><dd><p>Should be the Lagrange multiplier terms. Currently returning None
since we cannot do gradients yet.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.xmspdft.solve_safock">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.xmspdft.</span></span><span class="sig-name descname"><span class="pre">solve_safock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ci</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft/xmspdft.html#solve_safock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.xmspdft.solve_safock" title="Link to this definition">#</a></dt>
<dd><p>Diabatize Function. Finds the SA-Fock Eigenstates within the model space
spanned by the CI vectors.</p>
<dl>
<dt>Args:</dt><dd><p>mc : instance of class _PDFT</p>
<dl class="simple">
<dt>mo_coeff<span class="classifier">ndarray of shape (nao,nmo)</span></dt><dd><p>A full set of molecular orbital coefficients. Taken from
self if not provided.</p>
</dd>
<dt>ci<span class="classifier">ndarray of shape (nroots)</span></dt><dd><p>CI vectors should be from a converged CASSCF/CASCI calculation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>conv<span class="classifier">bool</span></dt><dd><p>Always true. If there is a convergence issue, scipy will raise an
exception.</p>
</dd>
<dt>ci<span class="classifier">list of ndarrays of length = nroots</span></dt><dd><p>CI vectors of the optimized diabatic states</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyscf.mcpdft">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pyscf.mcpdft" title="Link to this heading">#</a></h2>
<section id="multi-configuration-pair-density-functional-theory">
<h3>Multi-configuration pair-density functional theory<a class="headerlink" href="#multi-configuration-pair-density-functional-theory" title="Link to this heading">#</a></h3>
<p>Simple usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcpdft</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;def2-tzvp&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span> <span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcpdft</span><span class="o">.</span><span class="n">CASSCF</span> <span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="s1">&#39;tPBE&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.CASCI">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.</span></span><span class="sig-name descname"><span class="pre">CASCI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc_or_mf_or_mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelecas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcpdft.CASCI" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.CASCIPDFT">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.</span></span><span class="sig-name descname"><span class="pre">CASCIPDFT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc_or_mf_or_mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelecas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft.html#CASCIPDFT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.CASCIPDFT" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.CASSCF">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.</span></span><span class="sig-name descname"><span class="pre">CASSCF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc_or_mf_or_mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelecas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frozen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.mcpdft.CASSCF" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.mcpdft.CASSCFPDFT">
<span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.</span></span><span class="sig-name descname"><span class="pre">CASSCFPDFT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mc_or_mf_or_mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelecas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frozen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/mcpdft.html#CASSCFPDFT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.CASSCFPDFT" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.mcpdft.MultiStateMCPDFTSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.mcpdft.</span></span><span class="sig-name descname"><span class="pre">MultiStateMCPDFTSolver</span></span><a class="reference internal" href="../_modules/pyscf/mcpdft.html#MultiStateMCPDFTSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.mcpdft.MultiStateMCPDFTSolver" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

</section>
</section>


                </article>
              
              
              
              
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#submodules">Submodules</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.mcpdft.chkfile">pyscf.mcpdft.chkfile module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.chkfile.dump_lpdft"><code class="docutils literal notranslate"><span class="pre">dump_lpdft()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.chkfile.dump_mcpdft"><code class="docutils literal notranslate"><span class="pre">dump_mcpdft()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.chkfile.load_pdft"><code class="docutils literal notranslate"><span class="pre">load_pdft()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.mcpdft.cmspdft">pyscf.mcpdft.cmspdft module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.cmspdft.coulomb_tensor"><code class="docutils literal notranslate"><span class="pre">coulomb_tensor()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.cmspdft.e_coul"><code class="docutils literal notranslate"><span class="pre">e_coul()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.cmspdft.e_coul_o0"><code class="docutils literal notranslate"><span class="pre">e_coul_o0()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.mcpdft.lpdft">pyscf.mcpdft.lpdft module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.lpdft.get_lpdft_hconst"><code class="docutils literal notranslate"><span class="pre">get_lpdft_hconst()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.lpdft.get_transformed_h2eff_for_cas"><code class="docutils literal notranslate"><span class="pre">get_transformed_h2eff_for_cas()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.lpdft.kernel"><code class="docutils literal notranslate"><span class="pre">kernel()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.lpdft.linear_multi_state"><code class="docutils literal notranslate"><span class="pre">linear_multi_state()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.lpdft.linear_multi_state_mix"><code class="docutils literal notranslate"><span class="pre">linear_multi_state_mix()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.lpdft.make_lpdft_ham_"><code class="docutils literal notranslate"><span class="pre">make_lpdft_ham_()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.lpdft.transformed_h1e_for_cas"><code class="docutils literal notranslate"><span class="pre">transformed_h1e_for_cas()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.lpdft.weighted_average_densities"><code class="docutils literal notranslate"><span class="pre">weighted_average_densities()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.mcpdft.mcpdft">pyscf.mcpdft.mcpdft module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.mcpdft.energy_dft"><code class="docutils literal notranslate"><span class="pre">energy_dft()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.mcpdft.energy_elec"><code class="docutils literal notranslate"><span class="pre">energy_elec()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.mcpdft.energy_mcwfn"><code class="docutils literal notranslate"><span class="pre">energy_mcwfn()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.mcpdft.energy_tot"><code class="docutils literal notranslate"><span class="pre">energy_tot()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.mcpdft.get_energy_decomposition"><code class="docutils literal notranslate"><span class="pre">get_energy_decomposition()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.mcpdft.get_mcpdft_child_class"><code class="docutils literal notranslate"><span class="pre">get_mcpdft_child_class()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.mcpdft.kernel"><code class="docutils literal notranslate"><span class="pre">kernel()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.mcpdft.mspdft">pyscf.mcpdft.mspdft module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.mspdft.get_diabfns"><code class="docutils literal notranslate"><span class="pre">get_diabfns()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.mspdft.make_heff_mcscf"><code class="docutils literal notranslate"><span class="pre">make_heff_mcscf()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.mspdft.multi_state"><code class="docutils literal notranslate"><span class="pre">multi_state()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.mspdft.si_newton"><code class="docutils literal notranslate"><span class="pre">si_newton()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.mcpdft.otfnal">pyscf.mcpdft.otfnal module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.colle_salvetti_corr"><code class="docutils literal notranslate"><span class="pre">colle_salvetti_corr</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.colle_salvetti_corr.get_E_ot"><code class="docutils literal notranslate"><span class="pre">colle_salvetti_corr.get_E_ot()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.energy_ot"><code class="docutils literal notranslate"><span class="pre">energy_ot()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.ft_eval_xc"><code class="docutils literal notranslate"><span class="pre">ft_eval_xc()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.ft_hybrid_coeff"><code class="docutils literal notranslate"><span class="pre">ft_hybrid_coeff()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.ft_nlc_coeff"><code class="docutils literal notranslate"><span class="pre">ft_nlc_coeff()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.ft_rsh_and_hybrid_coeff"><code class="docutils literal notranslate"><span class="pre">ft_rsh_and_hybrid_coeff()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.ft_rsh_coeff"><code class="docutils literal notranslate"><span class="pre">ft_rsh_coeff()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.ft_xc_type"><code class="docutils literal notranslate"><span class="pre">ft_xc_type()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.ftransfnal"><code class="docutils literal notranslate"><span class="pre">ftransfnal</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.ftransfnal.Pi_deriv"><code class="docutils literal notranslate"><span class="pre">ftransfnal.Pi_deriv</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.ftransfnal.d_jT_op"><code class="docutils literal notranslate"><span class="pre">ftransfnal.d_jT_op()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.ftransfnal.get_rho_translated"><code class="docutils literal notranslate"><span class="pre">ftransfnal.get_rho_translated()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.ftransfnal.get_zeta"><code class="docutils literal notranslate"><span class="pre">ftransfnal.get_zeta()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.ftransfnal.jT_op"><code class="docutils literal notranslate"><span class="pre">ftransfnal.jT_op()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.ftransfnal.transl_prefix"><code class="docutils literal notranslate"><span class="pre">ftransfnal.transl_prefix</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.get_transfnal"><code class="docutils literal notranslate"><span class="pre">get_transfnal()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.make_hybrid_fnal"><code class="docutils literal notranslate"><span class="pre">make_hybrid_fnal()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.make_scaled_fnal"><code class="docutils literal notranslate"><span class="pre">make_scaled_fnal()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal"><code class="docutils literal notranslate"><span class="pre">otfnal</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.Pi_deriv"><code class="docutils literal notranslate"><span class="pre">otfnal.Pi_deriv</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.dens_deriv"><code class="docutils literal notranslate"><span class="pre">otfnal.dens_deriv</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.energy_ot"><code class="docutils literal notranslate"><span class="pre">otfnal.energy_ot()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.eval_ot"><code class="docutils literal notranslate"><span class="pre">otfnal.eval_ot()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.get_eff_1body"><code class="docutils literal notranslate"><span class="pre">otfnal.get_eff_1body()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.get_eff_2body"><code class="docutils literal notranslate"><span class="pre">otfnal.get_eff_2body()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.get_eff_2body_kl"><code class="docutils literal notranslate"><span class="pre">otfnal.get_eff_2body_kl()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.get_feff_1body"><code class="docutils literal notranslate"><span class="pre">otfnal.get_feff_1body()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.get_feff_2body"><code class="docutils literal notranslate"><span class="pre">otfnal.get_feff_2body()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.get_veff_1body"><code class="docutils literal notranslate"><span class="pre">otfnal.get_veff_1body()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.get_veff_2body"><code class="docutils literal notranslate"><span class="pre">otfnal.get_veff_2body()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.get_veff_2body_kl"><code class="docutils literal notranslate"><span class="pre">otfnal.get_veff_2body_kl()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.reset"><code class="docutils literal notranslate"><span class="pre">otfnal.reset()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.otfnal.xctype"><code class="docutils literal notranslate"><span class="pre">otfnal.xctype</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.register_otfnal"><code class="docutils literal notranslate"><span class="pre">register_otfnal()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.t_eval_xc"><code class="docutils literal notranslate"><span class="pre">t_eval_xc()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.t_hybrid_coeff"><code class="docutils literal notranslate"><span class="pre">t_hybrid_coeff()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.t_nlc_coeff"><code class="docutils literal notranslate"><span class="pre">t_nlc_coeff()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.t_rsh_and_hybrid_coeff"><code class="docutils literal notranslate"><span class="pre">t_rsh_and_hybrid_coeff()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.t_rsh_coeff"><code class="docutils literal notranslate"><span class="pre">t_rsh_coeff()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.t_xc_type"><code class="docutils literal notranslate"><span class="pre">t_xc_type()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.transfnal"><code class="docutils literal notranslate"><span class="pre">transfnal</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.transfnal.d_jT_op"><code class="docutils literal notranslate"><span class="pre">transfnal.d_jT_op()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.transfnal.eval_ot"><code class="docutils literal notranslate"><span class="pre">transfnal.eval_ot()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.transfnal.get_ratio"><code class="docutils literal notranslate"><span class="pre">transfnal.get_ratio()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.transfnal.get_rho_translated"><code class="docutils literal notranslate"><span class="pre">transfnal.get_rho_translated()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.transfnal.get_zeta"><code class="docutils literal notranslate"><span class="pre">transfnal.get_zeta()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.transfnal.jT_op"><code class="docutils literal notranslate"><span class="pre">transfnal.jT_op()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.transfnal.split_x_c"><code class="docutils literal notranslate"><span class="pre">transfnal.split_x_c()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.transfnal.transl_prefix"><code class="docutils literal notranslate"><span class="pre">transfnal.transl_prefix</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otfnal.unregister_otfnal"><code class="docutils literal notranslate"><span class="pre">unregister_otfnal()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.mcpdft.otpd">pyscf.mcpdft.otpd module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otpd.density_orbital_derivative"><code class="docutils literal notranslate"><span class="pre">density_orbital_derivative()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.otpd.get_ontop_pair_density"><code class="docutils literal notranslate"><span class="pre">get_ontop_pair_density()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.mcpdft.pdft_eff">pyscf.mcpdft.pdft_eff module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.pdft_eff.get_eff_1body"><code class="docutils literal notranslate"><span class="pre">get_eff_1body()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.pdft_eff.get_eff_2body"><code class="docutils literal notranslate"><span class="pre">get_eff_2body()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.pdft_eff.get_eff_2body_kl"><code class="docutils literal notranslate"><span class="pre">get_eff_2body_kl()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.mcpdft.pdft_feff">pyscf.mcpdft.pdft_feff module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.pdft_feff.get_feff_1body"><code class="docutils literal notranslate"><span class="pre">get_feff_1body()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.pdft_feff.get_feff_2body"><code class="docutils literal notranslate"><span class="pre">get_feff_2body()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.pdft_feff.get_feff_2body_kl"><code class="docutils literal notranslate"><span class="pre">get_feff_2body_kl()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.pdft_feff.kernel"><code class="docutils literal notranslate"><span class="pre">kernel()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.pdft_feff.lazy_kernel"><code class="docutils literal notranslate"><span class="pre">lazy_kernel()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.mcpdft.pdft_veff">pyscf.mcpdft.pdft_veff module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.pdft_veff.get_veff_1body"><code class="docutils literal notranslate"><span class="pre">get_veff_1body()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.pdft_veff.get_veff_2body"><code class="docutils literal notranslate"><span class="pre">get_veff_2body()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.pdft_veff.get_veff_2body_kl"><code class="docutils literal notranslate"><span class="pre">get_veff_2body_kl()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.pdft_veff.kernel"><code class="docutils literal notranslate"><span class="pre">kernel()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.pdft_veff.lazy_kernel"><code class="docutils literal notranslate"><span class="pre">lazy_kernel()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.mcpdft.tfnal_derivs">pyscf.mcpdft.tfnal_derivs module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.tfnal_derivs.contract_fot"><code class="docutils literal notranslate"><span class="pre">contract_fot()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.tfnal_derivs.contract_vot"><code class="docutils literal notranslate"><span class="pre">contract_vot()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.tfnal_derivs.eval_ot"><code class="docutils literal notranslate"><span class="pre">eval_ot()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.tfnal_derivs.unpack_vot"><code class="docutils literal notranslate"><span class="pre">unpack_vot()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.mcpdft.xmspdft">pyscf.mcpdft.xmspdft module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.xmspdft.diagonalize_safock"><code class="docutils literal notranslate"><span class="pre">diagonalize_safock()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.xmspdft.fock_h1e_for_cas"><code class="docutils literal notranslate"><span class="pre">fock_h1e_for_cas()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.xmspdft.make_fock_mcscf"><code class="docutils literal notranslate"><span class="pre">make_fock_mcscf()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.xmspdft.safock_energy"><code class="docutils literal notranslate"><span class="pre">safock_energy()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.xmspdft.solve_safock"><code class="docutils literal notranslate"><span class="pre">solve_safock()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.mcpdft">Module contents</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-configuration-pair-density-functional-theory">Multi-configuration pair-density functional theory</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.CASCI"><code class="docutils literal notranslate"><span class="pre">CASCI()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.CASCIPDFT"><code class="docutils literal notranslate"><span class="pre">CASCIPDFT()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.CASSCF"><code class="docutils literal notranslate"><span class="pre">CASSCF()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.CASSCFPDFT"><code class="docutils literal notranslate"><span class="pre">CASSCFPDFT()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.mcpdft.MultiStateMCPDFTSolver"><code class="docutils literal notranslate"><span class="pre">MultiStateMCPDFTSolver</span></code></a></li>
</ul>
</li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">

  
  <div class="tocsection editthispage">
    <a href="https://github.com/pyscf/pyscf.github.io/edit/master/source/pyscf_api_docs/pyscf.mcpdft.rst">
      <i class="fa-solid fa-pencil"></i>
      
      
        
          Edit on GitHub
        
      
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2025, The PySCF Developers.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>