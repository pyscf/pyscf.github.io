
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pyscf.scf package &#8212; PySCF</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=92fd9be5" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/css/pyscf-pst.css?v=ed6b5f64" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../_static/documentation_options.js?v=dfec817d"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'pyscf_api_docs/pyscf.scf';</script>
    <link rel="icon" href="../_static/favicon-32x32.png"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="2.7" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo-64x64.png" class="logo__image only-light" alt=""/>
    <img src="../_static/logo-64x64.png" class="logo__image only-dark pst-js-only" alt=""/>
  
  
    <p class="title logo__title">PySCF</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../quickstart.html">
    Quickstart
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../user/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../contributor/index.html">
    Contributor Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../about.html">
    About
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../news.html">
    News
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pyscf/pyscf" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../quickstart.html">
    Quickstart
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../user/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../contributor/index.html">
    Contributor Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../about.html">
    About
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../news.html">
    News
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pyscf/pyscf" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="pyscf.adc.html">pyscf.adc package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.agf2.html">pyscf.agf2 package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.ao2mo.html">pyscf.ao2mo package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.cc.html">pyscf.cc package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.ci.html">pyscf.ci package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.data.html">pyscf.data package</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="pyscf.df.html">pyscf.df package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="pyscf.df.grad.html">pyscf.df.grad package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.df.hessian.html">pyscf.df.hessian package</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="pyscf.dft.html">pyscf.dft package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="pyscf.dft.xc.html">pyscf.dft.xc package</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.eph.html">pyscf.eph package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.fci.html">pyscf.fci package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.geomopt.html">pyscf.geomopt package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.grad.html">pyscf.grad package</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="pyscf.gto.html">pyscf.gto package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="pyscf.gto.basis.html">pyscf.gto.basis package</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.gw.html">pyscf.gw package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.hessian.html">pyscf.hessian package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.lib.html">pyscf.lib package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.lo.html">pyscf.lo package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.mcscf.html">pyscf.mcscf package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.mp.html">pyscf.mp package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.mrpt.html">pyscf.mrpt package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.nac.html">pyscf.nac package</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="pyscf.pbc.html">pyscf.pbc package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.adc.html">pyscf.pbc.adc package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.ao2mo.html">pyscf.pbc.ao2mo package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.cc.html">pyscf.pbc.cc package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.ci.html">pyscf.pbc.ci package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.df.html">pyscf.pbc.df package</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="pyscf.pbc.dft.html">pyscf.pbc.dft package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="pyscf.pbc.dft.multigrid.html">pyscf.pbc.dft.multigrid package</a></li>
</ul>
</details></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.eph.html">pyscf.pbc.eph package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.geomopt.html">pyscf.pbc.geomopt package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.grad.html">pyscf.pbc.grad package</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="pyscf.pbc.gto.html">pyscf.pbc.gto package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="pyscf.pbc.gto.basis.html">pyscf.pbc.gto.basis package</a></li>
<li class="toctree-l3"><a class="reference internal" href="pyscf.pbc.gto.pseudo.html">pyscf.pbc.gto.pseudo package</a></li>
</ul>
</details></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.gw.html">pyscf.pbc.gw package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.lib.html">pyscf.pbc.lib package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.mp.html">pyscf.pbc.mp package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.mpicc.html">pyscf.pbc.mpicc package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.mpitools.html">pyscf.pbc.mpitools package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.scf.html">pyscf.pbc.scf package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.symm.html">pyscf.pbc.symm package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.tddft.html">pyscf.pbc.tddft package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.tdscf.html">pyscf.pbc.tdscf package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.tools.html">pyscf.pbc.tools package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.pbc.x2c.html">pyscf.pbc.x2c package</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.qmmm.html">pyscf.qmmm package</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">pyscf.scf package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.sgx.html">pyscf.sgx package</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="pyscf.solvent.html">pyscf.solvent package</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="pyscf.solvent.grad.html">pyscf.solvent.grad package</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyscf.solvent.hessian.html">pyscf.solvent.hessian package</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.soscf.html">pyscf.soscf package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.symm.html">pyscf.symm package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.tddft.html">pyscf.tddft package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.tdscf.html">pyscf.tdscf package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.tools.html">pyscf.tools package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyscf.x2c.html">pyscf.x2c package</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">pyscf.scf package</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="pyscf-scf-package">
<h1>pyscf.scf package<a class="headerlink" href="#pyscf-scf-package" title="Link to this heading">#</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">#</a></h2>
</section>
<section id="module-pyscf.scf.addons">
<span id="pyscf-scf-addons-module"></span><h2>pyscf.scf.addons module<a class="headerlink" href="#module-pyscf.scf.addons" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.canonical_orth_">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">canonical_orth_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#canonical_orth_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.canonical_orth_" title="Link to this definition">#</a></dt>
<dd><p>Löwdin’s canonical orthogonalization</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.convert_to_ghf">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">convert_to_ghf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#convert_to_ghf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.convert_to_ghf" title="Link to this definition">#</a></dt>
<dd><p>Convert the given mean-field object to the generalized HF/KS object</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mf object. If mf is an second order SCF (SOSCF) object, the SOSCF layer
will be discarded. Its underlying SCF object mf._scf will be converted.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mf : SCF object</p>
</dd>
<dt>Kwargs</dt><dd><dl class="simple">
<dt>remove_df<span class="classifier">bool</span></dt><dd><p>Whether to convert the DF-SCF object to the normal SCF object.
This conversion is not applied by default.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>An generalized SCF object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.convert_to_rhf">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">convert_to_rhf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#convert_to_rhf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.convert_to_rhf" title="Link to this definition">#</a></dt>
<dd><p>Convert the given mean-field object to the restricted HF/KS object</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mf object. If mf is an second order SCF (SOSCF) object, the SOSCF layer
will be discarded. Its underlying SCF object mf._scf will be converted.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mf : SCF object</p>
</dd>
<dt>Kwargs</dt><dd><dl class="simple">
<dt>remove_df<span class="classifier">bool</span></dt><dd><p>Whether to convert the DF-SCF object to the normal SCF object.
This conversion is not applied by default.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>An unrestricted SCF object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.convert_to_uhf">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">convert_to_uhf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#convert_to_uhf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.convert_to_uhf" title="Link to this definition">#</a></dt>
<dd><p>Convert the given mean-field object to the unrestricted HF/KS object</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mf object. If mf is an second order SCF (SOSCF) object, the SOSCF layer
will be discarded. Its underlying SCF object mf._scf will be converted.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mf : SCF object</p>
</dd>
<dt>Kwargs</dt><dd><dl class="simple">
<dt>remove_df<span class="classifier">bool</span></dt><dd><p>Whether to convert the DF-SCF object to the normal SCF object.
This conversion is not applied by default.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>An unrestricted SCF object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.dynamic_level_shift">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">dynamic_level_shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.addons.dynamic_level_shift" title="Link to this definition">#</a></dt>
<dd><p>Dynamically change the level shift in each SCF cycle.  The level shift
value is set to (HF energy change * factor)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.dynamic_level_shift_">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">dynamic_level_shift_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#dynamic_level_shift_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.dynamic_level_shift_" title="Link to this definition">#</a></dt>
<dd><p>Dynamically change the level shift in each SCF cycle.  The level shift
value is set to (HF energy change * factor)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.dynamic_occ">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">dynamic_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.addons.dynamic_occ" title="Link to this definition">#</a></dt>
<dd><p>Dynamically adjust the occupancy to avoid degeneracy between HOMO and LUMO</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.dynamic_occ_">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">dynamic_occ_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#dynamic_occ_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.dynamic_occ_" title="Link to this definition">#</a></dt>
<dd><p>Dynamically adjust the occupancy to avoid degeneracy between HOMO and LUMO</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.dynamic_sz_">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">dynamic_sz_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.addons.dynamic_sz_" title="Link to this definition">#</a></dt>
<dd><p>For UHF, allowing the Sz value being changed during SCF iteration.
Determine occupation of alpha and beta electrons based on energy spectrum</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.fast_newton">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">fast_newton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auxbasis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dual_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">newton_kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#fast_newton"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.fast_newton" title="Link to this definition">#</a></dt>
<dd><p>This is a wrap function which combines several operations. This
function first setup the initial guess
from density fitting calculation then use  for
Newton solver and call Newton solver.</p>
<p>Newton solver attributes [max_cycle_inner, max_stepsize, ah_start_tol,
ah_conv_tol, ah_grad_trust_region, …] can be passed through <code class="docutils literal notranslate"><span class="pre">**newton_kwargs</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.float_occ">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">float_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.addons.float_occ" title="Link to this definition">#</a></dt>
<dd><p>For UHF, allowing the Sz value being changed during SCF iteration.
Determine occupation of alpha and beta electrons based on energy spectrum</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.float_occ_">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">float_occ_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#float_occ_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.float_occ_" title="Link to this definition">#</a></dt>
<dd><p>For UHF, allowing the Sz value being changed during SCF iteration.
Determine occupation of alpha and beta electrons based on energy spectrum</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.follow_state">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">follow_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occorb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.addons.follow_state" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.follow_state_">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">follow_state_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occorb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#follow_state_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.follow_state_" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.frac_occ">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">frac_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.addons.frac_occ" title="Link to this definition">#</a></dt>
<dd><p>Addons for SCF methods to assign fractional occupancy for degenerated
occupied HOMOs.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; O 0 0 1&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">RHF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">frac_occ</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.frac_occ_">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">frac_occ_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#frac_occ_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.frac_occ_" title="Link to this definition">#</a></dt>
<dd><p>Addons for SCF methods to assign fractional occupancy for degenerated
occupied HOMOs.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; O 0 0 1&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">RHF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">frac_occ</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.get_ghf_orbspin">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">get_ghf_orbspin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_rhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#get_ghf_orbspin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.get_ghf_orbspin" title="Link to this definition">#</a></dt>
<dd><p>Spin of each GHF orbital when the GHF orbitals are converted from
RHF/UHF orbitals</p>
<p>For RHF orbitals, the orbspin corresponds to first occupied orbitals then
unoccupied orbitals.  In the occupied orbital space, if degenerated, first
alpha then beta, last the (open-shell) singly occupied (alpha) orbitals. In
the unoccupied orbital space, first the (open-shell) unoccupied (beta)
orbitals if applicable, then alpha and beta orbitals</p>
<p>For UHF orbitals, the orbspin corresponds to first occupied orbitals then
unoccupied orbitals.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.mom_occ">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">mom_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occorb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">setocc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.addons.mom_occ" title="Link to this definition">#</a></dt>
<dd><p>Use maximum overlap method to determine occupation number for each orbital in every
iteration.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.mom_occ_">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">mom_occ_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occorb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">setocc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#mom_occ_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.mom_occ_" title="Link to this definition">#</a></dt>
<dd><p>Use maximum overlap method to determine occupation number for each orbital in every
iteration.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.partial_cholesky_orth_">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">partial_cholesky_orth_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">canthr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cholthr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#partial_cholesky_orth_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.partial_cholesky_orth_" title="Link to this definition">#</a></dt>
<dd><p>Partial Cholesky orthogonalization for curing overcompleteness.</p>
<p>References:</p>
<p>Susi Lehtola, Curing basis set overcompleteness with pivoted
Cholesky decompositions, J. Chem. Phys. 151, 241102 (2019),
doi:10.1063/1.5139948.</p>
<p>Susi Lehtola, Accurate reproduction of strongly repulsive
interatomic potentials, Phys. Rev. A 101, 032504 (2020),
doi:10.1103/PhysRevA.101.032504.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.project_dm_nr2nr">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">project_dm_nr2nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mol2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#project_dm_nr2nr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.project_dm_nr2nr" title="Link to this definition">#</a></dt>
<dd><p>Project density matrix representation from basis set 1 (mol1) to basis
set 2 (mol2).</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}|AO2\rangle DM_AO2 \langle AO2|\\= |AO2\rangle P DM_AO1 P \langle AO2|\\DM_AO2 = P DM_AO1 P\\P = S_{AO2}^{-1}\langle AO2|AO1\rangle\end{aligned}\end{align} \]</div>
<p>There are three relevant functions:
<a class="reference internal" href="#pyscf.scf.addons.project_dm_nr2nr" title="pyscf.scf.addons.project_dm_nr2nr"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_dm_nr2nr()</span></code></a> is the projection for non-relativistic (scalar) basis.
<a class="reference internal" href="#pyscf.scf.addons.project_dm_nr2r" title="pyscf.scf.addons.project_dm_nr2r"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_dm_nr2r()</span></code></a> projects from non-relativistic to relativistic basis.
<a class="reference internal" href="#pyscf.scf.addons.project_dm_r2r" title="pyscf.scf.addons.project_dm_r2r"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_dm_r2r()</span></code></a>  is the projection between relativistic (spinor) basis.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.project_dm_nr2r">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">project_dm_nr2r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mol2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#project_dm_nr2r"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.project_dm_nr2r" title="Link to this definition">#</a></dt>
<dd><p>Project density matrix representation from basis set 1 (mol1) to basis
set 2 (mol2).</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}|AO2\rangle DM_AO2 \langle AO2|\\= |AO2\rangle P DM_AO1 P \langle AO2|\\DM_AO2 = P DM_AO1 P\\P = S_{AO2}^{-1}\langle AO2|AO1\rangle\end{aligned}\end{align} \]</div>
<p>There are three relevant functions:
<a class="reference internal" href="#pyscf.scf.addons.project_dm_nr2nr" title="pyscf.scf.addons.project_dm_nr2nr"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_dm_nr2nr()</span></code></a> is the projection for non-relativistic (scalar) basis.
<a class="reference internal" href="#pyscf.scf.addons.project_dm_nr2r" title="pyscf.scf.addons.project_dm_nr2r"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_dm_nr2r()</span></code></a> projects from non-relativistic to relativistic basis.
<a class="reference internal" href="#pyscf.scf.addons.project_dm_r2r" title="pyscf.scf.addons.project_dm_r2r"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_dm_r2r()</span></code></a>  is the projection between relativistic (spinor) basis.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.project_dm_r2r">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">project_dm_r2r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mol2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#project_dm_r2r"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.project_dm_r2r" title="Link to this definition">#</a></dt>
<dd><p>Project density matrix representation from basis set 1 (mol1) to basis
set 2 (mol2).</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}|AO2\rangle DM_AO2 \langle AO2|\\= |AO2\rangle P DM_AO1 P \langle AO2|\\DM_AO2 = P DM_AO1 P\\P = S_{AO2}^{-1}\langle AO2|AO1\rangle\end{aligned}\end{align} \]</div>
<p>There are three relevant functions:
<a class="reference internal" href="#pyscf.scf.addons.project_dm_nr2nr" title="pyscf.scf.addons.project_dm_nr2nr"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_dm_nr2nr()</span></code></a> is the projection for non-relativistic (scalar) basis.
<a class="reference internal" href="#pyscf.scf.addons.project_dm_nr2r" title="pyscf.scf.addons.project_dm_nr2r"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_dm_nr2r()</span></code></a> projects from non-relativistic to relativistic basis.
<a class="reference internal" href="#pyscf.scf.addons.project_dm_r2r" title="pyscf.scf.addons.project_dm_r2r"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_dm_r2r()</span></code></a>  is the projection between relativistic (spinor) basis.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.project_mo_nr2nr">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">project_mo_nr2nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mol2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#project_mo_nr2nr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.project_mo_nr2nr" title="Link to this definition">#</a></dt>
<dd><p>Project orbital coefficients from basis set 1 (C1 for mol1) to basis
set 2 (C2 for mol2).</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}|\psi1\rangle = |AO1\rangle C1\\|\psi2\rangle = P |\psi1\rangle = |AO2\rangle S^{-1}\langle AO2| AO1\rangle&gt; C1 = |AO2\rangle&gt; C2\\C2 = S^{-1}\langle AO2|AO1\rangle C1\end{aligned}\end{align} \]</div>
<p>There are three relevant functions:
<a class="reference internal" href="#pyscf.scf.addons.project_mo_nr2nr" title="pyscf.scf.addons.project_mo_nr2nr"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_mo_nr2nr()</span></code></a> is the projection for non-relativistic (scalar) basis.
<a class="reference internal" href="#pyscf.scf.addons.project_mo_nr2r" title="pyscf.scf.addons.project_mo_nr2r"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_mo_nr2r()</span></code></a> projects from non-relativistic to relativistic basis.
<a class="reference internal" href="#pyscf.scf.addons.project_mo_r2r" title="pyscf.scf.addons.project_mo_r2r"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_mo_r2r()</span></code></a>  is the projection between relativistic (spinor) basis.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.project_mo_nr2r">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">project_mo_nr2r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mol2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#project_mo_nr2r"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.project_mo_nr2r" title="Link to this definition">#</a></dt>
<dd><p>Project orbital coefficients from basis set 1 (C1 for mol1) to basis
set 2 (C2 for mol2).</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}|\psi1\rangle = |AO1\rangle C1\\|\psi2\rangle = P |\psi1\rangle = |AO2\rangle S^{-1}\langle AO2| AO1\rangle&gt; C1 = |AO2\rangle&gt; C2\\C2 = S^{-1}\langle AO2|AO1\rangle C1\end{aligned}\end{align} \]</div>
<p>There are three relevant functions:
<a class="reference internal" href="#pyscf.scf.addons.project_mo_nr2nr" title="pyscf.scf.addons.project_mo_nr2nr"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_mo_nr2nr()</span></code></a> is the projection for non-relativistic (scalar) basis.
<a class="reference internal" href="#pyscf.scf.addons.project_mo_nr2r" title="pyscf.scf.addons.project_mo_nr2r"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_mo_nr2r()</span></code></a> projects from non-relativistic to relativistic basis.
<a class="reference internal" href="#pyscf.scf.addons.project_mo_r2r" title="pyscf.scf.addons.project_mo_r2r"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_mo_r2r()</span></code></a>  is the projection between relativistic (spinor) basis.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.project_mo_r2r">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">project_mo_r2r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mol2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#project_mo_r2r"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.project_mo_r2r" title="Link to this definition">#</a></dt>
<dd><p>Project orbital coefficients from basis set 1 (C1 for mol1) to basis
set 2 (C2 for mol2).</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}|\psi1\rangle = |AO1\rangle C1\\|\psi2\rangle = P |\psi1\rangle = |AO2\rangle S^{-1}\langle AO2| AO1\rangle&gt; C1 = |AO2\rangle&gt; C2\\C2 = S^{-1}\langle AO2|AO1\rangle C1\end{aligned}\end{align} \]</div>
<p>There are three relevant functions:
<a class="reference internal" href="#pyscf.scf.addons.project_mo_nr2nr" title="pyscf.scf.addons.project_mo_nr2nr"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_mo_nr2nr()</span></code></a> is the projection for non-relativistic (scalar) basis.
<a class="reference internal" href="#pyscf.scf.addons.project_mo_nr2r" title="pyscf.scf.addons.project_mo_nr2r"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_mo_nr2r()</span></code></a> projects from non-relativistic to relativistic basis.
<a class="reference internal" href="#pyscf.scf.addons.project_mo_r2r" title="pyscf.scf.addons.project_mo_r2r"><code class="xref py py-func docutils literal notranslate"><span class="pre">project_mo_r2r()</span></code></a>  is the projection between relativistic (spinor) basis.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.remove_linear_dep">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">remove_linear_dep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lindep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cholesky_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_pivoted_cholesky</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.addons.remove_linear_dep" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>threshold<span class="classifier">float</span></dt><dd><p>The threshold under which the eigenvalues of the overlap matrix are
discarded to avoid numerical instability.</p>
</dd>
<dt>lindep<span class="classifier">float</span></dt><dd><p>The threshold that triggers the special treatment of the linear
dependence issue.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.remove_linear_dep_">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">remove_linear_dep_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lindep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cholesky_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_pivoted_cholesky</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#remove_linear_dep_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.remove_linear_dep_" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>threshold<span class="classifier">float</span></dt><dd><p>The threshold under which the eigenvalues of the overlap matrix are
discarded to avoid numerical instability.</p>
</dd>
<dt>lindep<span class="classifier">float</span></dt><dd><p>The threshold that triggers the special treatment of the linear
dependence issue.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.smearing">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">smearing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fermi'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#smearing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.smearing" title="Link to this definition">#</a></dt>
<dd><p>Fermi-Dirac or Gaussian smearing</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.addons.smearing_">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.addons.</span></span><span class="sig-name descname"><span class="pre">smearing_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/addons.html#smearing_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.addons.smearing_" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="module-pyscf.scf.atom_hf">
<span id="pyscf-scf-atom-hf-module"></span><h2>pyscf.scf.atom_hf module<a class="headerlink" href="#module-pyscf.scf.atom_hf" title="Link to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf.AtomHF1e">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_hf.</span></span><span class="sig-name descname"><span class="pre">AtomHF1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf.html#AtomHF1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf.AtomHF1e" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.rohf.HF1e" title="pyscf.scf.rohf.HF1e"><code class="xref py py-class docutils literal notranslate"><span class="pre">HF1e</span></code></a>, <a class="reference internal" href="#pyscf.scf.atom_hf.AtomSphAverageRHF" title="pyscf.scf.atom_hf.AtomSphAverageRHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomSphAverageRHF</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf.AtomHF1e.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.atom_hf.AtomHF1e.eig" title="Link to this definition">#</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf.AtomSphAverageRHF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_hf.</span></span><span class="sig-name descname"><span class="pre">AtomSphAverageRHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf.html#AtomSphAverageRHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf.AtomSphAverageRHF" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.hf.RHF" title="pyscf.scf.hf.RHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">RHF</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf.AtomSphAverageRHF.check_sanity">
<span class="sig-name descname"><span class="pre">check_sanity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf.html#AtomSphAverageRHF.check_sanity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf.AtomSphAverageRHF.check_sanity" title="Link to this definition">#</a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf.AtomSphAverageRHF.dump_flags">
<span class="sig-name descname"><span class="pre">dump_flags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf.html#AtomSphAverageRHF.dump_flags"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf.AtomSphAverageRHF.dump_flags" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf.AtomSphAverageRHF.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf.html#AtomSphAverageRHF.eig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf.AtomSphAverageRHF.eig" title="Link to this definition">#</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf.AtomSphAverageRHF.get_grad">
<span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf.html#AtomSphAverageRHF.get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf.AtomSphAverageRHF.get_grad" title="Link to this definition">#</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Orbital occupancy</p>
</dd>
<dt>fock_ao<span class="classifier">2D ndarray</span></dt><dd><p>Fock matrix in AO representation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf.AtomSphAverageRHF.get_occ">
<span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf.html#AtomSphAverageRHF.get_occ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf.AtomSphAverageRHF.get_occ" title="Link to this definition">#</a></dt>
<dd><p>spherically averaged fractional occupancy</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf.AtomSphAverageRHF.scf">
<span class="sig-name descname"><span class="pre">scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf.html#AtomSphAverageRHF.scf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf.AtomSphAverageRHF.scf" title="Link to this definition">#</a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf.AtomSphericAverageRHF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_hf.</span></span><span class="sig-name descname"><span class="pre">AtomSphericAverageRHF</span></span><a class="headerlink" href="#pyscf.scf.atom_hf.AtomSphericAverageRHF" title="Link to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.atom_hf.AtomSphAverageRHF" title="pyscf.scf.atom_hf.AtomSphAverageRHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomSphAverageRHF</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf.frac_occ">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_hf.</span></span><span class="sig-name descname"><span class="pre">frac_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atomic_configuration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[2,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[3,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">2,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">3,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">4,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">5,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">6,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[5,</span> <span class="pre">6,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">6,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">7,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">8,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">9,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">10,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">11,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">12,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[7,</span> <span class="pre">12,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">13,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">2,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">3,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">4,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">12,</span> <span class="pre">7,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">12,</span> <span class="pre">8,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">12,</span> <span class="pre">9,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">12,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[7,</span> <span class="pre">12,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">13,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">14,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">15,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">16,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">17,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[9,</span> <span class="pre">18,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">18,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">19,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">18,</span> <span class="pre">12,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">18,</span> <span class="pre">13,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">16,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">17,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">18,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">19,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[9,</span> <span class="pre">18,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">18,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">19,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">20,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">21,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">22,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">23,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[11,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">21,</span> <span class="pre">0],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">22,</span> <span class="pre">0],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">21,</span> <span class="pre">2],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">4],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">5],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">6],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">7],</span> <span class="pre">[11,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">9],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">11],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">12],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">13],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">14],</span> <span class="pre">[11,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">25,</span> <span class="pre">20,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">22,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">23,</span> <span class="pre">14],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">26,</span> <span class="pre">14],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">27,</span> <span class="pre">14],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">28,</span> <span class="pre">14],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">29,</span> <span class="pre">14],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[11,</span> <span class="pre">24,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">25,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">26,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">27,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">28,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">29,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">31,</span> <span class="pre">14],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">32,</span> <span class="pre">14],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">17],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">18],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">19],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">21],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">23],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">24],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">25],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">26],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">27],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">28],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">31,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">32,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">33,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">36,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">37,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">38,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">39,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">31,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">32,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">33,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">34,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">35,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">36,</span> <span class="pre">40,</span> <span class="pre">28]]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf.html#frac_occ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf.frac_occ" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf.get_atm_nrhf">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_hf.</span></span><span class="sig-name descname"><span class="pre">get_atm_nrhf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atomic_configuration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[2,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[3,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">2,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">3,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">4,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">5,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">6,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[5,</span> <span class="pre">6,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">6,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">7,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">8,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">9,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">10,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">11,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">12,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[7,</span> <span class="pre">12,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">13,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">2,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">3,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">4,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">12,</span> <span class="pre">7,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">12,</span> <span class="pre">8,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">12,</span> <span class="pre">9,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">12,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[7,</span> <span class="pre">12,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">13,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">14,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">15,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">16,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">17,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[9,</span> <span class="pre">18,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">18,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">19,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">18,</span> <span class="pre">12,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">18,</span> <span class="pre">13,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">16,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">17,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">18,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">19,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[9,</span> <span class="pre">18,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">18,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">19,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">20,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">21,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">22,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">23,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[11,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">21,</span> <span class="pre">0],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">22,</span> <span class="pre">0],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">21,</span> <span class="pre">2],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">4],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">5],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">6],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">7],</span> <span class="pre">[11,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">9],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">11],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">12],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">13],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">14],</span> <span class="pre">[11,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">25,</span> <span class="pre">20,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">22,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">23,</span> <span class="pre">14],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">26,</span> <span class="pre">14],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">27,</span> <span class="pre">14],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">28,</span> <span class="pre">14],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">29,</span> <span class="pre">14],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[11,</span> <span class="pre">24,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">25,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">26,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">27,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">28,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">29,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">31,</span> <span class="pre">14],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">32,</span> <span class="pre">14],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">17],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">18],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">19],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">21],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">23],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">24],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">25],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">26],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">27],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">28],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">31,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">32,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">33,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">36,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">37,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">38,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">39,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">31,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">32,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">33,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">34,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">35,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">36,</span> <span class="pre">40,</span> <span class="pre">28]]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf.html#get_atm_nrhf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf.get_atm_nrhf" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="module-pyscf.scf.atom_hf_pp">
<span id="pyscf-scf-atom-hf-pp-module"></span><h2>pyscf.scf.atom_hf_pp module<a class="headerlink" href="#module-pyscf.scf.atom_hf_pp" title="Link to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf_pp.AtomHF1ePP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_hf_pp.</span></span><span class="sig-name descname"><span class="pre">AtomHF1ePP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf_pp.html#AtomHF1ePP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf_pp.AtomHF1ePP" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.rohf.HF1e" title="pyscf.scf.rohf.HF1e"><code class="xref py py-class docutils literal notranslate"><span class="pre">HF1e</span></code></a>, <a class="reference internal" href="#pyscf.scf.atom_hf_pp.AtomSCFPP" title="pyscf.scf.atom_hf_pp.AtomSCFPP"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomSCFPP</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf_pp.AtomHF1ePP.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.atom_hf_pp.AtomHF1ePP.eig" title="Link to this definition">#</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf_pp.AtomHF1ePP.get_hcore">
<span class="sig-name descname"><span class="pre">get_hcore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.atom_hf_pp.AtomHF1ePP.get_hcore" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf_pp.AtomSCFPP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_hf_pp.</span></span><span class="sig-name descname"><span class="pre">AtomSCFPP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf_pp.html#AtomSCFPP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf_pp.AtomSCFPP" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.atom_hf.AtomSphAverageRHF" title="pyscf.scf.atom_hf.AtomSphAverageRHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomSphAverageRHF</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf_pp.AtomSCFPP.get_hcore">
<span class="sig-name descname"><span class="pre">get_hcore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf_pp.html#AtomSCFPP.get_hcore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf_pp.AtomSCFPP.get_hcore" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf_pp.get_pp_loc">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_hf_pp.</span></span><span class="sig-name descname"><span class="pre">get_pp_loc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf_pp.html#get_pp_loc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf_pp.get_pp_loc" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf_pp.get_pp_loc_part1_rs">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_hf_pp.</span></span><span class="sig-name descname"><span class="pre">get_pp_loc_part1_rs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf_pp.html#get_pp_loc_part1_rs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf_pp.get_pp_loc_part1_rs" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf_pp.get_pp_loc_part2">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_hf_pp.</span></span><span class="sig-name descname"><span class="pre">get_pp_loc_part2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf_pp.html#get_pp_loc_part2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf_pp.get_pp_loc_part2" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.atom_hf_pp.get_pp_nl">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_hf_pp.</span></span><span class="sig-name descname"><span class="pre">get_pp_nl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_hf_pp.html#get_pp_nl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_hf_pp.get_pp_nl" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="module-pyscf.scf.atom_ks">
<span id="pyscf-scf-atom-ks-module"></span><h2>pyscf.scf.atom_ks module<a class="headerlink" href="#module-pyscf.scf.atom_ks" title="Link to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.atom_ks.AtomSphAverageRKS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_ks.</span></span><span class="sig-name descname"><span class="pre">AtomSphAverageRKS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_ks.html#AtomSphAverageRKS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_ks.AtomSphAverageRKS" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyscf.dft.html#pyscf.dft.rks.RKS" title="pyscf.dft.rks.RKS"><code class="xref py py-class docutils literal notranslate"><span class="pre">RKS</span></code></a>, <a class="reference internal" href="#pyscf.scf.atom_hf.AtomSphAverageRHF" title="pyscf.scf.atom_hf.AtomSphAverageRHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomSphAverageRHF</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.atom_ks.AtomSphAverageRKS.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.atom_ks.AtomSphAverageRKS.eig" title="Link to this definition">#</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.atom_ks.AtomSphAverageRKS.get_grad">
<span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.atom_ks.AtomSphAverageRKS.get_grad" title="Link to this definition">#</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Orbital occupancy</p>
</dd>
<dt>fock_ao<span class="classifier">2D ndarray</span></dt><dd><p>Fock matrix in AO representation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.atom_ks.AtomSphAverageRKS.get_occ">
<span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.atom_ks.AtomSphAverageRKS.get_occ" title="Link to this definition">#</a></dt>
<dd><p>spherically averaged fractional occupancy</p>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.atom_ks.AtomSphericAverageRKS">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_ks.</span></span><span class="sig-name descname"><span class="pre">AtomSphericAverageRKS</span></span><a class="headerlink" href="#pyscf.scf.atom_ks.AtomSphericAverageRKS" title="Link to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.atom_ks.AtomSphAverageRKS" title="pyscf.scf.atom_ks.AtomSphAverageRKS"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomSphAverageRKS</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.atom_ks.get_atm_nrks">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.atom_ks.</span></span><span class="sig-name descname"><span class="pre">get_atm_nrks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atomic_configuration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[2,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[3,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">2,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">3,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">4,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">5,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[4,</span> <span class="pre">6,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[5,</span> <span class="pre">6,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">6,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">7,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">8,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">9,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">10,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">11,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[6,</span> <span class="pre">12,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[7,</span> <span class="pre">12,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">0,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">1,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">2,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">3,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">4,</span> <span class="pre">0],</span> <span class="pre">[7,</span> <span class="pre">12,</span> <span class="pre">6,</span> <span class="pre">0],</span> <span class="pre">[7,</span> <span class="pre">12,</span> <span class="pre">7,</span> <span class="pre">0],</span> <span class="pre">[7,</span> <span class="pre">12,</span> <span class="pre">8,</span> <span class="pre">0],</span> <span class="pre">[7,</span> <span class="pre">12,</span> <span class="pre">9,</span> <span class="pre">0],</span> <span class="pre">[7,</span> <span class="pre">12,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">12,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">13,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">14,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">15,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">16,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">17,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[9,</span> <span class="pre">18,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">18,</span> <span class="pre">10,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">18,</span> <span class="pre">11,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">18,</span> <span class="pre">12,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">18,</span> <span class="pre">13,</span> <span class="pre">0],</span> <span class="pre">[9,</span> <span class="pre">18,</span> <span class="pre">15,</span> <span class="pre">0],</span> <span class="pre">[9,</span> <span class="pre">18,</span> <span class="pre">16,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">18,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">19,</span> <span class="pre">0],</span> <span class="pre">[8,</span> <span class="pre">18,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[9,</span> <span class="pre">18,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">18,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">19,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">20,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">21,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">22,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">23,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[11,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">0],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">1],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">2],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">3],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">4],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">5],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">6],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">7],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">8],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">9],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">10],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">11],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">12],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">13],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">20,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">21,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">22,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">23,</span> <span class="pre">14],</span> <span class="pre">[11,</span> <span class="pre">24,</span> <span class="pre">25,</span> <span class="pre">14],</span> <span class="pre">[11,</span> <span class="pre">24,</span> <span class="pre">26,</span> <span class="pre">14],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">28,</span> <span class="pre">14],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">29,</span> <span class="pre">14],</span> <span class="pre">[10,</span> <span class="pre">24,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[11,</span> <span class="pre">24,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">24,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">25,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">26,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">27,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">28,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">29,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">14],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">15],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">16],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">17],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">19],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">20],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">21],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">22],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">23],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">24],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">25],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">26],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">27],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">30,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">31,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">32,</span> <span class="pre">28],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">34,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">36,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">37,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">38,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">39,</span> <span class="pre">28],</span> <span class="pre">[12,</span> <span class="pre">30,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[13,</span> <span class="pre">30,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">30,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">31,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">32,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">33,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">34,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">35,</span> <span class="pre">40,</span> <span class="pre">28],</span> <span class="pre">[14,</span> <span class="pre">36,</span> <span class="pre">40,</span> <span class="pre">28]]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'slater'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(100,</span> <span class="pre">434)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/atom_ks.html#get_atm_nrks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.atom_ks.get_atm_nrks" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="module-pyscf.scf.chkfile">
<span id="pyscf-scf-chkfile-module"></span><h2>pyscf.scf.chkfile module<a class="headerlink" href="#module-pyscf.scf.chkfile" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.chkfile.dump_scf">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.chkfile.</span></span><span class="sig-name descname"><span class="pre">dump_scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chkfile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_tot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite_mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/chkfile.html#dump_scf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.chkfile.dump_scf" title="Link to this definition">#</a></dt>
<dd><p>save temporary results</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.chkfile.load_scf">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.chkfile.</span></span><span class="sig-name descname"><span class="pre">load_scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/chkfile.html#load_scf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.chkfile.load_scf" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="module-pyscf.scf.cphf">
<span id="pyscf-scf-cphf-module"></span><h2>pyscf.scf.cphf module<a class="headerlink" href="#module-pyscf.scf.cphf" title="Link to this heading">#</a></h2>
<p>Restricted coupled perturbed Hartree-Fock solver</p>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.cphf.kernel">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.cphf.</span></span><span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fvind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.cphf.kernel" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>fvind<span class="classifier">function</span></dt><dd><p>Given density matrix, compute (ij|kl)D_{lk}*2 - (ij|kl)D_{jk}</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>hermi<span class="classifier">boolean</span></dt><dd><p>Whether the matrix defined by fvind is Hermitian or not.</p>
</dd>
<dt>level_shift<span class="classifier">float</span></dt><dd><p>Add to diagonal terms to slightly improve the convergence speed of
Krylov solver</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.cphf.solve">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.cphf.</span></span><span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fvind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/cphf.html#solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.cphf.solve" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>fvind<span class="classifier">function</span></dt><dd><p>Given density matrix, compute (ij|kl)D_{lk}*2 - (ij|kl)D_{jk}</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>hermi<span class="classifier">boolean</span></dt><dd><p>Whether the matrix defined by fvind is Hermitian or not.</p>
</dd>
<dt>level_shift<span class="classifier">float</span></dt><dd><p>Add to diagonal terms to slightly improve the convergence speed of
Krylov solver</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.cphf.solve_nos1">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.cphf.</span></span><span class="sig-name descname"><span class="pre">solve_nos1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fvind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/cphf.html#solve_nos1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.cphf.solve_nos1" title="Link to this definition">#</a></dt>
<dd><p>For field independent basis. First order overlap matrix is zero</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>level_shift<span class="classifier">float</span></dt><dd><p>Add to diagonal terms to slightly improve the convergence speed of
Krylov solver</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.cphf.solve_withs1">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.cphf.</span></span><span class="sig-name descname"><span class="pre">solve_withs1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fvind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/cphf.html#solve_withs1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.cphf.solve_withs1" title="Link to this definition">#</a></dt>
<dd><p>For field dependent basis. First order overlap matrix is non-zero.
The first order orbitals are set to
C^1_{ij} = -1/2 S1
e1 = h1 - s1*e0 + (e0_j-e0_i)*c1 + vhf[c1]</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>level_shift<span class="classifier">float</span></dt><dd><p>Add to diagonal terms to slightly improve the convergence speed of
Krylov solver</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>First order orbital coefficients (in MO basis) and first order orbital
energy matrix</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyscf.scf.dhf">
<span id="pyscf-scf-dhf-module"></span><h2>pyscf.scf.dhf module<a class="headerlink" href="#module-pyscf.scf.dhf" title="Link to this heading">#</a></h2>
<p>Dirac Hartree-Fock</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">DHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.hf.SCF" title="pyscf.scf.hf.SCF"><code class="xref py py-class docutils literal notranslate"><span class="pre">SCF</span></code></a></p>
<p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="simple">
<dt>Attributes for Dirac-Hartree-Fock</dt><dd><dl class="simple">
<dt>with_ssss<span class="classifier">bool or string, for Dirac-Hartree-Fock only</span></dt><dd><p>If False, ignore small component integrals (SS|SS).  Default is True.</p>
</dd>
<dt>with_gaunt<span class="classifier">bool, for Dirac-Hartree-Fock only</span></dt><dd><p>Default is False.</p>
</dd>
<dt>with_breit<span class="classifier">bool, for Dirac-Hartree-Fock only</span></dt><dd><p>Gaunt + gauge term.  Default is False.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e0</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">DHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Relativistic effects = </span><span class="si">%.12f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e1</span><span class="o">-</span><span class="n">e0</span><span class="p">))</span>
<span class="go">Relativistic effects = -0.000008854205</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.Gradients">
<span class="sig-name descname"><span class="pre">Gradients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.DHF.Gradients" title="Link to this definition">#</a></dt>
<dd><p>Unrestricted Dirac-Hartree-Fock gradients</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.TDA">
<span class="sig-name descname"><span class="pre">TDA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.DHF.TDA" title="Link to this definition">#</a></dt>
<dd><p>Tamm-Dancoff approximation</p>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Diagonalization convergence tolerance.  Default is 1e-9.</p>
</dd>
<dt>nstates<span class="classifier">int</span></dt><dd><p>Number of TD states to be computed. Default is 3.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Diagonalization converged or not</p>
</dd>
<dt>e<span class="classifier">1D array</span></dt><dd><p>excitation energy for each excited state.</p>
</dd>
<dt>xy<span class="classifier">A list of two 2D arrays</span></dt><dd><p>The two 2D arrays are Excitation coefficients X (shape [nocc,nvir])
and de-excitation coefficients Y (shape [nocc,nvir]) for each
excited state.  (X,Y) are normalized to 1/2 in RHF/RKS methods and
normalized to 1 for UHF/UKS methods. In the TDA calculation, Y = 0.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.TDHF">
<span class="sig-name descname"><span class="pre">TDHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.DHF.TDHF" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.analyze">
<span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.build"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.build" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.conv_tol">
<span class="sig-name descname"><span class="pre">conv_tol</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-08</span></em><a class="headerlink" href="#pyscf.scf.dhf.DHF.conv_tol" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.dip_moment">
<span class="sig-name descname"><span class="pre">dip_moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Debye'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.dip_moment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.dip_moment" title="Link to this definition">#</a></dt>
<dd><p>Dipole moment calculation</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mu_x = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|x|\mu) + \sum_A Q_A X_A\\
\mu_y = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|y|\mu) + \sum_A Q_A Y_A\\
\mu_z = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|z|\mu) + \sum_A Q_A Z_A\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu_x, \mu_y, \mu_z\)</span> are the x, y and z components of dipole
moment</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mol: an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code>
dm : a 2D ndarrays density matrices</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z component</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.dump_flags">
<span class="sig-name descname"><span class="pre">dump_flags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.dump_flags"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.dump_flags" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.energy_elec">
<span class="sig-name descname"><span class="pre">energy_elec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.DHF.energy_elec" title="Link to this definition">#</a></dt>
<dd><p>Electronic part of Dirac-Hartree-Fock energy</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mf : an instance of SCF class</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm<span class="classifier">2D ndarray</span></dt><dd><p>one-particle density matrix</p>
</dd>
<dt>h1e<span class="classifier">2D ndarray</span></dt><dd><p>Core hamiltonian</p>
</dd>
<dt>vhf<span class="classifier">2D ndarray</span></dt><dd><p>HF potential</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Hartree-Fock electronic energy and the Coulomb energy</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.gen_response">
<span class="sig-name descname"><span class="pre">gen_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_j</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.DHF.gen_response" title="Link to this definition">#</a></dt>
<dd><p>Generate a function to compute the product of DHF response function and
DHF density matrices.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.get_grad">
<span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.get_grad" title="Link to this definition">#</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Orbital occupancy</p>
</dd>
<dt>fock_ao<span class="classifier">2D ndarray</span></dt><dd><p>Fock matrix in AO representation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.get_hcore">
<span class="sig-name descname"><span class="pre">get_hcore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.get_hcore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.get_hcore" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.get_jk">
<span class="sig-name descname"><span class="pre">get_jk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_j</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.get_jk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.get_jk" title="Link to this definition">#</a></dt>
<dd><p>Compute J, K matrices for all input density matrices</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : not hermitian and not symmetric</div>
<div class="line">1 : hermitian or symmetric</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
<dt>with_j<span class="classifier">boolean</span></dt><dd><p>Whether to compute J matrices</p>
</dd>
<dt>with_k<span class="classifier">boolean</span></dt><dd><p>Whether to compute K matrices</p>
</dd>
<dt>omega<span class="classifier">float</span></dt><dd><p>Parameter of range-separated Coulomb operator: erf( omega * r12 ) / r12.
If specified, integration are evaluated based on the long-range
part of the range-separated Coulomb operator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="kn">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.get_occ">
<span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.get_occ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.get_occ" title="Link to this definition">#</a></dt>
<dd><p>Label the occupancies for each orbital</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">1D ndarray</span></dt><dd><p>Obital energies</p>
</dd>
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 0, 2, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.get_ovlp">
<span class="sig-name descname"><span class="pre">get_ovlp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.get_ovlp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.get_ovlp" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.get_veff">
<span class="sig-name descname"><span class="pre">get_veff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.get_veff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.get_veff" title="Link to this definition">#</a></dt>
<dd><p>Dirac-Coulomb</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.init_direct_scf">
<span class="sig-name descname"><span class="pre">init_direct_scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.init_direct_scf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.init_direct_scf" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.init_guess_by_atom">
<span class="sig-name descname"><span class="pre">init_guess_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.init_guess_by_atom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.init_guess_by_atom" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.init_guess_by_chkfile">
<span class="sig-name descname"><span class="pre">init_guess_by_chkfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.init_guess_by_chkfile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.init_guess_by_chkfile" title="Link to this definition">#</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.init_guess_by_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.init_guess_by_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.init_guess_by_huckel" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.init_guess_by_minao">
<span class="sig-name descname"><span class="pre">init_guess_by_minao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.init_guess_by_minao"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.init_guess_by_minao" title="Link to this definition">#</a></dt>
<dd><p>Initial guess in terms of the overlap to minimal basis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.init_guess_by_mod_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_mod_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.init_guess_by_mod_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.init_guess_by_mod_huckel" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<p>In contrast to init_guess_by_huckel, this routine employs the
updated GWH rule from doi:10.1021/ja00480a005 to form the guess.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.init_guess_by_sap">
<span class="sig-name descname"><span class="pre">init_guess_by_sap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.init_guess_by_sap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.init_guess_by_sap" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a superposition of
atomic potentials (SAP), doi:10.1021/acs.jctc.8b01089.
This is the Gaussian fit implementation, see doi:10.1063/5.0004046.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mol<span class="classifier">MoleBase object</span></dt><dd><p>the molecule object for which the initial guess is evaluated</p>
</dd>
<dt>sap_basis<span class="classifier">dict</span></dt><dd><p>SAP basis in internal format (python dictionary)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>SAP initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.make_rdm1">
<span class="sig-name descname"><span class="pre">make_rdm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.DHF.make_rdm1" title="Link to this definition">#</a></dt>
<dd><p>One-particle density matrix in AO representation</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Orbital coefficients. Each column is one orbital.</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Occupancy</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>One-particle density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.mulliken_pop">
<span class="sig-name descname"><span class="pre">mulliken_pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.mulliken_pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.mulliken_pop" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.nuc_grad_method">
<span class="sig-name descname"><span class="pre">nuc_grad_method</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.nuc_grad_method"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.nuc_grad_method" title="Link to this definition">#</a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.reset" title="Link to this definition">#</a></dt>
<dd><p>Reset mol and clean up relevant attributes for scanner mode</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.scf">
<span class="sig-name descname"><span class="pre">scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.scf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.scf" title="Link to this definition">#</a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.sfx2c1e">
<span class="sig-name descname"><span class="pre">sfx2c1e</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.sfx2c1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.sfx2c1e" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.ssss_approx">
<span class="sig-name descname"><span class="pre">ssss_approx</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'Visscher'</span></em><a class="headerlink" href="#pyscf.scf.dhf.DHF.ssss_approx" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.stability">
<span class="sig-name descname"><span class="pre">stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">internal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.stability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.stability" title="Link to this definition">#</a></dt>
<dd><p>DHF/DKS stability analysis.</p>
<p>See also pyscf.scf.stability.rhf_stability function.</p>
<dl>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>return_status: bool</dt><dd><p>Whether to return <cite>stable_i</cite> and <cite>stable_e</cite></p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>If return_status is False (default), the return value includes
two set of orbitals, which are more close to the stable condition.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
<p>Else, another two boolean variables (indicating current status:
stable or unstable) are returned.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.to_dhf">
<span class="sig-name descname"><span class="pre">to_dhf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.to_dhf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.to_dhf" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.to_dks">
<span class="sig-name descname"><span class="pre">to_dks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.to_dks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.to_dks" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a DKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.to_ghf">
<span class="sig-name descname"><span class="pre">to_ghf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.to_ghf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.to_ghf" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a GHF object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.to_gks">
<span class="sig-name descname"><span class="pre">to_gks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.to_gks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.to_gks" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a GKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.to_gpu">
<span class="sig-name descname"><span class="pre">to_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.DHF.to_gpu" title="Link to this definition">#</a></dt>
<dd><p>Convert a method to its corresponding GPU variant, and recursively
converts all attributes of a method to cupy objects or gpu4pyscf objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.to_ks">
<span class="sig-name descname"><span class="pre">to_ks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.DHF.to_ks" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a DKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.to_rhf">
<span class="sig-name descname"><span class="pre">to_rhf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.to_rhf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.to_rhf" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a RHF/ROHF object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.to_rks">
<span class="sig-name descname"><span class="pre">to_rks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.to_rks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.to_rks" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a RKS/ROKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.to_uhf">
<span class="sig-name descname"><span class="pre">to_uhf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.to_uhf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.to_uhf" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a UHF object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.to_uks">
<span class="sig-name descname"><span class="pre">to_uks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.to_uks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.to_uks" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a UKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.with_breit">
<span class="sig-name descname"><span class="pre">with_breit</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#pyscf.scf.dhf.DHF.with_breit" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.with_gaunt">
<span class="sig-name descname"><span class="pre">with_gaunt</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#pyscf.scf.dhf.DHF.with_gaunt" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.with_ssss">
<span class="sig-name descname"><span class="pre">with_ssss</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#pyscf.scf.dhf.DHF.with_ssss" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.x2c">
<span class="sig-name descname"><span class="pre">x2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.DHF.x2c" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.DHF.x2c1e">
<span class="sig-name descname"><span class="pre">x2c1e</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#DHF.x2c1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.DHF.x2c1e" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.dhf.HF1e">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">HF1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#HF1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.HF1e" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.dhf.DHF" title="pyscf.scf.dhf.DHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">DHF</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.HF1e.scf">
<span class="sig-name descname"><span class="pre">scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.HF1e.scf" title="Link to this definition">#</a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.dhf.RDHF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">RDHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#RDHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.RDHF" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.dhf.DHF" title="pyscf.scf.dhf.DHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">DHF</span></code></a></p>
<p>Kramers restricted Dirac-Hartree-Fock</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.RDHF.TDA">
<span class="sig-name descname"><span class="pre">TDA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.RDHF.TDA" title="Link to this definition">#</a></dt>
<dd><p>Tamm-Dancoff approximation</p>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Diagonalization convergence tolerance.  Default is 1e-9.</p>
</dd>
<dt>nstates<span class="classifier">int</span></dt><dd><p>Number of TD states to be computed. Default is 3.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Diagonalization converged or not</p>
</dd>
<dt>e<span class="classifier">1D array</span></dt><dd><p>excitation energy for each excited state.</p>
</dd>
<dt>xy<span class="classifier">A list of two 2D arrays</span></dt><dd><p>The two 2D arrays are Excitation coefficients X (shape [nocc,nvir])
and de-excitation coefficients Y (shape [nocc,nvir]) for each
excited state.  (X,Y) are normalized to 1/2 in RHF/RKS methods and
normalized to 1 for UHF/UKS methods. In the TDA calculation, Y = 0.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.RDHF.TDHF">
<span class="sig-name descname"><span class="pre">TDHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.RDHF.TDHF" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.RDHF.to_dks">
<span class="sig-name descname"><span class="pre">to_dks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#RDHF.to_dks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.RDHF.to_dks" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a DKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.RDHF.x2c">
<span class="sig-name descname"><span class="pre">x2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.RDHF.x2c" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.dhf.RDHF.x2c1e">
<span class="sig-name descname"><span class="pre">x2c1e</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#RDHF.x2c1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.RDHF.x2c1e" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.dhf.RHF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">RHF</span></span><a class="headerlink" href="#pyscf.scf.dhf.RHF" title="Link to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.dhf.RDHF" title="pyscf.scf.dhf.RDHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">RDHF</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.dhf.UDHF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">UDHF</span></span><a class="headerlink" href="#pyscf.scf.dhf.UDHF" title="Link to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.dhf.DHF" title="pyscf.scf.dhf.DHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">DHF</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.dhf.UHF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">UHF</span></span><a class="headerlink" href="#pyscf.scf.dhf.UHF" title="Link to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.dhf.DHF" title="pyscf.scf.dhf.DHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">DHF</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.analyze">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.analyze" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.dip_moment">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">dip_moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Debye'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#dip_moment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.dip_moment" title="Link to this definition">#</a></dt>
<dd><p>Dipole moment calculation</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mu_x = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|x|\mu) + \sum_A Q_A X_A\\
\mu_y = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|y|\mu) + \sum_A Q_A Y_A\\
\mu_z = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|z|\mu) + \sum_A Q_A Z_A\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu_x, \mu_y, \mu_z\)</span> are the x, y and z components of dipole
moment</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mol: an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code>
dm : a 2D ndarrays density matrices</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z component</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.energy_elec">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">energy_elec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#energy_elec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.energy_elec" title="Link to this definition">#</a></dt>
<dd><p>Electronic part of Dirac-Hartree-Fock energy</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mf : an instance of SCF class</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm<span class="classifier">2D ndarray</span></dt><dd><p>one-particle density matrix</p>
</dd>
<dt>h1e<span class="classifier">2D ndarray</span></dt><dd><p>Core hamiltonian</p>
</dd>
<dt>vhf<span class="classifier">2D ndarray</span></dt><dd><p>HF potential</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Hartree-Fock electronic energy and the Coulomb energy</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.get_grad">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock_ao</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.get_grad" title="Link to this definition">#</a></dt>
<dd><p>DHF Gradients</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.get_hcore">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">get_hcore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#get_hcore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.get_hcore" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.get_init_guess">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">get_init_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'minao'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#get_init_guess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.get_init_guess" title="Link to this definition">#</a></dt>
<dd><p>Generate density matrix for initial guess</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>key<span class="classifier">str</span></dt><dd><p>One of ‘minao’, ‘atom’, ‘huckel’, ‘mod_huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.get_jk">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">get_jk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coulomb_allow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'SSSS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_llll</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_ssll</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_ssss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.dhf.get_jk" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.get_jk_coulomb">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">get_jk_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coulomb_allow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'SSSS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_llll</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_ssll</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opt_ssss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#get_jk_coulomb"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.get_jk_coulomb" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.get_ovlp">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">get_ovlp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#get_ovlp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.get_ovlp" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.init_guess_by_1e">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#init_guess_by_1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.init_guess_by_1e" title="Link to this definition">#</a></dt>
<dd><p>Initial guess from one electron system.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.init_guess_by_atom">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#init_guess_by_atom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.init_guess_by_atom" title="Link to this definition">#</a></dt>
<dd><p>Initial guess from atom calculation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.init_guess_by_chkfile">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_chkfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chkfile_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#init_guess_by_chkfile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.init_guess_by_chkfile" title="Link to this definition">#</a></dt>
<dd><p>Read SCF chkfile and make the density matrix for 4C-DHF initial guess.</p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.init_guess_by_huckel">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#init_guess_by_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.init_guess_by_huckel" title="Link to this definition">#</a></dt>
<dd><p>Initial guess from on-the-fly Huckel, doi:10.1021/acs.jctc.8b01089.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.init_guess_by_minao">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_minao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#init_guess_by_minao"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.init_guess_by_minao" title="Link to this definition">#</a></dt>
<dd><p>Initial guess in terms of the overlap to minimal basis.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.init_guess_by_mod_huckel">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_mod_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#init_guess_by_mod_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.init_guess_by_mod_huckel" title="Link to this definition">#</a></dt>
<dd><p>Initial guess from on-the-fly Huckel, doi:10.1021/acs.jctc.8b01089,
employing the updated GWH rule from doi:10.1021/ja00480a005.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.init_guess_by_sap">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_sap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#init_guess_by_sap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.init_guess_by_sap" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a superposition of
atomic potentials (SAP), doi:10.1021/acs.jctc.8b01089.
This is the Gaussian fit implementation, see doi:10.1063/5.0004046.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mol<span class="classifier">MoleBase object</span></dt><dd><p>the molecule object for which the initial guess is evaluated</p>
</dd>
<dt>sap_basis<span class="classifier">dict</span></dt><dd><p>SAP basis in internal format (python dictionary)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>SAP initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.kernel">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_tol_grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dump_chk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.kernel" title="Link to this definition">#</a></dt>
<dd><p>the modified SCF kernel for Dirac-Hartree-Fock.  In this kernel, the
SCF is carried out in three steps.  First the 2-electron part is
approximated by large component integrals (LL|LL); Next, (SS|LL) the
interaction between large and small components are added; Finally,
converge the SCF with the small component contributions (SS|SS)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.mulliken_pop">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">mulliken_pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#mulliken_pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.mulliken_pop" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dhf.time_reversal_matrix">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dhf.</span></span><span class="sig-name descname"><span class="pre">time_reversal_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dhf.html#time_reversal_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dhf.time_reversal_matrix" title="Link to this definition">#</a></dt>
<dd><p>T(A_ij) = A[T(i),T(j)]^*</p>
</dd></dl>

</section>
<section id="module-pyscf.scf.diis">
<span id="pyscf-scf-diis-module"></span><h2>pyscf.scf.diis module<a class="headerlink" href="#module-pyscf.scf.diis" title="Link to this heading">#</a></h2>
<p>DIIS</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.diis.ADIIS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.diis.</span></span><span class="sig-name descname"><span class="pre">ADIIS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/diis.html#ADIIS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.diis.ADIIS" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyscf.lib.html#pyscf.lib.diis.DIIS" title="pyscf.lib.diis.DIIS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DIIS</span></code></a></p>
<p>Ref: JCP 132, 054109 (2010); DOI:10.1063/1.3304922</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.diis.ADIIS.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/diis.html#ADIIS.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.diis.ADIIS.update" title="Link to this definition">#</a></dt>
<dd><p>Extrapolate vector</p>
<ul class="simple">
<li><p>If xerr the error vector is given, this function will push the target</p></li>
</ul>
<p>vector and error vector in the DIIS subspace, and use the error vector
to extrapolate the vector and return the extrapolated vector.
* If xerr is None, this function will take the difference between
the current given vector and the last given vector as the error
vector to extrapolate the vector.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.diis.CDIIS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.diis.</span></span><span class="sig-name descname"><span class="pre">CDIIS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Corth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/diis.html#CDIIS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.diis.CDIIS" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyscf.lib.html#pyscf.lib.diis.DIIS" title="pyscf.lib.diis.DIIS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DIIS</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.diis.CDIIS.get_num_vec">
<span class="sig-name descname"><span class="pre">get_num_vec</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/diis.html#CDIIS.get_num_vec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.diis.CDIIS.get_num_vec" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.diis.CDIIS.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/diis.html#CDIIS.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.diis.CDIIS.update" title="Link to this definition">#</a></dt>
<dd><p>Extrapolate vector</p>
<ul class="simple">
<li><p>If xerr the error vector is given, this function will push the target</p></li>
</ul>
<p>vector and error vector in the DIIS subspace, and use the error vector
to extrapolate the vector and return the extrapolated vector.
* If xerr is None, this function will take the difference between
the current given vector and the last given vector as the error
vector to extrapolate the vector.</p>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.diis.DIIS">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.diis.</span></span><span class="sig-name descname"><span class="pre">DIIS</span></span><a class="headerlink" href="#pyscf.scf.diis.DIIS" title="Link to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.diis.CDIIS" title="pyscf.scf.diis.CDIIS"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDIIS</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.diis.EDIIS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.diis.</span></span><span class="sig-name descname"><span class="pre">EDIIS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/diis.html#EDIIS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.diis.EDIIS" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyscf.lib.html#pyscf.lib.diis.DIIS" title="pyscf.lib.diis.DIIS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DIIS</span></code></a></p>
<p>SCF-EDIIS
Ref: JCP 116, 8255 (2002); DOI:10.1063/1.1470195</p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.diis.EDIIS.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/diis.html#EDIIS.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.diis.EDIIS.update" title="Link to this definition">#</a></dt>
<dd><p>Extrapolate vector</p>
<ul class="simple">
<li><p>If xerr the error vector is given, this function will push the target</p></li>
</ul>
<p>vector and error vector in the DIIS subspace, and use the error vector
to extrapolate the vector and return the extrapolated vector.
* If xerr is None, this function will take the difference between
the current given vector and the last given vector as the error
vector to extrapolate the vector.</p>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.diis.SCFDIIS">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.diis.</span></span><span class="sig-name descname"><span class="pre">SCFDIIS</span></span><a class="headerlink" href="#pyscf.scf.diis.SCFDIIS" title="Link to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.diis.CDIIS" title="pyscf.scf.diis.CDIIS"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDIIS</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.diis.SCF_DIIS">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.diis.</span></span><span class="sig-name descname"><span class="pre">SCF_DIIS</span></span><a class="headerlink" href="#pyscf.scf.diis.SCF_DIIS" title="Link to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.diis.CDIIS" title="pyscf.scf.diis.CDIIS"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDIIS</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.diis.adiis_minimize">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.diis.</span></span><span class="sig-name descname"><span class="pre">adiis_minimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idnewest</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/diis.html#adiis_minimize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.diis.adiis_minimize" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.diis.ediis_minimize">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.diis.</span></span><span class="sig-name descname"><span class="pre">ediis_minimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">es</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/diis.html#ediis_minimize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.diis.ediis_minimize" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.diis.get_err_vec">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.diis.</span></span><span class="sig-name descname"><span class="pre">get_err_vec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Corth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/diis.html#get_err_vec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.diis.get_err_vec" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.diis.get_err_vec_orig">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.diis.</span></span><span class="sig-name descname"><span class="pre">get_err_vec_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/diis.html#get_err_vec_orig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.diis.get_err_vec_orig" title="Link to this definition">#</a></dt>
<dd><p>error vector = SDF - FDS</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.diis.get_err_vec_orth">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.diis.</span></span><span class="sig-name descname"><span class="pre">get_err_vec_orth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Corth</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/diis.html#get_err_vec_orth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.diis.get_err_vec_orth" title="Link to this definition">#</a></dt>
<dd><p>error vector in orthonormal basis = C.T.conj() (SDF - FDS) C</p>
</dd></dl>

</section>
<section id="module-pyscf.scf.dispersion">
<span id="pyscf-scf-dispersion-module"></span><h2>pyscf.scf.dispersion module<a class="headerlink" href="#module-pyscf.scf.dispersion" title="Link to this heading">#</a></h2>
<p>dispersion correction for HF and DFT</p>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dispersion.check_disp">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dispersion.</span></span><span class="sig-name descname"><span class="pre">check_disp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dispersion.html#check_disp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dispersion.check_disp" title="Link to this definition">#</a></dt>
<dd><p>Check whether to apply dispersion correction based on the xc attribute.
If dispersion is allowed, return the DFTD3 disp version, such as d3bj,
d3zero, d4.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dispersion.get_dispersion">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dispersion.</span></span><span class="sig-name descname"><span class="pre">get_dispersion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_3body</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dispersion.html#get_dispersion"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dispersion.get_dispersion" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dispersion.parse_dft">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dispersion.</span></span><span class="sig-name descname"><span class="pre">parse_dft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc_code</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dispersion.html#parse_dft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dispersion.parse_dft" title="Link to this definition">#</a></dt>
<dd><p>Extract (xc, nlc, disp) from xc_code</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.dispersion.parse_disp">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.dispersion.</span></span><span class="sig-name descname"><span class="pre">parse_disp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dft_method</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/dispersion.html#parse_disp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.dispersion.parse_disp" title="Link to this definition">#</a></dt>
<dd><p>Decode the disp parameters based on the xc code.
Returns xc_code_for_dftd3, disp_version, with_3body</p>
<dl class="simple">
<dt>Example: b3lyp-d3bj2b -&gt; (b3lyp, d3bj, False)</dt><dd><p>wb97x-d3bj   -&gt; (wb97x, d3bj, False)</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyscf.scf.ghf">
<span id="pyscf-scf-ghf-module"></span><h2>pyscf.scf.ghf module<a class="headerlink" href="#module-pyscf.scf.ghf" title="Link to this heading">#</a></h2>
<p>Non-relativistic generalized Hartree-Fock</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf.</span></span><span class="sig-name descname"><span class="pre">GHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.hf.SCF" title="pyscf.scf.hf.SCF"><code class="xref py py-class docutils literal notranslate"><span class="pre">SCF</span></code></a></p>
<p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="simple">
<dt>Attributes for GHF method</dt><dd><p>GHF orbital coefficients are 2D array.  Let nao be the number of spatial
AOs, mo_coeff[:nao] are the coefficients of AO with alpha spin;
mo_coeff[nao:nao*2] are the coefficients of AO with beta spin.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.CISD">
<span class="sig-name descname"><span class="pre">CISD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ghf.GHF.CISD" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.MP2">
<span class="sig-name descname"><span class="pre">MP2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ghf.GHF.MP2" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.TDA">
<span class="sig-name descname"><span class="pre">TDA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ghf.GHF.TDA" title="Link to this definition">#</a></dt>
<dd><p>Tamm-Dancoff approximation</p>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Diagonalization convergence tolerance.  Default is 1e-9.</p>
</dd>
<dt>nstates<span class="classifier">int</span></dt><dd><p>Number of TD states to be computed. Default is 3.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Diagonalization converged or not</p>
</dd>
<dt>e<span class="classifier">1D array</span></dt><dd><p>excitation energy for each excited state.</p>
</dd>
<dt>xy<span class="classifier">A list of two 2D arrays</span></dt><dd><p>The two 2D arrays are Excitation coefficients X (shape [nocc,nvir])
and de-excitation coefficients Y (shape [nocc,nvir]) for each
excited state.  (X,Y) are normalized to 1/2 in RHF/RKS methods and
normalized to 1 for UHF/UKS methods. In the TDA calculation, Y = 0.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.TDHF">
<span class="sig-name descname"><span class="pre">TDHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ghf.GHF.TDHF" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.analyze">
<span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.convert_from_">
<span class="sig-name descname"><span class="pre">convert_from_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.convert_from_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.convert_from_" title="Link to this definition">#</a></dt>
<dd><p>Create GHF object based on the RHF/UHF object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.det_ovlp">
<span class="sig-name descname"><span class="pre">det_ovlp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ovlp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.det_ovlp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.det_ovlp" title="Link to this definition">#</a></dt>
<dd><p>Calculate the overlap between two different determinants. It is the product
of single values of molecular orbital overlap matrix.</p>
<dl class="simple">
<dt>Return:</dt><dd><dl class="simple">
<dt>A list:</dt><dd><p>the product of single values: float
x_a: <span class="math notranslate nohighlight">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>
They are used to calculate asymmetric density matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.dip_moment">
<span class="sig-name descname"><span class="pre">dip_moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit_symbol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Debye'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.dip_moment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.dip_moment" title="Link to this definition">#</a></dt>
<dd><p>Dipole moment calculation</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mu_x = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|x|\mu) + \sum_A Q_A X_A\\
\mu_y = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|y|\mu) + \sum_A Q_A Y_A\\
\mu_z = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|z|\mu) + \sum_A Q_A Z_A\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu_x, \mu_y, \mu_z\)</span> are the x, y and z components of dipole
moment</p>
<dl>
<dt>Args:</dt><dd><p>mol: an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code>
dm : a 2D ndarrays density matrices
origin : optional; length 3 list, tuple, or 1D array</p>
<blockquote>
<div><p>Location of the origin. By default, the point (0, 0, 0) is used.</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z component</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.gen_response">
<span class="sig-name descname"><span class="pre">gen_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_j</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ghf.GHF.gen_response" title="Link to this definition">#</a></dt>
<dd><p>Generate a function to compute the product of GHF response function and
GHF density matrices.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.get_grad">
<span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.get_grad" title="Link to this definition">#</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Orbital occupancy</p>
</dd>
<dt>fock_ao<span class="classifier">2D ndarray</span></dt><dd><p>Fock matrix in AO representation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.get_hcore">
<span class="sig-name descname"><span class="pre">get_hcore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.get_hcore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.get_hcore" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.get_init_guess">
<span class="sig-name descname"><span class="pre">get_init_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'minao'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ghf.GHF.get_init_guess" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.get_jk">
<span class="sig-name descname"><span class="pre">get_jk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_j</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.get_jk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.get_jk" title="Link to this definition">#</a></dt>
<dd><p>Compute J, K matrices for all input density matrices</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : not hermitian and not symmetric</div>
<div class="line">1 : hermitian or symmetric</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
<dt>with_j<span class="classifier">boolean</span></dt><dd><p>Whether to compute J matrices</p>
</dd>
<dt>with_k<span class="classifier">boolean</span></dt><dd><p>Whether to compute K matrices</p>
</dd>
<dt>omega<span class="classifier">float</span></dt><dd><p>Parameter of range-separated Coulomb operator: erf( omega * r12 ) / r12.
If specified, integration are evaluated based on the long-range
part of the range-separated Coulomb operator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="kn">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.get_occ">
<span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ghf.GHF.get_occ" title="Link to this definition">#</a></dt>
<dd><p>Label the occupancies for each orbital</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">1D ndarray</span></dt><dd><p>Obital energies</p>
</dd>
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 0, 2, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.get_ovlp">
<span class="sig-name descname"><span class="pre">get_ovlp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.get_ovlp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.get_ovlp" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.get_veff">
<span class="sig-name descname"><span class="pre">get_veff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.get_veff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.get_veff" title="Link to this definition">#</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>dm_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</p>
</dd>
<dt>vhf_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The reference HF potential matrix.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>matrix Vhf = 2*J - K.  Vhf can be a list matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="kn">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf0</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">dm_last</span><span class="o">=</span><span class="n">dm0</span><span class="p">,</span> <span class="n">vhf_last</span><span class="o">=</span><span class="n">vhf0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vhf1</span><span class="p">,</span> <span class="n">vhf2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.init_guess_by_atom">
<span class="sig-name descname"><span class="pre">init_guess_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.init_guess_by_atom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.init_guess_by_atom" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.init_guess_by_chkfile">
<span class="sig-name descname"><span class="pre">init_guess_by_chkfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.init_guess_by_chkfile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.init_guess_by_chkfile" title="Link to this definition">#</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.init_guess_by_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.init_guess_by_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.init_guess_by_huckel" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.init_guess_by_minao">
<span class="sig-name descname"><span class="pre">init_guess_by_minao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.init_guess_by_minao"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.init_guess_by_minao" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix based on ANO basis, then project
the density matrix to the basis set defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">init_guess_by_minao</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">array([[ 0.94758917,  0.09227308],</span>
<span class="go">       [ 0.09227308,  0.94758917]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.init_guess_by_mod_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_mod_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.init_guess_by_mod_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.init_guess_by_mod_huckel" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<p>In contrast to init_guess_by_huckel, this routine employs the
updated GWH rule from doi:10.1021/ja00480a005 to form the guess.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.init_guess_by_sap">
<span class="sig-name descname"><span class="pre">init_guess_by_sap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.init_guess_by_sap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.init_guess_by_sap" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a superposition of
atomic potentials (SAP), doi:10.1021/acs.jctc.8b01089.
This is the Gaussian fit implementation, see doi:10.1063/5.0004046.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mol<span class="classifier">MoleBase object</span></dt><dd><p>the molecule object for which the initial guess is evaluated</p>
</dd>
<dt>sap_basis<span class="classifier">dict</span></dt><dd><p>SAP basis in internal format (python dictionary)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>SAP initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.mulliken_meta">
<span class="sig-name descname"><span class="pre">mulliken_meta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.mulliken_meta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.mulliken_meta" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carried out within each subsets.</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or 2-item list of ndarray</span></dt><dd><p>Density matrix.  ROHF dm is a 2-item list of 2D array</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.mulliken_pop">
<span class="sig-name descname"><span class="pre">mulliken_pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.mulliken_pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.mulliken_pop" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.nuc_grad_method">
<span class="sig-name descname"><span class="pre">nuc_grad_method</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.nuc_grad_method"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.nuc_grad_method" title="Link to this definition">#</a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.spin_square">
<span class="sig-name descname"><span class="pre">spin_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.spin_square"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.spin_square" title="Link to this definition">#</a></dt>
<dd><p>Spin of the GHF wavefunction</p>
<div class="math notranslate nohighlight">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math notranslate nohighlight">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math notranslate nohighlight">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl>
<dt>There are two possibilities for <span class="math notranslate nohighlight">\(S_+ S_-\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron <span class="math notranslate nohighlight">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math notranslate nohighlight">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math notranslate nohighlight">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="math notranslate nohighlight">
\[\langle S_+ S_- \rangle
=\sum_{ij}(\langle i^\alpha|i^\beta\rangle \langle j^\beta|j^\alpha\rangle
- \langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle)\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Similarly, for <span class="math notranslate nohighlight">\(S_- S_+\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle S_- S_+ \rangle
=\sum_{ij}(\langle i^\beta|i^\alpha\rangle \langle j^\alpha|j^\beta\rangle
- \langle i^\beta|j^\alpha\rangle \langle j^\alpha|i^\beta\rangle)\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>For <span class="math notranslate nohighlight">\(S_z^2\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}&amp;\sum_{ij}(\langle ij|s_{z1}s_{z2}|ij\rangle
          -\langle ij|s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}\sum_{ij}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}\sum_{ij}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 - \langle i^\alpha|j^\alpha\rangle \langle j^\beta|i^\beta\rangle
 - \langle i^\beta|j^\beta\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}\sum_{ij}|\langle i^\alpha|i^\alpha\rangle - \langle i^\beta|i^\beta\rangle|^2
 -\frac{1}{4}\sum_{ij}|\langle i^\alpha|j^\alpha\rangle - \langle i^\beta|j^\beta\rangle|^2 \\
&amp;=\frac{1}{4}(n_\alpha - n_\beta)^2
 -\frac{1}{4}\sum_{ij}|\langle i^\alpha|j^\alpha\rangle - \langle i^\beta|j^\beta\rangle|^2\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo<span class="classifier">a list of 2 ndarrays</span></dt><dd><p>Occupied alpha and occupied beta orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>s<span class="classifier">ndarray</span></dt><dd><p>AO overlap</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.stability">
<span class="sig-name descname"><span class="pre">stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">internal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.stability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.stability" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.to_gpu">
<span class="sig-name descname"><span class="pre">to_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ghf.GHF.to_gpu" title="Link to this definition">#</a></dt>
<dd><p>Convert a method to its corresponding GPU variant, and recursively
converts all attributes of a method to cupy objects or gpu4pyscf objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.to_ks">
<span class="sig-name descname"><span class="pre">to_ks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.to_ks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.to_ks" title="Link to this definition">#</a></dt>
<dd><p>Convert to GKS object.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.with_soc">
<span class="sig-name descname"><span class="pre">with_soc</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.ghf.GHF.with_soc" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.x2c">
<span class="sig-name descname"><span class="pre">x2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ghf.GHF.x2c" title="Link to this definition">#</a></dt>
<dd><p>X2C with spin-orbit coupling effects.</p>
<p>Starting from PySCF 2.1, this function (mol.GHF().x2c()) produces an X2C
calculation in spherical GTO bases. The results in theory are equivalent
to those obtained from the mol.X2C() method, which is computed in the
spinor GTO bases. This function called the spin-free X2C1E method in the
older versions.</p>
<p>Please note the difference from other SCF methods, such as RHF and UHF.
In those methods, the .x2c() method produces a scalar relativistic
calculation using the X2C Hamiltonian.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.GHF.x2c1e">
<span class="sig-name descname"><span class="pre">x2c1e</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#GHF.x2c1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.GHF.x2c1e" title="Link to this definition">#</a></dt>
<dd><p>X2C with spin-orbit coupling effects.</p>
<p>Starting from PySCF 2.1, this function (mol.GHF().x2c()) produces an X2C
calculation in spherical GTO bases. The results in theory are equivalent
to those obtained from the mol.X2C() method, which is computed in the
spinor GTO bases. This function called the spin-free X2C1E method in the
older versions.</p>
<p>Please note the difference from other SCF methods, such as RHF and UHF.
In those methods, the .x2c() method produces a scalar relativistic
calculation using the X2C Hamiltonian.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.ghf.HF1e">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf.</span></span><span class="sig-name descname"><span class="pre">HF1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#HF1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.HF1e" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.ghf.GHF" title="pyscf.scf.ghf.GHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">GHF</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf.HF1e.scf">
<span class="sig-name descname"><span class="pre">scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ghf.HF1e.scf" title="Link to this definition">#</a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ghf.analyze">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf.</span></span><span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Dipole moment</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ghf.det_ovlp">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf.</span></span><span class="sig-name descname"><span class="pre">det_ovlp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ovlp</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#det_ovlp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.det_ovlp" title="Link to this definition">#</a></dt>
<dd><p>Calculate the overlap between two different determinants. It is the product
of single values of molecular orbital overlap matrix.</p>
<dl class="simple">
<dt>Return:</dt><dd><dl class="simple">
<dt>A list:</dt><dd><p>the product of single values: float
x_a: <span class="math notranslate nohighlight">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>
They are used to calculate asymmetric density matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ghf.dip_moment">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf.</span></span><span class="sig-name descname"><span class="pre">dip_moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit_symbol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Debye'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#dip_moment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.dip_moment" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ghf.get_jk">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf.</span></span><span class="sig-name descname"><span class="pre">get_jk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_j=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_k=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jkbuild=&lt;function</span> <span class="pre">get_jk&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega=None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#get_jk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.get_jk" title="Link to this definition">#</a></dt>
<dd><p>Compute J, K matrices for all input density matrices</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : not hermitian and not symmetric</div>
<div class="line">1 : hermitian or symmetric</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
<dt>with_j<span class="classifier">boolean</span></dt><dd><p>Whether to compute J matrices</p>
</dd>
<dt>with_k<span class="classifier">boolean</span></dt><dd><p>Whether to compute K matrices</p>
</dd>
<dt>omega<span class="classifier">float</span></dt><dd><p>Parameter of range-separated Coulomb operator: erf( omega * r12 ) / r12.
If specified, integration are evaluated based on the long-range
part of the range-separated Coulomb operator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="kn">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ghf.get_occ">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf.</span></span><span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#get_occ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.get_occ" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ghf.guess_orbspin">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf.</span></span><span class="sig-name descname"><span class="pre">guess_orbspin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#guess_orbspin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.guess_orbspin" title="Link to this definition">#</a></dt>
<dd><p>Guess the orbital spin (alpha 0, beta 1, unknown -1) based on the
orbital coefficients</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ghf.init_guess_by_chkfile">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_chkfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chkfile_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#init_guess_by_chkfile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.init_guess_by_chkfile" title="Link to this definition">#</a></dt>
<dd><p>Read SCF chkfile and make the density matrix for GHF initial guess.</p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ghf.mulliken_meta">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf.</span></span><span class="sig-name descname"><span class="pre">mulliken_meta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#mulliken_meta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.mulliken_meta" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ghf.mulliken_pop">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf.</span></span><span class="sig-name descname"><span class="pre">mulliken_pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#mulliken_pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.mulliken_pop" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ghf.spin_square">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf.</span></span><span class="sig-name descname"><span class="pre">spin_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf.html#spin_square"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf.spin_square" title="Link to this definition">#</a></dt>
<dd><p>Spin of the GHF wavefunction</p>
<div class="math notranslate nohighlight">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math notranslate nohighlight">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math notranslate nohighlight">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl>
<dt>There are two possibilities for <span class="math notranslate nohighlight">\(S_+ S_-\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron <span class="math notranslate nohighlight">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math notranslate nohighlight">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math notranslate nohighlight">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="math notranslate nohighlight">
\[\langle S_+ S_- \rangle
=\sum_{ij}(\langle i^\alpha|i^\beta\rangle \langle j^\beta|j^\alpha\rangle
- \langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle)\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Similarly, for <span class="math notranslate nohighlight">\(S_- S_+\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle S_- S_+ \rangle
=\sum_{ij}(\langle i^\beta|i^\alpha\rangle \langle j^\alpha|j^\beta\rangle
- \langle i^\beta|j^\alpha\rangle \langle j^\alpha|i^\beta\rangle)\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>For <span class="math notranslate nohighlight">\(S_z^2\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}&amp;\sum_{ij}(\langle ij|s_{z1}s_{z2}|ij\rangle
          -\langle ij|s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}\sum_{ij}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}\sum_{ij}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 - \langle i^\alpha|j^\alpha\rangle \langle j^\beta|i^\beta\rangle
 - \langle i^\beta|j^\beta\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}\sum_{ij}|\langle i^\alpha|i^\alpha\rangle - \langle i^\beta|i^\beta\rangle|^2
 -\frac{1}{4}\sum_{ij}|\langle i^\alpha|j^\alpha\rangle - \langle i^\beta|j^\beta\rangle|^2 \\
&amp;=\frac{1}{4}(n_\alpha - n_\beta)^2
 -\frac{1}{4}\sum_{ij}|\langle i^\alpha|j^\alpha\rangle - \langle i^\beta|j^\beta\rangle|^2\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo<span class="classifier">a list of 2 ndarrays</span></dt><dd><p>Occupied alpha and occupied beta orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>s<span class="classifier">ndarray</span></dt><dd><p>AO overlap</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-pyscf.scf.ghf_symm">
<span id="pyscf-scf-ghf-symm-module"></span><h2>pyscf.scf.ghf_symm module<a class="headerlink" href="#module-pyscf.scf.ghf_symm" title="Link to this heading">#</a></h2>
<p>Non-relativistic generalized Hartree-Fock with point group symmetry.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.GHF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf_symm.</span></span><span class="sig-name descname"><span class="pre">GHF</span></span><a class="headerlink" href="#pyscf.scf.ghf_symm.GHF" title="Link to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.ghf_symm.SymAdaptedGHF" title="pyscf.scf.ghf_symm.SymAdaptedGHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymAdaptedGHF</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.HF1e">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf_symm.</span></span><span class="sig-name descname"><span class="pre">HF1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf_symm.html#HF1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf_symm.HF1e" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.ghf_symm.SymAdaptedGHF" title="pyscf.scf.ghf_symm.SymAdaptedGHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymAdaptedGHF</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.HF1e.scf">
<span class="sig-name descname"><span class="pre">scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ghf_symm.HF1e.scf" title="Link to this definition">#</a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.SymAdaptedGHF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf_symm.</span></span><span class="sig-name descname"><span class="pre">SymAdaptedGHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf_symm.html#SymAdaptedGHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf_symm.SymAdaptedGHF" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.ghf.GHF" title="pyscf.scf.ghf.GHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">GHF</span></code></a></p>
<p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="simple">
<dt>Attributes for GHF method</dt><dd><p>GHF orbital coefficients are 2D array.  Let nao be the number of spatial
AOs, mo_coeff[:nao] are the coefficients of AO with alpha spin;
mo_coeff[nao:nao*2] are the coefficients of AO with beta spin.</p>
</dd>
<dt>Attributes for symmetry allowed GHF:</dt><dd><dl class="simple">
<dt>irrep_nelec<span class="classifier">dict</span></dt><dd><p>Specify the number of electrons for particular irrep
{‘ir_name’:int, …}.
For the irreps not listed in these dicts, the program will choose the
occupancy based on the orbital energies.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.SymAdaptedGHF.analyze">
<span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf_symm.html#SymAdaptedGHF.analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.SymAdaptedGHF.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf_symm.html#SymAdaptedGHF.build"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.build" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.SymAdaptedGHF.canonicalize">
<span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.canonicalize" title="Link to this definition">#</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix in occupied, virtual
subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.SymAdaptedGHF.dump_flags">
<span class="sig-name descname"><span class="pre">dump_flags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf_symm.html#SymAdaptedGHF.dump_flags"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.dump_flags" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.SymAdaptedGHF.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symm_orb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irrep_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf_symm.html#SymAdaptedGHF.eig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.eig" title="Link to this definition">#</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.SymAdaptedGHF.get_grad">
<span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf_symm.html#SymAdaptedGHF.get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.get_grad" title="Link to this definition">#</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Orbital occupancy</p>
</dd>
<dt>fock_ao<span class="classifier">2D ndarray</span></dt><dd><p>Fock matrix in AO representation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.SymAdaptedGHF.get_irrep_nelec">
<span class="sig-name descname"><span class="pre">get_irrep_nelec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf_symm.html#SymAdaptedGHF.get_irrep_nelec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.get_irrep_nelec" title="Link to this definition">#</a></dt>
<dd><p>Electron numbers for each irreducible representation.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>mol<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></span></dt><dd><p>To provide irrep_id, and spin-adapted basis</p>
</dd>
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Regular orbital coefficients, without grouping for irreps</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Regular occupancy, without grouping for irreps</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>irrep_nelec<span class="classifier">dict</span></dt><dd><p>The number of electrons for each irrep {‘ir_name’:int,…}.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-76.016789472074251</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf_symm</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">)</span>
<span class="go">{&#39;A1&#39;: 6, &#39;A2&#39;: 0, &#39;B1&#39;: 2, &#39;B2&#39;: 2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.SymAdaptedGHF.get_occ">
<span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf_symm.html#SymAdaptedGHF.get_occ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.get_occ" title="Link to this definition">#</a></dt>
<dd><p>We assumed mo_energy are grouped by symmetry irreps, (see function
self.eig). The orbitals are sorted after SCF.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.SymAdaptedGHF.get_orbsym">
<span class="sig-name descname"><span class="pre">get_orbsym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf_symm.html#SymAdaptedGHF.get_orbsym"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.get_orbsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.SymAdaptedGHF.orbsym">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">orbsym</span></span><a class="headerlink" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.orbsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.SymAdaptedGHF.to_gpu">
<span class="sig-name descname"><span class="pre">to_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.to_gpu" title="Link to this definition">#</a></dt>
<dd><p>Convert a method to its corresponding GPU variant, and recursively
converts all attributes of a method to cupy objects or gpu4pyscf objects.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.analyze">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf_symm.</span></span><span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf_symm.html#analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf_symm.analyze" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.canonicalize">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf_symm.</span></span><span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf_symm.html#canonicalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf_symm.canonicalize" title="Link to this definition">#</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix in occupied, virtual
subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ghf_symm.get_orbsym">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ghf_symm.</span></span><span class="sig-name descname"><span class="pre">get_orbsym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symm_orb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irrep_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ghf_symm.html#get_orbsym"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ghf_symm.get_orbsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="module-pyscf.scf.hf">
<span id="pyscf-scf-hf-module"></span><h2>pyscf.scf.hf module<a class="headerlink" href="#module-pyscf.scf.hf" title="Link to this heading">#</a></h2>
<p>Hartree-Fock</p>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.Kgwh">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">Kgwh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ei</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ej</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">updated_rule</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#Kgwh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.Kgwh" title="Link to this definition">#</a></dt>
<dd><p>Computes the generalized Wolfsberg-Helmholtz parameter</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">RHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#RHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.RHF" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.hf.SCF" title="pyscf.scf.hf.SCF"><code class="xref py py-class docutils literal notranslate"><span class="pre">SCF</span></code></a></p>
<p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.CASCI">
<span class="sig-name descname"><span class="pre">CASCI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.CASCI" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.CASSCF">
<span class="sig-name descname"><span class="pre">CASSCF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.CASSCF" title="Link to this definition">#</a></dt>
<dd><p>CASCI/CASSCF</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>mf_or_mol<span class="classifier">SCF object or Mole object</span></dt><dd><p>SCF or Mole to define the problem size.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Number of active orbitals.</p>
</dd>
<dt>nelecas<span class="classifier">int or a pair of int</span></dt><dd><p>Number of electrons in active space.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>ncore<span class="classifier">int</span></dt><dd><p>Number of doubly occupied core orbitals. If not presented, this
parameter can be automatically determined.</p>
</dd>
</dl>
</dd>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code>.</p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code>.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Active space size.</p>
</dd>
<dt>nelecas<span class="classifier">tuple of int</span></dt><dd><p>Active (nelec_alpha, nelec_beta)</p>
</dd>
<dt>ncore<span class="classifier">int or tuple of int</span></dt><dd><p>Core electron number.  In UHF-CASSCF, it’s a tuple to indicate the different core electron numbers.</p>
</dd>
<dt>natorb<span class="classifier">bool</span></dt><dd><p>Whether to transform natural orbitals in active space.
Note: when CASCI/CASSCF are combined with DMRG solver or selected
CI solver, enabling this parameter may slightly change the total energy.
False by default.</p>
</dd>
<dt>canonicalization<span class="classifier">bool</span></dt><dd><p>Whether to canonicalize orbitals in core and external space
against the general Fock matrix.
The orbitals in active space are NOT transformed by default. To
get the natural orbitals in active space, the attribute .natorb
needs to be enabled.
True by default.</p>
</dd>
<dt>sorting_mo_energy<span class="classifier">bool</span></dt><dd><p>Whether to sort the orbitals based on the diagonal elements of the
general Fock matrix.  Default is False.</p>
</dd>
<dt>fcisolver<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">FCISolver</span></code></span></dt><dd><p>The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal notranslate"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p>For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>e_cas<span class="classifier">float</span></dt><dd><p>CAS space FCI energy</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>When canonicalization is specified, the orbitals are canonical
orbitals which make the general Fock matrix (Fock operator on top
of MCSCF 1-particle density matrix) diagonalized within each
subspace (core, active, external).  If natorb (natural orbitals in
active space) is specified, the active segment of the mo_coeff is
natural orbitals.</p>
</dd>
<dt>mo_energy<span class="classifier">ndarray</span></dt><dd><p>Diagonal elements of general Fock matrix (in mo_coeff
representation).</p>
</dd>
<dt>mo_occ<span class="classifier">ndarray</span></dt><dd><p>Occupation numbers of natural orbitals if natorb is specified.</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
</pre></div>
</div>
<p>Extra attributes for CASSCF:</p>
<blockquote>
<div><dl>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Converge threshold.  Default is 1e-7</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>Converge threshold for CI gradients and orbital rotation gradients.
If not specified, it is set to sqrt(conv_tol).</p>
</dd>
<dt>max_stepsize<span class="classifier">float</span></dt><dd><p>The step size for orbital rotation.  Small step (0.005 - 0.05) is prefered.
Default is 0.02.</p>
</dd>
<dt>max_cycle_macro<span class="classifier">int</span></dt><dd><p>Max number of macro iterations.  Default is 50.</p>
</dd>
<dt>max_cycle_micro<span class="classifier">int</span></dt><dd><p>Max number of micro iterations in each macro iteration.  Depending on
systems, increasing this value might reduce the total macro
iterations.  Generally, 2 - 5 steps should be enough.  Default is 4.</p>
</dd>
<dt>small_rot_tol<span class="classifier">float</span></dt><dd><p>Threshold for orbital rotation to be considered small. If the largest orbital
rotation is smaller than this value, the CI solver will restart from the
previous iteration if supported.
Default is 0.01</p>
</dd>
<dt>ah_level_shift<span class="classifier">float, for AH solver.</span></dt><dd><p>Level shift for the Davidson diagonalization in AH solver.  Default is 1e-8.</p>
</dd>
<dt>ah_conv_tol<span class="classifier">float, for AH solver.</span></dt><dd><p>converge threshold for AH solver.  Default is 1e-12.</p>
</dd>
<dt>ah_max_cycle<span class="classifier">float, for AH solver.</span></dt><dd><p>Max number of iterations allowd in AH solver.  Default is 30.</p>
</dd>
<dt>ah_lindep<span class="classifier">float, for AH solver.</span></dt><dd><p>Linear dependence threshold for AH solver.  Default is 1e-14.</p>
</dd>
<dt>ah_start_tol<span class="classifier">flat, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 2.5.</p>
</dd>
<dt>ah_start_cycle<span class="classifier">int, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 3.</p>
<p><code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_max_cycle</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_start_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_start_cycle</span></code>
can affect the accuracy and performance of CASSCF solver.  Lower
<code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code> might improve the accuracy of CASSCF
optimization, but decrease the performance.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401898486001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401887945668</span>
</pre></div>
</div>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>Checkpoint file to save the intermediate orbitals during the CASSCF optimization.
Default is the checkpoint file of mean field object.</p>
</dd>
<dt>ci_response_space<span class="classifier">int</span></dt><dd><p>subspace size to solve the CI vector response.  Default is 3.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>scale_restoration<span class="classifier">float</span></dt><dd><p>When a step of orbital rotation moves out of trust region, the
orbital optimization will be restored to previous state and the
step size of the orbital rotation needs to be reduced.
scale_restoration controls how much to scale down the step size.</p>
</dd>
</dl>
</div></blockquote>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>e_cas<span class="classifier">float</span></dt><dd><p>CAS space FCI energy</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>Optimized CASSCF orbitals coefficients. When canonicalization is
specified, the returned orbitals make the general Fock matrix
(Fock operator on top of MCSCF 1-particle density matrix)
diagonalized within each subspace (core, active, external). If
natorb (natural orbitals in active space) is enabled, the active
segment of mo_coeff is transformed to natural orbitals.</p>
</dd>
<dt>mo_energy<span class="classifier">ndarray</span></dt><dd><p>Diagonal elements of general Fock matrix (in mo_coeff
representation).</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401882238134</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.CISD">
<span class="sig-name descname"><span class="pre">CISD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.CISD" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.DFMP2">
<span class="sig-name descname"><span class="pre">DFMP2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.DFMP2" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.Gradients">
<span class="sig-name descname"><span class="pre">Gradients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.Gradients" title="Link to this definition">#</a></dt>
<dd><p>Non-relativistic restricted Hartree-Fock gradients</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.MP2">
<span class="sig-name descname"><span class="pre">MP2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.MP2" title="Link to this definition">#</a></dt>
<dd><p>restricted MP2 with canonical HF and non-canonical HF reference</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>For non-canonical MP2, converge threshold for MP2
correlation energy.  Default value is 1e-7.</p>
</dd>
<dt>conv_tol_normt<span class="classifier">float</span></dt><dd><p>For non-canonical MP2, converge threshold for
norm(t2).  Default value is 1e-5.</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>For non-canonical MP2, max number of MP2
iterations.  Default value is 50.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>For non-canonical MP2, DIIS space size in MP2
iterations.  Default is 6.</p>
</dd>
<dt>level_shift<span class="classifier">float</span></dt><dd><p>A shift on virtual orbital energies to stabilize the MP2 iterations.</p>
</dd>
<dt>frozen<span class="classifier">int or list</span></dt><dd><p>If integer is given, the inner-most orbitals are excluded from MP2
amplitudes.  Given the orbital indices (0-based) in a list, both
occupied and virtual orbitals can be frozen in MP2 calculation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pt</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">MP2</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># auto-generate the number of core orbitals to be frozen (1 in this case)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pt</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">MP2</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set_frozen</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals and 3 high lying unoccupied orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pt</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_corr<span class="classifier">float</span></dt><dd><p>MP2 correlation correction</p>
</dd>
<dt>e_corr_ss/os<span class="classifier">float</span></dt><dd><p>Same-spin and opposite-spin component of the MP2 correlation energy</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MP2 energy (HF + correlation)</p>
</dd>
<dt>t2 :</dt><dd><p>T amplitudes t2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.TDA">
<span class="sig-name descname"><span class="pre">TDA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.TDA" title="Link to this definition">#</a></dt>
<dd><p>Tamm-Dancoff approximation</p>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Diagonalization convergence tolerance.  Default is 1e-9.</p>
</dd>
<dt>nstates<span class="classifier">int</span></dt><dd><p>Number of TD states to be computed. Default is 3.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Diagonalization converged or not</p>
</dd>
<dt>e<span class="classifier">1D array</span></dt><dd><p>excitation energy for each excited state.</p>
</dd>
<dt>xy<span class="classifier">A list of two 2D arrays</span></dt><dd><p>The two 2D arrays are Excitation coefficients X (shape [nocc,nvir])
and de-excitation coefficients Y (shape [nocc,nvir]) for each
excited state.  (X,Y) are normalized to 1/2 in RHF/RKS methods and
normalized to 1 for UHF/UKS methods. In the TDA calculation, Y = 0.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.TDHF">
<span class="sig-name descname"><span class="pre">TDHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.TDHF" title="Link to this definition">#</a></dt>
<dd><p>Time-dependent Hartree-Fock</p>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Diagonalization convergence tolerance.  Default is 1e-4.</p>
</dd>
<dt>nstates<span class="classifier">int</span></dt><dd><p>Number of TD states to be computed. Default is 3.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Diagonalization converged or not</p>
</dd>
<dt>e<span class="classifier">1D array</span></dt><dd><p>excitation energy for each excited state.</p>
</dd>
<dt>xy<span class="classifier">A list of two 2D arrays</span></dt><dd><p>The two 2D arrays are Excitation coefficients X (shape [nocc,nvir])
and de-excitation coefficients Y (shape [nocc,nvir]) for each
excited state.  (X,Y) are normalized to 1/2 in RHF/RKS methods and
normalized to 1 for UHF/UKS methods. In the TDA calculation, Y = 0.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.check_sanity">
<span class="sig-name descname"><span class="pre">check_sanity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#RHF.check_sanity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.check_sanity" title="Link to this definition">#</a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.convert_from_">
<span class="sig-name descname"><span class="pre">convert_from_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#RHF.convert_from_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.convert_from_" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to RHF/ROHF</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.gen_response">
<span class="sig-name descname"><span class="pre">gen_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">singlet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.gen_response" title="Link to this definition">#</a></dt>
<dd><p>Generate a function to compute the product of RHF response function and
RHF density matrices.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>singlet (None or boolean)<span class="classifier">If singlet is None, response function for</span></dt><dd><p>orbital hessian or CPHF will be generated. If singlet is boolean,
it is used in TDDFT response kernel.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.get_init_guess">
<span class="sig-name descname"><span class="pre">get_init_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'minao'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#RHF.get_init_guess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.get_init_guess" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.get_jk">
<span class="sig-name descname"><span class="pre">get_jk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_j</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#RHF.get_jk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.get_jk" title="Link to this definition">#</a></dt>
<dd><p>Compute J, K matrices for all input density matrices</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : not hermitian and not symmetric</div>
<div class="line">1 : hermitian or symmetric</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
<dt>with_j<span class="classifier">boolean</span></dt><dd><p>Whether to compute J matrices</p>
</dd>
<dt>with_k<span class="classifier">boolean</span></dt><dd><p>Whether to compute K matrices</p>
</dd>
<dt>omega<span class="classifier">float</span></dt><dd><p>Parameter of range-separated Coulomb operator: erf( omega * r12 ) / r12.
If specified, integration are evaluated based on the long-range
part of the range-separated Coulomb operator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="kn">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.get_veff">
<span class="sig-name descname"><span class="pre">get_veff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#RHF.get_veff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.get_veff" title="Link to this definition">#</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>dm_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</p>
</dd>
<dt>vhf_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The reference HF potential matrix.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>matrix Vhf = 2*J - K.  Vhf can be a list matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="kn">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf0</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">dm_last</span><span class="o">=</span><span class="n">dm0</span><span class="p">,</span> <span class="n">vhf_last</span><span class="o">=</span><span class="n">vhf0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vhf1</span><span class="p">,</span> <span class="n">vhf2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.nuc_grad_method">
<span class="sig-name descname"><span class="pre">nuc_grad_method</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#RHF.nuc_grad_method"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.nuc_grad_method" title="Link to this definition">#</a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.spin_square">
<span class="sig-name descname"><span class="pre">spin_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#RHF.spin_square"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.spin_square" title="Link to this definition">#</a></dt>
<dd><p>Spin square and multiplicity of RHF determinant</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.stability">
<span class="sig-name descname"><span class="pre">stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">internal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#RHF.stability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.stability" title="Link to this definition">#</a></dt>
<dd><p>RHF/RKS stability analysis.</p>
<p>See also pyscf.scf.stability.rhf_stability function.</p>
<dl>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the RHF optimization space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. Including the RHF -&gt; UHF and real -&gt; complex
stability analysis.</p>
</dd>
<dt>return_status: bool</dt><dd><p>Whether to return <cite>stable_i</cite> and <cite>stable_e</cite></p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>If return_status is False (default), the return value includes
two set of orbitals, which are more close to the stable condition.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
<p>Else, another two boolean variables (indicating current status:
stable or unstable) are returned.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.to_gpu">
<span class="sig-name descname"><span class="pre">to_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.RHF.to_gpu" title="Link to this definition">#</a></dt>
<dd><p>Convert a method to its corresponding GPU variant, and recursively
converts all attributes of a method to cupy objects or gpu4pyscf objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.RHF.to_ks">
<span class="sig-name descname"><span class="pre">to_ks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#RHF.to_ks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.RHF.to_ks" title="Link to this definition">#</a></dt>
<dd><p>Convert to RKS object.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">SCF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyscf.lib.html#pyscf.lib.misc.StreamObject" title="pyscf.lib.misc.StreamObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamObject</span></code></a></p>
<p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.CCSD">
<span class="sig-name descname"><span class="pre">CCSD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frozen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.CCSD" title="Link to this definition">#</a></dt>
<dd><p>restricted CCSD</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-7.</p>
</dd>
<dt>conv_tol_normt<span class="classifier">float</span></dt><dd><p>converge threshold for norm(t1,t2).  Default is 1e-5.</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  Default is 50.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  Default is 6.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 0.</p>
</dd>
<dt>iterative_damping<span class="classifier">float</span></dt><dd><p>The self consistent damping parameter.</p>
</dd>
<dt>direct<span class="classifier">bool</span></dt><dd><p>AO-direct CCSD. Default is False.</p>
</dd>
<dt>async_io<span class="classifier">bool</span></dt><dd><p>Allow for asynchronous function execution. Default is True.</p>
</dd>
<dt>incore_complete<span class="classifier">bool</span></dt><dd><p>Avoid all I/O (also for DIIS). Default is False.</p>
</dd>
<dt>level_shift<span class="classifier">float</span></dt><dd><p>A shift on virtual orbital energies to stabilize the CCSD iteration</p>
</dd>
<dt>frozen<span class="classifier">int or list</span></dt><dd><p>If integer is given, the inner-most orbitals are frozen from CC
amplitudes.  Given the orbital indices (0-based) in a list, both
occupied and virtual orbitals can be frozen in CC calculation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># auto-generate the number of core orbitals to be frozen (1 in this case)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set_frozen</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals and 3 high lying unoccupied orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the CCSD iteration converged</p>
</dd>
<dt>e_corr<span class="classifier">float</span></dt><dd><p>CCSD correlation correction</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total CCSD energy (HF + correlation)</p>
</dd>
<dt>t1, t2 :</dt><dd><p>T amplitudes t1[i,a], t2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
<dt>l1, l2 :</dt><dd><p>Lambda amplitudes l1[i,a], l2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.DIIS">
<span class="sig-name descname"><span class="pre">DIIS</span></span><a class="headerlink" href="#pyscf.scf.hf.SCF.DIIS" title="Link to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.diis.CDIIS" title="pyscf.scf.diis.CDIIS"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDIIS</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.QCISD">
<span class="sig-name descname"><span class="pre">QCISD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frozen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.QCISD" title="Link to this definition">#</a></dt>
<dd><p>restricted QCISD</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.QMMM">
<span class="sig-name descname"><span class="pre">QMMM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms_or_coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">charges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radii</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.QMMM" title="Link to this definition">#</a></dt>
<dd><p>Embedding the one-electron (non-relativistic) potential generated by MM
point charges into QM Hamiltonian.</p>
<p>The total energy includes the regular QM energy, the interaction between
the nuclei in QM region and the MM charges, and the static Coulomb
interaction between the electron density and the MM charges. It does not
include the static Coulomb interactions of the MM point charges, the MM
energy, the vdw interaction or other bonding/non-bonding effects between
QM region and MM particles.</p>
<dl>
<dt>Args:</dt><dd><p>scf_method : a HF or DFT object</p>
<dl class="simple">
<dt>atoms_or_coords<span class="classifier">2D array, shape (N,3)</span></dt><dd><p>MM particle coordinates</p>
</dd>
<dt>charges<span class="classifier">1D array</span></dt><dd><p>MM particle charges</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>radii<span class="classifier">1D array</span></dt><dd><p>The Gaussian charge distribution radii of MM atoms.</p>
</dd>
<dt>unit<span class="classifier">str</span></dt><dd><p>Bohr, AU, Ang (case insensitive). Default is the same to mol.unit</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Same method object as the input scf_method with modified 1e Hamiltonian</p>
</dd>
<dt>Note:</dt><dd><p>1. if MM charge and X2C correction are used together, function mm_charge
needs to be applied after X2C decoration (.x2c method), eg
mf = mm_charge(scf.RHF(mol).x2c()), [(0.5,0.6,0.8)], [-0.5]).
2. Once mm_charge function is applied on the SCF object, it
affects all the post-HF calculations eg MP2, CCSD, MCSCF etc</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">mm_charge</span><span class="p">(</span><span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">mol</span><span class="p">),</span> <span class="p">[(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.6</span><span class="p">,</span><span class="mf">0.8</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-101.940495711284</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.analyze">
<span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.apply" title="Link to this definition">#</a></dt>
<dd><p>Apply the fn to rest arguments:  return fn(<a href="#id1"><span class="problematic" id="id2">*</span></a>args, <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs).  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.as_scanner">
<span class="sig-name descname"><span class="pre">as_scanner</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.as_scanner" title="Link to this definition">#</a></dt>
<dd><p>Generating a scanner/solver for HF PES.</p>
<p>The returned solver is a function. This function requires one argument
“mol” as input and returns total HF energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
SCF object (DIIS, conv_tol, max_memory etc) are automatically applied in
the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, …) during calculation.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">))</span>
<span class="go">-98.552190448277955</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.5&#39;</span><span class="p">))</span>
<span class="go">-98.414750424294368</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.build"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.build" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.callback">
<span class="sig-name descname"><span class="pre">callback</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.callback" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.canonicalize">
<span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.canonicalize" title="Link to this definition">#</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix within occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.check_convergence">
<span class="sig-name descname"><span class="pre">check_convergence</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.check_convergence" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.check_sanity">
<span class="sig-name descname"><span class="pre">check_sanity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.check_sanity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.check_sanity" title="Link to this definition">#</a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.conv_check">
<span class="sig-name descname"><span class="pre">conv_check</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.conv_check" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.conv_tol">
<span class="sig-name descname"><span class="pre">conv_tol</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-09</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.conv_tol" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.conv_tol_cpscf">
<span class="sig-name descname"><span class="pre">conv_tol_cpscf</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-08</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.conv_tol_cpscf" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.conv_tol_grad">
<span class="sig-name descname"><span class="pre">conv_tol_grad</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.conv_tol_grad" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.convert_from_">
<span class="sig-name descname"><span class="pre">convert_from_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.convert_from_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.convert_from_" title="Link to this definition">#</a></dt>
<dd><p>Convert the abinput mean-field object to the associated KS object.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.damp">
<span class="sig-name descname"><span class="pre">damp</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.damp" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.density_fit">
<span class="sig-name descname"><span class="pre">density_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">auxbasis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">only_dfj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.density_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.density_fit" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.diis">
<span class="sig-name descname"><span class="pre">diis</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.diis" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.diis_damp">
<span class="sig-name descname"><span class="pre">diis_damp</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.diis_damp" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.diis_file">
<span class="sig-name descname"><span class="pre">diis_file</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.diis_file" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.diis_space">
<span class="sig-name descname"><span class="pre">diis_space</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">8</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.diis_space" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.diis_space_rollback">
<span class="sig-name descname"><span class="pre">diis_space_rollback</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.diis_space_rollback" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.diis_start_cycle">
<span class="sig-name descname"><span class="pre">diis_start_cycle</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.diis_start_cycle" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.dip_moment">
<span class="sig-name descname"><span class="pre">dip_moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Debye'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.dip_moment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.dip_moment" title="Link to this definition">#</a></dt>
<dd><p>Dipole moment calculation</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mu_x = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|x|\mu) + \sum_A Q_A X_A\\
\mu_y = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|y|\mu) + \sum_A Q_A Y_A\\
\mu_z = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|z|\mu) + \sum_A Q_A Z_A\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu_x, \mu_y, \mu_z\)</span> are the x, y and z components of dipole
moment</p>
<dl>
<dt>Args:</dt><dd><p>mol: an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code>
dm : a 2D ndarrays density matrices
origin : optional; length 3 list, tuple, or 1D array</p>
<blockquote>
<div><p>Location of the origin. By default, the point (0, 0, 0) is used.</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z component</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.direct_scf">
<span class="sig-name descname"><span class="pre">direct_scf</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.direct_scf" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.direct_scf_tol">
<span class="sig-name descname"><span class="pre">direct_scf_tol</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-13</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.direct_scf_tol" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.disp">
<span class="sig-name descname"><span class="pre">disp</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.disp" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.do_disp">
<span class="sig-name descname"><span class="pre">do_disp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.do_disp" title="Link to this definition">#</a></dt>
<dd><p>Check whether to apply dispersion correction based on the xc attribute.
If dispersion is allowed, return the DFTD3 disp version, such as d3bj,
d3zero, d4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.dump_chk">
<span class="sig-name descname"><span class="pre">dump_chk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs_or_file</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.dump_chk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.dump_chk" title="Link to this definition">#</a></dt>
<dd><p>Serialize the SCF object and save it to the specified chkfile.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>envs_or_file:</dt><dd><p>If this argument is a file path, the serialized SCF object is
saved to the file specified by this argument.
If this attribute is a dict (created by locals()), the necessary
variables are saved to the file specified by the attribute mf.chkfile.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.dump_flags">
<span class="sig-name descname"><span class="pre">dump_flags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.dump_flags"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.dump_flags" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.dump_scf_summary">
<span class="sig-name descname"><span class="pre">dump_scf_summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.dump_scf_summary" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.eig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.eig" title="Link to this definition">#</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.energy_elec">
<span class="sig-name descname"><span class="pre">energy_elec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.energy_elec" title="Link to this definition">#</a></dt>
<dd><p>Electronic part of Hartree-Fock energy, for given core hamiltonian and
HF potential</p>
<p>… math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> \<span class="n">sum_</span><span class="p">{</span><span class="n">ij</span><span class="p">}</span><span class="n">h_</span><span class="p">{</span><span class="n">ij</span><span class="p">}</span> \<span class="n">gamma_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span>
  <span class="o">+</span> \<span class="n">frac</span><span class="p">{</span><span class="mi">1</span><span class="p">}{</span><span class="mi">2</span><span class="p">}</span>\<span class="n">sum_</span><span class="p">{</span><span class="n">ijkl</span><span class="p">}</span> \<span class="n">gamma_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span>\<span class="n">gamma_</span><span class="p">{</span><span class="n">lk</span><span class="p">}</span> \<span class="n">langle</span> <span class="n">ik</span><span class="o">||</span><span class="n">jl</span>\<span class="n">rangle</span>
</pre></div>
</div>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mf : an instance of SCF class</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm<span class="classifier">2D ndarray</span></dt><dd><p>one-particle density matrix</p>
</dd>
<dt>h1e<span class="classifier">2D ndarray</span></dt><dd><p>Core hamiltonian</p>
</dd>
<dt>vhf<span class="classifier">2D ndarray</span></dt><dd><p>HF potential</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Hartree-Fock electronic energy and the Coulomb energy</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.energy_nuc">
<span class="sig-name descname"><span class="pre">energy_nuc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.energy_nuc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.energy_nuc" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.energy_tot">
<span class="sig-name descname"><span class="pre">energy_tot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.energy_tot" title="Link to this definition">#</a></dt>
<dd><p>Total Hartree-Fock energy, electronic part plus nuclear repulsion
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.energy_elec()</span></code> for the electron part</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.from_chk">
<span class="sig-name descname"><span class="pre">from_chk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.from_chk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.from_chk" title="Link to this definition">#</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.get_dispersion">
<span class="sig-name descname"><span class="pre">get_dispersion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_3body</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.get_dispersion" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.get_fock">
<span class="sig-name descname"><span class="pre">get_fock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis_start_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damp_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.get_fock" title="Link to this definition">#</a></dt>
<dd><p>F = h^{core} + V^{HF}</p>
<p>Special treatment (damping, DIIS, or level shift) will be applied to the
Fock matrix if diis and cycle is specified (The two parameters are passed
to get_fock function during the SCF iteration)</p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>h1e<span class="classifier">2D ndarray</span></dt><dd><p>Core hamiltonian</p>
</dd>
<dt>s1e<span class="classifier">2D ndarray</span></dt><dd><p>Overlap matrix, for DIIS</p>
</dd>
<dt>vhf<span class="classifier">2D ndarray</span></dt><dd><p>HF potential matrix</p>
</dd>
<dt>dm<span class="classifier">2D ndarray</span></dt><dd><p>Density matrix, for DIIS</p>
</dd>
<dt>cycle<span class="classifier">int</span></dt><dd><p>Then present SCF iteration step, for DIIS</p>
</dd>
<dt>diis<span class="classifier">an object of <a class="reference internal" href="#pyscf.scf.hf.SCF.DIIS" title="pyscf.scf.hf.SCF.DIIS"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SCF.DIIS</span></code></a> class</span></dt><dd><p>DIIS object to hold intermediate Fock and error vectors</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 0.</p>
</dd>
<dt>level_shift_factor<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.get_grad">
<span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.get_grad" title="Link to this definition">#</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Orbital occupancy</p>
</dd>
<dt>fock_ao<span class="classifier">2D ndarray</span></dt><dd><p>Fock matrix in AO representation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.get_hcore">
<span class="sig-name descname"><span class="pre">get_hcore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.get_hcore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.get_hcore" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.get_init_guess">
<span class="sig-name descname"><span class="pre">get_init_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'minao'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.get_init_guess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.get_init_guess" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.get_j">
<span class="sig-name descname"><span class="pre">get_j</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.get_j"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.get_j" title="Link to this definition">#</a></dt>
<dd><p>Compute J matrices for all input density matrices</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.get_jk">
<span class="sig-name descname"><span class="pre">get_jk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_j</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.get_jk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.get_jk" title="Link to this definition">#</a></dt>
<dd><p>Compute J, K matrices for all input density matrices</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : not hermitian and not symmetric</div>
<div class="line">1 : hermitian or symmetric</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
<dt>with_j<span class="classifier">boolean</span></dt><dd><p>Whether to compute J matrices</p>
</dd>
<dt>with_k<span class="classifier">boolean</span></dt><dd><p>Whether to compute K matrices</p>
</dd>
<dt>omega<span class="classifier">float</span></dt><dd><p>Parameter of range-separated Coulomb operator: erf( omega * r12 ) / r12.
If specified, integration are evaluated based on the long-range
part of the range-separated Coulomb operator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="kn">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.get_k">
<span class="sig-name descname"><span class="pre">get_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.get_k"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.get_k" title="Link to this definition">#</a></dt>
<dd><p>Compute K matrices for all input density matrices</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.get_occ">
<span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.get_occ" title="Link to this definition">#</a></dt>
<dd><p>Label the occupancies for each orbital</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">1D ndarray</span></dt><dd><p>Obital energies</p>
</dd>
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 0, 2, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.get_ovlp">
<span class="sig-name descname"><span class="pre">get_ovlp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.get_ovlp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.get_ovlp" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.get_veff">
<span class="sig-name descname"><span class="pre">get_veff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.get_veff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.get_veff" title="Link to this definition">#</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>dm_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</p>
</dd>
<dt>vhf_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The reference HF potential matrix.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>matrix Vhf = 2*J - K.  Vhf can be a list matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="kn">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf0</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">dm_last</span><span class="o">=</span><span class="n">dm0</span><span class="p">,</span> <span class="n">vhf_last</span><span class="o">=</span><span class="n">vhf0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vhf1</span><span class="p">,</span> <span class="n">vhf2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.init_direct_scf">
<span class="sig-name descname"><span class="pre">init_direct_scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.init_direct_scf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.init_direct_scf" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.init_guess">
<span class="sig-name descname"><span class="pre">init_guess</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'minao'</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.init_guess" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.init_guess_by_1e">
<span class="sig-name descname"><span class="pre">init_guess_by_1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.init_guess_by_1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.init_guess_by_1e" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.init_guess_by_atom">
<span class="sig-name descname"><span class="pre">init_guess_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.init_guess_by_atom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.init_guess_by_atom" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.init_guess_by_chkfile">
<span class="sig-name descname"><span class="pre">init_guess_by_chkfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.init_guess_by_chkfile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.init_guess_by_chkfile" title="Link to this definition">#</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.init_guess_by_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.init_guess_by_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.init_guess_by_huckel" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.init_guess_by_minao">
<span class="sig-name descname"><span class="pre">init_guess_by_minao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.init_guess_by_minao"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.init_guess_by_minao" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix based on ANO basis, then project
the density matrix to the basis set defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">init_guess_by_minao</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">array([[ 0.94758917,  0.09227308],</span>
<span class="go">       [ 0.09227308,  0.94758917]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.init_guess_by_mod_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_mod_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">updated_rule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.init_guess_by_mod_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.init_guess_by_mod_huckel" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<p>In contrast to init_guess_by_huckel, this routine employs the
updated GWH rule from doi:10.1021/ja00480a005 to form the guess.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.init_guess_by_sap">
<span class="sig-name descname"><span class="pre">init_guess_by_sap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.init_guess_by_sap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.init_guess_by_sap" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a superposition of
atomic potentials (SAP), doi:10.1021/acs.jctc.8b01089.
This is the Gaussian fit implementation, see doi:10.1063/5.0004046.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mol<span class="classifier">MoleBase object</span></dt><dd><p>the molecule object for which the initial guess is evaluated</p>
</dd>
<dt>sap_basis<span class="classifier">dict</span></dt><dd><p>SAP basis in internal format (python dictionary)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>SAP initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.istype">
<span class="sig-name descname"><span class="pre">istype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type_code</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.istype"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.istype" title="Link to this definition">#</a></dt>
<dd><p>Checks if the object is an instance of the class specified by the type_code.
type_code can be a class or a str. If the type_code is a class, it is
equivalent to the Python built-in function <cite>isinstance</cite>. If the type_code
is a str, it checks the type_code against the names of the object and all
its parent classes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.kernel">
<span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.kernel" title="Link to this definition">#</a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.level_shift">
<span class="sig-name descname"><span class="pre">level_shift</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.level_shift" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.make_rdm1">
<span class="sig-name descname"><span class="pre">make_rdm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.make_rdm1" title="Link to this definition">#</a></dt>
<dd><p>One-particle density matrix in AO representation</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Orbital coefficients. Each column is one orbital.</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Occupancy</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>One-particle density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.make_rdm2">
<span class="sig-name descname"><span class="pre">make_rdm2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.make_rdm2" title="Link to this definition">#</a></dt>
<dd><p>Two-particle density matrix in AO representation</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Orbital coefficients. Each column is one orbital.</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Occupancy</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Two-particle density matrix, 4D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.max_cycle">
<span class="sig-name descname"><span class="pre">max_cycle</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">50</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.max_cycle" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.mulliken_meta">
<span class="sig-name descname"><span class="pre">mulliken_meta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.mulliken_meta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.mulliken_meta" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carried out within each subsets.</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or 2-item list of ndarray</span></dt><dd><p>Density matrix.  ROHF dm is a 2-item list of 2D array</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.mulliken_pop">
<span class="sig-name descname"><span class="pre">mulliken_pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.mulliken_pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.mulliken_pop" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.mulliken_pop_meta_lowdin_ao">
<span class="sig-name descname"><span class="pre">mulliken_pop_meta_lowdin_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.mulliken_pop_meta_lowdin_ao" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carried out within each subsets.</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or 2-item list of ndarray</span></dt><dd><p>Density matrix.  ROHF dm is a 2-item list of 2D array</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.newton">
<span class="sig-name descname"><span class="pre">newton</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.newton"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.newton" title="Link to this definition">#</a></dt>
<dd><p>Create an SOSCF object based on the mean-field object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.nuc_grad_method">
<span class="sig-name descname"><span class="pre">nuc_grad_method</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.nuc_grad_method"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.nuc_grad_method" title="Link to this definition">#</a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.opt">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">opt</span></span><a class="headerlink" href="#pyscf.scf.hf.SCF.opt" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.pop" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carried out within each subsets.</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or 2-item list of ndarray</span></dt><dd><p>Density matrix.  ROHF dm is a 2-item list of 2D array</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.quad_moment">
<span class="sig-name descname"><span class="pre">quad_moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DebyeAngstrom'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.quad_moment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.quad_moment" title="Link to this definition">#</a></dt>
<dd><p>Calculates traceless quadrupole moment tensor.</p>
<p>The traceless quadrupole tensor is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}Q_{ij} &amp;= - \frac{1}{2} \sum_{\mu \nu} P_{\mu \nu}
        \left[ 3 (\nu | r_i r_j | \mu) - \delta_{ij} (\nu | r^2 | \mu) \right] \\
       &amp;+ \frac{1}{2} \sum_A Q_A
       \left( R_{iA} R_{jA} - \delta_{ij} \|\mathbf{R}_A\|^2  \right).\end{split}\]</div>
<p>If the molecule has a dipole, the quadrupole moment depends on the location
of the origin. By default, the origin is taken to be (0, 0, 0), but it can
be set manually via the keyword argument <cite>origin</cite>.</p>
<dl>
<dt>Args:</dt><dd><p>mol: an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code>
dm : a 2D ndarrays density matrices
origin : optional; length 3 list, tuple, or 1D array</p>
<blockquote>
<div><p>Location of the origin. By default, it is (0, 0, 0).</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><p>Traceless quadrupole tensor, 2D ndarray.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.remove_soscf">
<span class="sig-name descname"><span class="pre">remove_soscf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.remove_soscf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.remove_soscf" title="Link to this definition">#</a></dt>
<dd><p>Remove the SOSCF decorator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.reset" title="Link to this definition">#</a></dt>
<dd><p>Reset mol and relevant attributes associated to the old mol object</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.sap_basis">
<span class="sig-name descname"><span class="pre">sap_basis</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'sapgrasplarge'</span></em><a class="headerlink" href="#pyscf.scf.hf.SCF.sap_basis" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.scf">
<span class="sig-name descname"><span class="pre">scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.scf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.scf" title="Link to this definition">#</a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.sfx2c1e">
<span class="sig-name descname"><span class="pre">sfx2c1e</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.sfx2c1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.sfx2c1e" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.stability">
<span class="sig-name descname"><span class="pre">stability</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.stability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.stability" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.to_ghf">
<span class="sig-name descname"><span class="pre">to_ghf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.to_ghf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.to_ghf" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a GHF object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.to_gks">
<span class="sig-name descname"><span class="pre">to_gks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.to_gks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.to_gks" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a GKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.to_gpu">
<span class="sig-name descname"><span class="pre">to_gpu</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.to_gpu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.to_gpu" title="Link to this definition">#</a></dt>
<dd><p>Converts to the object with GPU support.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.to_ks">
<span class="sig-name descname"><span class="pre">to_ks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.to_ks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.to_ks" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to the associated KS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.to_rhf">
<span class="sig-name descname"><span class="pre">to_rhf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.to_rhf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.to_rhf" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a RHF/ROHF object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.to_rks">
<span class="sig-name descname"><span class="pre">to_rks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.to_rks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.to_rks" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a RKS/ROKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.to_uhf">
<span class="sig-name descname"><span class="pre">to_uhf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.to_uhf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.to_uhf" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a UHF object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.to_uks">
<span class="sig-name descname"><span class="pre">to_uks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.to_uks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.to_uks" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to a UKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.update" title="Link to this definition">#</a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It’s an alias of function <a href="#id5"><span class="problematic" id="id6">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.update_">
<span class="sig-name descname"><span class="pre">update_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF.update_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF.update_" title="Link to this definition">#</a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It’s an alias of function <a href="#id7"><span class="problematic" id="id8">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.update_from_chk">
<span class="sig-name descname"><span class="pre">update_from_chk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.update_from_chk" title="Link to this definition">#</a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It’s an alias of function <a href="#id9"><span class="problematic" id="id10">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.update_from_chk_">
<span class="sig-name descname"><span class="pre">update_from_chk_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.update_from_chk_" title="Link to this definition">#</a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It’s an alias of function <a href="#id11"><span class="problematic" id="id12">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.x2c">
<span class="sig-name descname"><span class="pre">x2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.x2c" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF.x2c1e">
<span class="sig-name descname"><span class="pre">x2c1e</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.SCF.x2c1e" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.hf.SCF_Scanner">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">SCF_Scanner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf_obj</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#SCF_Scanner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.SCF_Scanner" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="pyscf.lib.html#pyscf.lib.misc.SinglePointScanner" title="pyscf.lib.misc.SinglePointScanner"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglePointScanner</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.analyze">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.as_scanner">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">as_scanner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#as_scanner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.as_scanner" title="Link to this definition">#</a></dt>
<dd><p>Generating a scanner/solver for HF PES.</p>
<p>The returned solver is a function. This function requires one argument
“mol” as input and returns total HF energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
SCF object (DIIS, conv_tol, max_memory etc) are automatically applied in
the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, …) during calculation.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">))</span>
<span class="go">-98.552190448277955</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.5&#39;</span><span class="p">))</span>
<span class="go">-98.414750424294368</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.canonicalize">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#canonicalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.canonicalize" title="Link to this definition">#</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix within occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.damping">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">damping</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_prev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#damping"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.damping" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.dip_moment">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">dip_moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Debye'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#dip_moment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.dip_moment" title="Link to this definition">#</a></dt>
<dd><p>Dipole moment calculation</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mu_x = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|x|\mu) + \sum_A Q_A X_A\\
\mu_y = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|y|\mu) + \sum_A Q_A Y_A\\
\mu_z = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|z|\mu) + \sum_A Q_A Z_A\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu_x, \mu_y, \mu_z\)</span> are the x, y and z components of dipole
moment</p>
<dl>
<dt>Args:</dt><dd><p>mol: an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code>
dm : a 2D ndarrays density matrices
origin : optional; length 3 list, tuple, or 1D array</p>
<blockquote>
<div><p>Location of the origin. By default, the point (0, 0, 0) is used.</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z component</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.dot_eri_dm">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">dot_eri_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_j</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#dot_eri_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.dot_eri_dm" title="Link to this definition">#</a></dt>
<dd><p>Compute J, K matrices in terms of the given 2-electron integrals and
density matrix:</p>
<p>J ~ numpy.einsum(‘pqrs,qp-&gt;rs’, eri, dm)
K ~ numpy.einsum(‘pqrs,qr-&gt;ps’, eri, dm)</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>eri<span class="classifier">ndarray</span></dt><dd><p>8-fold or 4-fold ERIs or complex integral array with N^4 elements
(N is the number of orbitals)</p>
</dd>
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="kn">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eri</span> <span class="o">=</span> <span class="n">_vhf</span><span class="o">.</span><span class="n">int2e_sph</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_env</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">dot_eri_dm</span><span class="p">(</span><span class="n">eri</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.dump_scf_summary">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">dump_scf_summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#dump_scf_summary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.dump_scf_summary" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.eig">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#eig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.eig" title="Link to this definition">#</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.energy_elec">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">energy_elec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#energy_elec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.energy_elec" title="Link to this definition">#</a></dt>
<dd><p>Electronic part of Hartree-Fock energy, for given core hamiltonian and
HF potential</p>
<p>… math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> \<span class="n">sum_</span><span class="p">{</span><span class="n">ij</span><span class="p">}</span><span class="n">h_</span><span class="p">{</span><span class="n">ij</span><span class="p">}</span> \<span class="n">gamma_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span>
  <span class="o">+</span> \<span class="n">frac</span><span class="p">{</span><span class="mi">1</span><span class="p">}{</span><span class="mi">2</span><span class="p">}</span>\<span class="n">sum_</span><span class="p">{</span><span class="n">ijkl</span><span class="p">}</span> \<span class="n">gamma_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span>\<span class="n">gamma_</span><span class="p">{</span><span class="n">lk</span><span class="p">}</span> \<span class="n">langle</span> <span class="n">ik</span><span class="o">||</span><span class="n">jl</span>\<span class="n">rangle</span>
</pre></div>
</div>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mf : an instance of SCF class</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm<span class="classifier">2D ndarray</span></dt><dd><p>one-particle density matrix</p>
</dd>
<dt>h1e<span class="classifier">2D ndarray</span></dt><dd><p>Core hamiltonian</p>
</dd>
<dt>vhf<span class="classifier">2D ndarray</span></dt><dd><p>HF potential</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Hartree-Fock electronic energy and the Coulomb energy</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.energy_tot">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">energy_tot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#energy_tot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.energy_tot" title="Link to this definition">#</a></dt>
<dd><p>Total Hartree-Fock energy, electronic part plus nuclear repulsion
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.energy_elec()</span></code> for the electron part</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.get_fock">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">get_fock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis_start_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damp_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#get_fock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.get_fock" title="Link to this definition">#</a></dt>
<dd><p>F = h^{core} + V^{HF}</p>
<p>Special treatment (damping, DIIS, or level shift) will be applied to the
Fock matrix if diis and cycle is specified (The two parameters are passed
to get_fock function during the SCF iteration)</p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>h1e<span class="classifier">2D ndarray</span></dt><dd><p>Core hamiltonian</p>
</dd>
<dt>s1e<span class="classifier">2D ndarray</span></dt><dd><p>Overlap matrix, for DIIS</p>
</dd>
<dt>vhf<span class="classifier">2D ndarray</span></dt><dd><p>HF potential matrix</p>
</dd>
<dt>dm<span class="classifier">2D ndarray</span></dt><dd><p>Density matrix, for DIIS</p>
</dd>
<dt>cycle<span class="classifier">int</span></dt><dd><p>Then present SCF iteration step, for DIIS</p>
</dd>
<dt>diis<span class="classifier">an object of <a class="reference internal" href="#pyscf.scf.hf.SCF.DIIS" title="pyscf.scf.hf.SCF.DIIS"><code class="xref py py-attr docutils literal notranslate"><span class="pre">SCF.DIIS</span></code></a> class</span></dt><dd><p>DIIS object to hold intermediate Fock and error vectors</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 0.</p>
</dd>
<dt>level_shift_factor<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.get_grad">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock_ao</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.get_grad" title="Link to this definition">#</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Orbital occupancy</p>
</dd>
<dt>fock_ao<span class="classifier">2D ndarray</span></dt><dd><p>Fock matrix in AO representation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.get_hcore">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">get_hcore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#get_hcore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.get_hcore" title="Link to this definition">#</a></dt>
<dd><p>Core Hamiltonian</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_hcore</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">array([[-0.93767904, -0.59316327],</span>
<span class="go">       [-0.59316327, -0.93767904]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.get_init_guess">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">get_init_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'minao'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#get_init_guess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.get_init_guess" title="Link to this definition">#</a></dt>
<dd><p>Generate density matrix for initial guess</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>key<span class="classifier">str</span></dt><dd><p>One of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.get_jk">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">get_jk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhfopt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_j</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#get_jk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.get_jk" title="Link to this definition">#</a></dt>
<dd><p>Compute J, K matrices for all input density matrices</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : not hermitian and not symmetric</div>
<div class="line">1 : hermitian or symmetric</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
<dt>with_j<span class="classifier">boolean</span></dt><dd><p>Whether to compute J matrices</p>
</dd>
<dt>with_k<span class="classifier">boolean</span></dt><dd><p>Whether to compute K matrices</p>
</dd>
<dt>omega<span class="classifier">float</span></dt><dd><p>Parameter of range-separated Coulomb operator: erf( omega * r12 ) / r12.
If specified, integration are evaluated based on the long-range
part of the range-separated Coulomb operator.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="kn">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.get_occ">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#get_occ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.get_occ" title="Link to this definition">#</a></dt>
<dd><p>Label the occupancies for each orbital</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">1D ndarray</span></dt><dd><p>Obital energies</p>
</dd>
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 0, 2, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.get_ovlp">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">get_ovlp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#get_ovlp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.get_ovlp" title="Link to this definition">#</a></dt>
<dd><p>Overlap matrix</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.get_veff">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">get_veff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhfopt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#get_veff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.get_veff" title="Link to this definition">#</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>dm_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</p>
</dd>
<dt>vhf_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The reference HF potential matrix.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>matrix Vhf = 2*J - K.  Vhf can be a list matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf.scf</span> <span class="kn">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf0</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">dm_last</span><span class="o">=</span><span class="n">dm0</span><span class="p">,</span> <span class="n">vhf_last</span><span class="o">=</span><span class="n">vhf0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vhf1</span><span class="p">,</span> <span class="n">vhf2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.init_guess_by_1e">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#init_guess_by_1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.init_guess_by_1e" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.init_guess_by_atom">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#init_guess_by_atom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.init_guess_by_atom" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.init_guess_by_chkfile">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_chkfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chkfile_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#init_guess_by_chkfile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.init_guess_by_chkfile" title="Link to this definition">#</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.init_guess_by_huckel">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#init_guess_by_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.init_guess_by_huckel" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.init_guess_by_minao">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_minao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#init_guess_by_minao"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.init_guess_by_minao" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix based on ANO basis, then project
the density matrix to the basis set defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">init_guess_by_minao</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">array([[ 0.94758917,  0.09227308],</span>
<span class="go">       [ 0.09227308,  0.94758917]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.init_guess_by_mod_huckel">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_mod_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#init_guess_by_mod_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.init_guess_by_mod_huckel" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<p>In contrast to init_guess_by_huckel, this routine employs the
updated GWH rule from doi:10.1021/ja00480a005 to form the guess.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.init_guess_by_sap">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_sap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sap_basis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#init_guess_by_sap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.init_guess_by_sap" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a superposition of
atomic potentials (SAP), doi:10.1021/acs.jctc.8b01089.
This is the Gaussian fit implementation, see doi:10.1063/5.0004046.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mol<span class="classifier">MoleBase object</span></dt><dd><p>the molecule object for which the initial guess is evaluated</p>
</dd>
<dt>sap_basis<span class="classifier">dict</span></dt><dd><p>SAP basis in internal format (python dictionary)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>SAP initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.kernel">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_tol_grad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dump_chk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#kernel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.kernel" title="Link to this definition">#</a></dt>
<dd><p>kernel: the SCF driver.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>mf<span class="classifier">an instance of SCF class</span></dt><dd><p>mf object holds all parameters to control SCF.  One can modify its
member functions to change the behavior of SCF.  The member
functions which are called in kernel are</p>
<div class="line-block">
<div class="line">mf.get_init_guess</div>
<div class="line">mf.get_hcore</div>
<div class="line">mf.get_ovlp</div>
<div class="line">mf.get_veff</div>
<div class="line">mf.get_fock</div>
<div class="line">mf.get_grad</div>
<div class="line">mf.eig</div>
<div class="line">mf.get_occ</div>
<div class="line">mf.make_rdm1</div>
<div class="line">mf.energy_tot</div>
<div class="line">mf.dump_chk</div>
</div>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.</p>
</dd>
<dt>dump_chk<span class="classifier">bool</span></dt><dd><p>Whether to save SCF intermediate results in the checkpoint file</p>
</dd>
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>Initial guess density matrix.  If not given (the default), the kernel
takes the density matrix generated by <code class="docutils literal notranslate"><span class="pre">mf.get_init_guess</span></code>.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>sap_basis<span class="classifier">str</span></dt><dd><p>SAP basis name</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list :   scf_conv, e_tot, mo_energy, mo_coeff, mo_occ</p>
<dl class="simple">
<dt>scf_conv<span class="classifier">bool</span></dt><dd><p>True means SCF converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Hartree-Fock energy of last iteration</p>
</dd>
<dt>mo_energy<span class="classifier">1D float array</span></dt><dd><p>Orbital energies.  Depending the eig function provided by mf
object, the orbital energies may NOT be sorted.</p>
</dd>
<dt>mo_coeff<span class="classifier">2D array</span></dt><dd><p>Orbital coefficients.</p>
</dd>
<dt>mo_occ<span class="classifier">1D array</span></dt><dd><p>Orbital occupancies.  The occupancies may NOT be sorted from large
to small.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conv</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">mo_e</span><span class="p">,</span> <span class="n">mo</span><span class="p">,</span> <span class="n">mo_occ</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">),</span> <span class="n">dm0</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;conv = </span><span class="si">%s</span><span class="s1">, E(HF) = </span><span class="si">%.12f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">conv</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
<span class="go">conv = True, E(HF) = -1.081170784378</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.level_shift">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">level_shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#level_shift"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.level_shift" title="Link to this definition">#</a></dt>
<dd><p>Apply level shift <span class="math notranslate nohighlight">\(\Delta\)</span> to virtual orbitals</p>
<div class="math notranslate nohighlight">
\begin{align}
  FC &amp;= SCE \\
  F &amp;= F + SC \Lambda C^\dagger S \\
  \Lambda_{ij} &amp;=
  \begin{cases}
     \delta_{ij}\Delta &amp; i \in \text{virtual} \\
     0 &amp; \text{otherwise}
  \end{cases}
\end{align}</div><dl class="simple">
<dt>Returns:</dt><dd><p>New Fock matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.make_rdm1">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">make_rdm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#make_rdm1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.make_rdm1" title="Link to this definition">#</a></dt>
<dd><p>One-particle density matrix in AO representation</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Orbital coefficients. Each column is one orbital.</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Occupancy</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>One-particle density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.make_rdm2">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">make_rdm2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#make_rdm2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.make_rdm2" title="Link to this definition">#</a></dt>
<dd><p>Two-particle density matrix in AO representation</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Orbital coefficients. Each column is one orbital.</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Occupancy</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Two-particle density matrix, 4D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.make_sap">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">make_sap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sap_basis</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#make_sap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.make_sap" title="Link to this definition">#</a></dt>
<dd><p>Superposition of atomic potentials (SAP) potential matrix</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mol<span class="classifier">MoleBase object</span></dt><dd><p>molecule for which SAP is computed</p>
</dd>
<dt>sap_basis<span class="classifier">dict</span></dt><dd><p>SAP basis</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>Vsap<span class="classifier">ndarray</span></dt><dd><p>SAP potential matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.mulliken_meta">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">mulliken_meta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#mulliken_meta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.mulliken_meta" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carried out within each subsets.</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or 2-item list of ndarray</span></dt><dd><p>Density matrix.  ROHF dm is a 2-item list of 2D array</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.mulliken_pop">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">mulliken_pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#mulliken_pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.mulliken_pop" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.mulliken_pop_meta_lowdin_ao">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">mulliken_pop_meta_lowdin_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf.mulliken_pop_meta_lowdin_ao" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carried out within each subsets.</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or 2-item list of ndarray</span></dt><dd><p>Density matrix.  ROHF dm is a 2-item list of 2D array</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.pack_uniq_var">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">pack_uniq_var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#pack_uniq_var"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.pack_uniq_var" title="Link to this definition">#</a></dt>
<dd><p>Extract the unique variables from the full orbital-gradients (or
orbital-rotation) matrix</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.quad_moment">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">quad_moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DebyeAngstrom'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#quad_moment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.quad_moment" title="Link to this definition">#</a></dt>
<dd><p>Calculates traceless quadrupole moment tensor.</p>
<p>The traceless quadrupole tensor is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}Q_{ij} &amp;= - \frac{1}{2} \sum_{\mu \nu} P_{\mu \nu}
        \left[ 3 (\nu | r_i r_j | \mu) - \delta_{ij} (\nu | r^2 | \mu) \right] \\
       &amp;+ \frac{1}{2} \sum_A Q_A
       \left( R_{iA} R_{jA} - \delta_{ij} \|\mathbf{R}_A\|^2  \right).\end{split}\]</div>
<p>If the molecule has a dipole, the quadrupole moment depends on the location
of the origin. By default, the origin is taken to be (0, 0, 0), but it can
be set manually via the keyword argument <cite>origin</cite>.</p>
<dl>
<dt>Args:</dt><dd><p>mol: an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code>
dm : a 2D ndarrays density matrices
origin : optional; length 3 list, tuple, or 1D array</p>
<blockquote>
<div><p>Location of the origin. By default, it is (0, 0, 0).</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><p>Traceless quadrupole tensor, 2D ndarray.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.uniq_var_indices">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">uniq_var_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#uniq_var_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.uniq_var_indices" title="Link to this definition">#</a></dt>
<dd><p>Indices of the unique variables for the orbital-gradients (or
orbital-rotation) matrix.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf.unpack_uniq_var">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf.</span></span><span class="sig-name descname"><span class="pre">unpack_uniq_var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf.html#unpack_uniq_var"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf.unpack_uniq_var" title="Link to this definition">#</a></dt>
<dd><p>Fill the full orbital-gradients (or orbital-rotation) matrix with the
unique variables.</p>
</dd></dl>

</section>
<section id="module-pyscf.scf.hf_symm">
<span id="pyscf-scf-hf-symm-module"></span><h2>pyscf.scf.hf_symm module<a class="headerlink" href="#module-pyscf.scf.hf_symm" title="Link to this heading">#</a></h2>
<p>Non-relativistic restricted Hartree-Fock with point group symmetry.</p>
<p>The symmetry are not handled in a separate data structure.  Note that during
the SCF iteration,  the orbitals are grouped in terms of symmetry irreps.
But the orbitals in the result are sorted based on the orbital energies.
Function symm.label_orb_symm can be used to detect the symmetry of the
molecular orbitals.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.HF1e">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">HF1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#HF1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.HF1e" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.hf_symm.SymAdaptedROHF" title="pyscf.scf.hf_symm.SymAdaptedROHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymAdaptedROHF</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.HF1e.scf">
<span class="sig-name descname"><span class="pre">scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.HF1e.scf" title="Link to this definition">#</a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.RHF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">RHF</span></span><a class="headerlink" href="#pyscf.scf.hf_symm.RHF" title="Link to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.hf_symm.SymAdaptedRHF" title="pyscf.scf.hf_symm.SymAdaptedRHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymAdaptedRHF</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.ROHF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">ROHF</span></span><a class="headerlink" href="#pyscf.scf.hf_symm.ROHF" title="Link to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.hf_symm.SymAdaptedROHF" title="pyscf.scf.hf_symm.SymAdaptedROHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymAdaptedROHF</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">SymAdaptedRHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedRHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.hf.RHF" title="pyscf.scf.hf.RHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">RHF</span></code></a></p>
<p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="simple">
<dt>Attributes for symmetry allowed RHF:</dt><dd><dl class="simple">
<dt>irrep_nelec<span class="classifier">dict</span></dt><dd><p>Specify the number of electrons for particular irrep {‘ir_name’:int,…}.
For the irreps not listed in this dict, the program will choose the
occupancy based on the orbital energies.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-76.016789472074251</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">()</span>
<span class="go">{&#39;A1&#39;: 6, &#39;A2&#39;: 0, &#39;B1&#39;: 2, &#39;B2&#39;: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">irrep_nelec</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A2&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-72.768201804695622</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">()</span>
<span class="go">{&#39;A1&#39;: 6, &#39;A2&#39;: 2, &#39;B1&#39;: 2, &#39;B2&#39;: 0}</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.CASCI">
<span class="sig-name descname"><span class="pre">CASCI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.CASCI" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.CASSCF">
<span class="sig-name descname"><span class="pre">CASSCF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.CASSCF" title="Link to this definition">#</a></dt>
<dd><p>CASCI/CASSCF</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>mf_or_mol<span class="classifier">SCF object or Mole object</span></dt><dd><p>SCF or Mole to define the problem size.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Number of active orbitals.</p>
</dd>
<dt>nelecas<span class="classifier">int or a pair of int</span></dt><dd><p>Number of electrons in active space.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>ncore<span class="classifier">int</span></dt><dd><p>Number of doubly occupied core orbitals. If not presented, this
parameter can be automatically determined.</p>
</dd>
</dl>
</dd>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code>.</p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code>.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Active space size.</p>
</dd>
<dt>nelecas<span class="classifier">tuple of int</span></dt><dd><p>Active (nelec_alpha, nelec_beta)</p>
</dd>
<dt>ncore<span class="classifier">int or tuple of int</span></dt><dd><p>Core electron number.  In UHF-CASSCF, it’s a tuple to indicate the different core electron numbers.</p>
</dd>
<dt>natorb<span class="classifier">bool</span></dt><dd><p>Whether to transform natural orbitals in active space.
Note: when CASCI/CASSCF are combined with DMRG solver or selected
CI solver, enabling this parameter may slightly change the total energy.
False by default.</p>
</dd>
<dt>canonicalization<span class="classifier">bool</span></dt><dd><p>Whether to canonicalize orbitals in core and external space
against the general Fock matrix.
The orbitals in active space are NOT transformed by default. To
get the natural orbitals in active space, the attribute .natorb
needs to be enabled.
True by default.</p>
</dd>
<dt>sorting_mo_energy<span class="classifier">bool</span></dt><dd><p>Whether to sort the orbitals based on the diagonal elements of the
general Fock matrix.  Default is False.</p>
</dd>
<dt>fcisolver<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">FCISolver</span></code></span></dt><dd><p>The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal notranslate"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p>For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>e_cas<span class="classifier">float</span></dt><dd><p>CAS space FCI energy</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>When canonicalization is specified, the orbitals are canonical
orbitals which make the general Fock matrix (Fock operator on top
of MCSCF 1-particle density matrix) diagonalized within each
subspace (core, active, external).  If natorb (natural orbitals in
active space) is specified, the active segment of the mo_coeff is
natural orbitals.</p>
</dd>
<dt>mo_energy<span class="classifier">ndarray</span></dt><dd><p>Diagonal elements of general Fock matrix (in mo_coeff
representation).</p>
</dd>
<dt>mo_occ<span class="classifier">ndarray</span></dt><dd><p>Occupation numbers of natural orbitals if natorb is specified.</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
</pre></div>
</div>
<p>Extra attributes for CASSCF:</p>
<blockquote>
<div><dl>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Converge threshold.  Default is 1e-7</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>Converge threshold for CI gradients and orbital rotation gradients.
If not specified, it is set to sqrt(conv_tol).</p>
</dd>
<dt>max_stepsize<span class="classifier">float</span></dt><dd><p>The step size for orbital rotation.  Small step (0.005 - 0.05) is prefered.
Default is 0.02.</p>
</dd>
<dt>max_cycle_macro<span class="classifier">int</span></dt><dd><p>Max number of macro iterations.  Default is 50.</p>
</dd>
<dt>max_cycle_micro<span class="classifier">int</span></dt><dd><p>Max number of micro iterations in each macro iteration.  Depending on
systems, increasing this value might reduce the total macro
iterations.  Generally, 2 - 5 steps should be enough.  Default is 4.</p>
</dd>
<dt>small_rot_tol<span class="classifier">float</span></dt><dd><p>Threshold for orbital rotation to be considered small. If the largest orbital
rotation is smaller than this value, the CI solver will restart from the
previous iteration if supported.
Default is 0.01</p>
</dd>
<dt>ah_level_shift<span class="classifier">float, for AH solver.</span></dt><dd><p>Level shift for the Davidson diagonalization in AH solver.  Default is 1e-8.</p>
</dd>
<dt>ah_conv_tol<span class="classifier">float, for AH solver.</span></dt><dd><p>converge threshold for AH solver.  Default is 1e-12.</p>
</dd>
<dt>ah_max_cycle<span class="classifier">float, for AH solver.</span></dt><dd><p>Max number of iterations allowd in AH solver.  Default is 30.</p>
</dd>
<dt>ah_lindep<span class="classifier">float, for AH solver.</span></dt><dd><p>Linear dependence threshold for AH solver.  Default is 1e-14.</p>
</dd>
<dt>ah_start_tol<span class="classifier">flat, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 2.5.</p>
</dd>
<dt>ah_start_cycle<span class="classifier">int, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 3.</p>
<p><code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_max_cycle</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_start_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_start_cycle</span></code>
can affect the accuracy and performance of CASSCF solver.  Lower
<code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code> might improve the accuracy of CASSCF
optimization, but decrease the performance.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401898486001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401887945668</span>
</pre></div>
</div>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>Checkpoint file to save the intermediate orbitals during the CASSCF optimization.
Default is the checkpoint file of mean field object.</p>
</dd>
<dt>ci_response_space<span class="classifier">int</span></dt><dd><p>subspace size to solve the CI vector response.  Default is 3.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>scale_restoration<span class="classifier">float</span></dt><dd><p>When a step of orbital rotation moves out of trust region, the
orbital optimization will be restored to previous state and the
step size of the orbital rotation needs to be reduced.
scale_restoration controls how much to scale down the step size.</p>
</dd>
</dl>
</div></blockquote>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>e_cas<span class="classifier">float</span></dt><dd><p>CAS space FCI energy</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>Optimized CASSCF orbitals coefficients. When canonicalization is
specified, the returned orbitals make the general Fock matrix
(Fock operator on top of MCSCF 1-particle density matrix)
diagonalized within each subspace (core, active, external). If
natorb (natural orbitals in active space) is enabled, the active
segment of mo_coeff is transformed to natural orbitals.</p>
</dd>
<dt>mo_energy<span class="classifier">ndarray</span></dt><dd><p>Diagonal elements of general Fock matrix (in mo_coeff
representation).</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401882238134</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.analyze">
<span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedRHF.analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Occupancy for each irreps; Mulliken population analysis</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedRHF.build"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.build" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.canonicalize">
<span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.canonicalize" title="Link to this definition">#</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix in occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symm_orb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irrep_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.eig" title="Link to this definition">#</a></dt>
<dd><p>Solve generalized eigenvalue problem, for each irrep.  The
eigenvalues and eigenvectors are not sorted to ascending order.
Instead, they are grouped based on irreps.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.get_grad">
<span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedRHF.get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.get_grad" title="Link to this definition">#</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Orbital occupancy</p>
</dd>
<dt>fock_ao<span class="classifier">2D ndarray</span></dt><dd><p>Fock matrix in AO representation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.get_irrep_nelec">
<span class="sig-name descname"><span class="pre">get_irrep_nelec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedRHF.get_irrep_nelec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.get_irrep_nelec" title="Link to this definition">#</a></dt>
<dd><p>Electron numbers for each irreducible representation.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>mol<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></span></dt><dd><p>To provide irrep_id, and spin-adapted basis</p>
</dd>
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Regular orbital coefficients, without grouping for irreps</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Regular occupancy, without grouping for irreps</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>irrep_nelec<span class="classifier">dict</span></dt><dd><p>The number of electrons for each irrep {‘ir_name’:int,…}.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-76.016789472074251</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf_symm</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">)</span>
<span class="go">{&#39;A1&#39;: 6, &#39;A2&#39;: 0, &#39;B1&#39;: 2, &#39;B2&#39;: 2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.get_occ">
<span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedRHF.get_occ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.get_occ" title="Link to this definition">#</a></dt>
<dd><p>We assumed mo_energy are grouped by symmetry irreps, (see function
self.eig). The orbitals are sorted after SCF.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.get_orbsym">
<span class="sig-name descname"><span class="pre">get_orbsym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedRHF.get_orbsym"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.get_orbsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.get_wfnsym">
<span class="sig-name descname"><span class="pre">get_wfnsym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbsym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.get_wfnsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.orbsym">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">orbsym</span></span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.orbsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.to_gpu">
<span class="sig-name descname"><span class="pre">to_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.to_gpu" title="Link to this definition">#</a></dt>
<dd><p>Convert a method to its corresponding GPU variant, and recursively
converts all attributes of a method to cupy objects or gpu4pyscf objects.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedRHF.wfnsym">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wfnsym</span></span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedRHF.wfnsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">SymAdaptedROHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedROHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.rohf.ROHF" title="pyscf.scf.rohf.ROHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">ROHF</span></code></a></p>
<p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="simple">
<dt>Attributes for symmetry allowed ROHF:</dt><dd><dl class="simple">
<dt>irrep_nelec<span class="classifier">dict</span></dt><dd><p>Specify the number of alpha/beta electrons for particular irrep
{‘ir_name’:(int,int), …}.
For the irreps not listed in these dicts, the program will choose the
occupancy based on the orbital energies.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-75.619358861084052</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">()</span>
<span class="go">{&#39;A1&#39;: (3, 3), &#39;A2&#39;: (0, 0), &#39;B1&#39;: (1, 1), &#39;B2&#39;: (1, 0)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">irrep_nelec</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;B1&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-75.425669486776457</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">()</span>
<span class="go">{&#39;A1&#39;: (3, 3), &#39;A2&#39;: (0, 0), &#39;B1&#39;: (1, 0), &#39;B2&#39;: (1, 1)}</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.CASCI">
<span class="sig-name descname"><span class="pre">CASCI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.CASCI" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.CASSCF">
<span class="sig-name descname"><span class="pre">CASSCF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.CASSCF" title="Link to this definition">#</a></dt>
<dd><p>CASCI/CASSCF</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>mf_or_mol<span class="classifier">SCF object or Mole object</span></dt><dd><p>SCF or Mole to define the problem size.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Number of active orbitals.</p>
</dd>
<dt>nelecas<span class="classifier">int or a pair of int</span></dt><dd><p>Number of electrons in active space.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>ncore<span class="classifier">int</span></dt><dd><p>Number of doubly occupied core orbitals. If not presented, this
parameter can be automatically determined.</p>
</dd>
</dl>
</dd>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code>.</p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code>.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Active space size.</p>
</dd>
<dt>nelecas<span class="classifier">tuple of int</span></dt><dd><p>Active (nelec_alpha, nelec_beta)</p>
</dd>
<dt>ncore<span class="classifier">int or tuple of int</span></dt><dd><p>Core electron number.  In UHF-CASSCF, it’s a tuple to indicate the different core electron numbers.</p>
</dd>
<dt>natorb<span class="classifier">bool</span></dt><dd><p>Whether to transform natural orbitals in active space.
Note: when CASCI/CASSCF are combined with DMRG solver or selected
CI solver, enabling this parameter may slightly change the total energy.
False by default.</p>
</dd>
<dt>canonicalization<span class="classifier">bool</span></dt><dd><p>Whether to canonicalize orbitals in core and external space
against the general Fock matrix.
The orbitals in active space are NOT transformed by default. To
get the natural orbitals in active space, the attribute .natorb
needs to be enabled.
True by default.</p>
</dd>
<dt>sorting_mo_energy<span class="classifier">bool</span></dt><dd><p>Whether to sort the orbitals based on the diagonal elements of the
general Fock matrix.  Default is False.</p>
</dd>
<dt>fcisolver<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">FCISolver</span></code></span></dt><dd><p>The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal notranslate"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p>For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>e_cas<span class="classifier">float</span></dt><dd><p>CAS space FCI energy</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>When canonicalization is specified, the orbitals are canonical
orbitals which make the general Fock matrix (Fock operator on top
of MCSCF 1-particle density matrix) diagonalized within each
subspace (core, active, external).  If natorb (natural orbitals in
active space) is specified, the active segment of the mo_coeff is
natural orbitals.</p>
</dd>
<dt>mo_energy<span class="classifier">ndarray</span></dt><dd><p>Diagonal elements of general Fock matrix (in mo_coeff
representation).</p>
</dd>
<dt>mo_occ<span class="classifier">ndarray</span></dt><dd><p>Occupation numbers of natural orbitals if natorb is specified.</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
</pre></div>
</div>
<p>Extra attributes for CASSCF:</p>
<blockquote>
<div><dl>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Converge threshold.  Default is 1e-7</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>Converge threshold for CI gradients and orbital rotation gradients.
If not specified, it is set to sqrt(conv_tol).</p>
</dd>
<dt>max_stepsize<span class="classifier">float</span></dt><dd><p>The step size for orbital rotation.  Small step (0.005 - 0.05) is prefered.
Default is 0.02.</p>
</dd>
<dt>max_cycle_macro<span class="classifier">int</span></dt><dd><p>Max number of macro iterations.  Default is 50.</p>
</dd>
<dt>max_cycle_micro<span class="classifier">int</span></dt><dd><p>Max number of micro iterations in each macro iteration.  Depending on
systems, increasing this value might reduce the total macro
iterations.  Generally, 2 - 5 steps should be enough.  Default is 4.</p>
</dd>
<dt>small_rot_tol<span class="classifier">float</span></dt><dd><p>Threshold for orbital rotation to be considered small. If the largest orbital
rotation is smaller than this value, the CI solver will restart from the
previous iteration if supported.
Default is 0.01</p>
</dd>
<dt>ah_level_shift<span class="classifier">float, for AH solver.</span></dt><dd><p>Level shift for the Davidson diagonalization in AH solver.  Default is 1e-8.</p>
</dd>
<dt>ah_conv_tol<span class="classifier">float, for AH solver.</span></dt><dd><p>converge threshold for AH solver.  Default is 1e-12.</p>
</dd>
<dt>ah_max_cycle<span class="classifier">float, for AH solver.</span></dt><dd><p>Max number of iterations allowd in AH solver.  Default is 30.</p>
</dd>
<dt>ah_lindep<span class="classifier">float, for AH solver.</span></dt><dd><p>Linear dependence threshold for AH solver.  Default is 1e-14.</p>
</dd>
<dt>ah_start_tol<span class="classifier">flat, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 2.5.</p>
</dd>
<dt>ah_start_cycle<span class="classifier">int, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 3.</p>
<p><code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_max_cycle</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_start_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_start_cycle</span></code>
can affect the accuracy and performance of CASSCF solver.  Lower
<code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code> might improve the accuracy of CASSCF
optimization, but decrease the performance.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401898486001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401887945668</span>
</pre></div>
</div>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>Checkpoint file to save the intermediate orbitals during the CASSCF optimization.
Default is the checkpoint file of mean field object.</p>
</dd>
<dt>ci_response_space<span class="classifier">int</span></dt><dd><p>subspace size to solve the CI vector response.  Default is 3.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>scale_restoration<span class="classifier">float</span></dt><dd><p>When a step of orbital rotation moves out of trust region, the
orbital optimization will be restored to previous state and the
step size of the orbital rotation needs to be reduced.
scale_restoration controls how much to scale down the step size.</p>
</dd>
</dl>
</div></blockquote>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>e_cas<span class="classifier">float</span></dt><dd><p>CAS space FCI energy</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>Optimized CASSCF orbitals coefficients. When canonicalization is
specified, the returned orbitals make the general Fock matrix
(Fock operator on top of MCSCF 1-particle density matrix)
diagonalized within each subspace (core, active, external). If
natorb (natural orbitals in active space) is enabled, the active
segment of mo_coeff is transformed to natural orbitals.</p>
</dd>
<dt>mo_energy<span class="classifier">ndarray</span></dt><dd><p>Diagonal elements of general Fock matrix (in mo_coeff
representation).</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401882238134</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.TDA">
<span class="sig-name descname"><span class="pre">TDA</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.TDA" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.TDHF">
<span class="sig-name descname"><span class="pre">TDHF</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.TDHF" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.analyze">
<span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedROHF.analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedROHF.build"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.build" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.canonicalize">
<span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedROHF.canonicalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.canonicalize" title="Link to this definition">#</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix in occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.dump_flags">
<span class="sig-name descname"><span class="pre">dump_flags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedROHF.dump_flags"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.dump_flags" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedROHF.eig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.eig" title="Link to this definition">#</a></dt>
<dd><p>Solve generalized eigenvalue problem, for each irrep.  The
eigenvalues and eigenvectors are not sorted to ascending order.
Instead, they are grouped based on irreps.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.get_grad">
<span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedROHF.get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.get_grad" title="Link to this definition">#</a></dt>
<dd><p>ROHF gradients is the off-diagonal block [co + cv + ov], where
[ cc co cv ]
[ oc oo ov ]
[ vc vo vv ]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.get_irrep_nelec">
<span class="sig-name descname"><span class="pre">get_irrep_nelec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedROHF.get_irrep_nelec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.get_irrep_nelec" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.get_occ">
<span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedROHF.get_occ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.get_occ" title="Link to this definition">#</a></dt>
<dd><p>Label the occupancies for each orbital.
NOTE the occupancies are not assigned based on the orbital energy ordering.
The first N orbitals are assigned to be occupied orbitals.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; O 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 2, 2, 1, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.get_orbsym">
<span class="sig-name descname"><span class="pre">get_orbsym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.get_orbsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.get_wfnsym">
<span class="sig-name descname"><span class="pre">get_wfnsym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbsym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.get_wfnsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.make_rdm1">
<span class="sig-name descname"><span class="pre">make_rdm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#SymAdaptedROHF.make_rdm1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.make_rdm1" title="Link to this definition">#</a></dt>
<dd><p>One-particle density matrix.  mo_occ is a 1D array, with occupancy 1 or 2.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.orbsym">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">orbsym</span></span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.orbsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.to_gpu">
<span class="sig-name descname"><span class="pre">to_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.to_gpu" title="Link to this definition">#</a></dt>
<dd><p>Convert a method to its corresponding GPU variant, and recursively
converts all attributes of a method to cupy objects or gpu4pyscf objects.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.SymAdaptedROHF.wfnsym">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wfnsym</span></span><a class="headerlink" href="#pyscf.scf.hf_symm.SymAdaptedROHF.wfnsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.analyze">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Occupancy for each irreps; Mulliken population analysis</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.canonicalize">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#canonicalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.canonicalize" title="Link to this definition">#</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix in occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.check_irrep_nelec">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">check_irrep_nelec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irrep_nelec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelec</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#check_irrep_nelec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.check_irrep_nelec" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.eig">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symm_orb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irrep_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#eig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.eig" title="Link to this definition">#</a></dt>
<dd><p>Solve generalized eigenvalue problem, for each irrep.  The
eigenvalues and eigenvectors are not sorted to ascending order.
Instead, they are grouped based on irreps.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.get_irrep_nelec">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">get_irrep_nelec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#get_irrep_nelec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.get_irrep_nelec" title="Link to this definition">#</a></dt>
<dd><p>Electron numbers for each irreducible representation.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>mol<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></span></dt><dd><p>To provide irrep_id, and spin-adapted basis</p>
</dd>
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Regular orbital coefficients, without grouping for irreps</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Regular occupancy, without grouping for irreps</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>irrep_nelec<span class="classifier">dict</span></dt><dd><p>The number of electrons for each irrep {‘ir_name’:int,…}.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-76.016789472074251</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf_symm</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">)</span>
<span class="go">{&#39;A1&#39;: 6, &#39;A2&#39;: 0, &#39;B1&#39;: 2, &#39;B2&#39;: 2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.get_orbsym">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">get_orbsym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symm_orb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irrep_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#get_orbsym"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.get_orbsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.get_wfnsym">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">get_wfnsym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbsym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#get_wfnsym"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.get_wfnsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.map_degeneracy">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">map_degeneracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbsym</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#map_degeneracy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.map_degeneracy" title="Link to this definition">#</a></dt>
<dd><p>Find degeneracy correspondence for cylindrical symmetry</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.hf_symm.so2ao_mo_coeff">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.hf_symm.</span></span><span class="sig-name descname"><span class="pre">so2ao_mo_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">so</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irrep_mo_coeff</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/hf_symm.html#so2ao_mo_coeff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.hf_symm.so2ao_mo_coeff" title="Link to this definition">#</a></dt>
<dd><p>Transfer the basis of MO coefficients, from symmetry-adapted basis to AO basis</p>
</dd></dl>

</section>
<section id="module-pyscf.scf.jk">
<span id="pyscf-scf-jk-module"></span><h2>pyscf.scf.jk module<a class="headerlink" href="#module-pyscf.scf.jk" title="Link to this heading">#</a></h2>
<p>General JK contraction function for
* arbitrary integrals
* 4 different molecules
* multiple density matrices
* arbitrary basis subset for the 4 indices</p>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.jk.get_jk">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.jk.</span></span><span class="sig-name descname"><span class="pre">get_jk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scripts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['ijkl,ji-&gt;kl']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'int2e_sph'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aosym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s1'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhfopt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/jk.html#get_jk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.jk.get_jk" title="Link to this definition">#</a></dt>
<dd><p>Compute J/K matrices for the given density matrix</p>
<dl>
<dt>Args:</dt><dd><p>mols : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> or a list of <cite>Mole</cite> objects</p>
<dl class="simple">
<dt>dms<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether the returned J (K) matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>intor<span class="classifier">str</span></dt><dd><p>2-electron integral name.  See <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the complete
list of available 2-electron integral names</p>
</dd>
<dt>aosym<span class="classifier">int or str</span></dt><dd><p>Permutation symmetry for the AO integrals</p>
<div class="line-block">
<div class="line">4 or ‘4’ or ‘s4’: 4-fold symmetry (default)</div>
<div class="line">‘2ij’ or ‘s2ij’ : symmetry between i, j in (ij|kl)</div>
<div class="line">‘2kl’ or ‘s2kl’ : symmetry between k, l in (ij|kl)</div>
<div class="line">1 or ‘1’ or ‘s1’: no symmetry</div>
<div class="line">‘a4ij’ : 4-fold symmetry with anti-symmetry between i, j in (ij|kl)</div>
<div class="line">‘a4kl’ : 4-fold symmetry with anti-symmetry between k, l in (ij|kl)</div>
<div class="line">‘a2ij’ : anti-symmetry between i, j in (ij|kl)</div>
<div class="line">‘a2kl’ : anti-symmetry between k, l in (ij|kl)</div>
</div>
</dd>
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. cint2e_ip_sph has 3 components.</p>
</dd>
<dt>scripts<span class="classifier">string or a list of strings</span></dt><dd><p>Contraction description (following numpy.einsum convention) based on
letters [ijkl].  Each script will be one-to-one applied to each
entry of dms.  So it must have the same number of elements as the
dms, len(scripts) == len(dms).</p>
</dd>
<dt>shls_slice<span class="classifier">8-element list</span></dt><dd><p>(ish_start, ish_end, jsh_start, jsh_end, ksh_start, ksh_end, lsh_start, lsh_end)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Depending on the number of density matrices, the function returns one
J/K matrix or a list of J/K matrices (the same number of entries as the
input dms).
Each JK matrices may be a 2D array or 3D array if the AO integral
has multiple components.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 -.5 0; H 0 .5 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nao</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">nao</span><span class="p">,</span><span class="n">nao</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Default, Coulomb matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vj</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Coulomb matrix with 8-fold permutation symmetry for AO integrals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vj</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="s1">&#39;ijkl,ji-&gt;kl&#39;</span><span class="p">,</span> <span class="n">aosym</span><span class="o">=</span><span class="s1">&#39;s8&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Exchange matrix with 8-fold permutation symmetry for AO integrals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vk</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="s1">&#39;ijkl,jk-&gt;il&#39;</span><span class="p">,</span> <span class="n">aosym</span><span class="o">=</span><span class="s1">&#39;s8&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute coulomb and exchange matrices together</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vj</span><span class="p">,</span> <span class="n">vk</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="p">(</span><span class="n">dm</span><span class="p">,</span><span class="n">dm</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;ijkl,ji-&gt;kl&#39;</span><span class="p">,</span><span class="s1">&#39;ijkl,li-&gt;kj&#39;</span><span class="p">),</span> <span class="n">aosym</span><span class="o">=</span><span class="s1">&#39;s8&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Analytical gradients for coulomb matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j1</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="s1">&#39;ijkl,lk-&gt;ij&#39;</span><span class="p">,</span> <span class="n">intor</span><span class="o">=</span><span class="s1">&#39;int2e_ip1_sph&#39;</span><span class="p">,</span> <span class="n">aosym</span><span class="o">=</span><span class="s1">&#39;s2kl&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># contraction across two molecules</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol1</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 2 0 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nao1</span> <span class="o">=</span> <span class="n">mol1</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">nao1</span><span class="p">,</span><span class="n">nao1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Coulomb interaction between two molecules, note 4-fold symmetry can be applied</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jcross</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">((</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol</span><span class="p">,</span><span class="n">mol</span><span class="p">),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">scripts</span><span class="o">=</span><span class="s1">&#39;ijkl,lk-&gt;ij&#39;</span><span class="p">,</span> <span class="n">aosym</span><span class="o">=</span><span class="s1">&#39;s4&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ecoul</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij&#39;</span><span class="p">,</span> <span class="n">jcross</span><span class="p">,</span> <span class="n">dm1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Exchange interaction between two molecules, no symmetry can be used</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kcross</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">((</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol</span><span class="p">,</span><span class="n">mol</span><span class="p">,</span><span class="n">mol1</span><span class="p">),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">scripts</span><span class="o">=</span><span class="s1">&#39;ijkl,jk-&gt;il&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ex</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ji&#39;</span><span class="p">,</span> <span class="n">kcross</span><span class="p">,</span> <span class="n">dm1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Analytical gradients for coulomb matrix between two molecules</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jcros1</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">((</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol</span><span class="p">,</span><span class="n">mol</span><span class="p">),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">scripts</span><span class="o">=</span><span class="s1">&#39;ijkl,lk-&gt;ij&#39;</span><span class="p">,</span> <span class="n">intor</span><span class="o">=</span><span class="s1">&#39;int2e_ip1_sph&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Analytical gradients for coulomb interaction between 1s density and the other molecule</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jpart1</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">((</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol</span><span class="p">,</span><span class="n">mol</span><span class="p">),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">scripts</span><span class="o">=</span><span class="s1">&#39;ijkl,lk-&gt;ij&#39;</span><span class="p">,</span> <span class="n">intor</span><span class="o">=</span><span class="s1">&#39;int2e_ip1_sph&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">shls_slice</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nbas</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nbas</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.jk.jk_build">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.jk.</span></span><span class="sig-name descname"><span class="pre">jk_build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scripts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['ijkl,ji-&gt;kl']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'int2e_sph'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aosym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s1'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhfopt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.jk.jk_build" title="Link to this definition">#</a></dt>
<dd><p>Compute J/K matrices for the given density matrix</p>
<dl>
<dt>Args:</dt><dd><p>mols : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> or a list of <cite>Mole</cite> objects</p>
<dl class="simple">
<dt>dms<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether the returned J (K) matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>intor<span class="classifier">str</span></dt><dd><p>2-electron integral name.  See <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the complete
list of available 2-electron integral names</p>
</dd>
<dt>aosym<span class="classifier">int or str</span></dt><dd><p>Permutation symmetry for the AO integrals</p>
<div class="line-block">
<div class="line">4 or ‘4’ or ‘s4’: 4-fold symmetry (default)</div>
<div class="line">‘2ij’ or ‘s2ij’ : symmetry between i, j in (ij|kl)</div>
<div class="line">‘2kl’ or ‘s2kl’ : symmetry between k, l in (ij|kl)</div>
<div class="line">1 or ‘1’ or ‘s1’: no symmetry</div>
<div class="line">‘a4ij’ : 4-fold symmetry with anti-symmetry between i, j in (ij|kl)</div>
<div class="line">‘a4kl’ : 4-fold symmetry with anti-symmetry between k, l in (ij|kl)</div>
<div class="line">‘a2ij’ : anti-symmetry between i, j in (ij|kl)</div>
<div class="line">‘a2kl’ : anti-symmetry between k, l in (ij|kl)</div>
</div>
</dd>
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. cint2e_ip_sph has 3 components.</p>
</dd>
<dt>scripts<span class="classifier">string or a list of strings</span></dt><dd><p>Contraction description (following numpy.einsum convention) based on
letters [ijkl].  Each script will be one-to-one applied to each
entry of dms.  So it must have the same number of elements as the
dms, len(scripts) == len(dms).</p>
</dd>
<dt>shls_slice<span class="classifier">8-element list</span></dt><dd><p>(ish_start, ish_end, jsh_start, jsh_end, ksh_start, ksh_end, lsh_start, lsh_end)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Depending on the number of density matrices, the function returns one
J/K matrix or a list of J/K matrices (the same number of entries as the
input dms).
Each JK matrices may be a 2D array or 3D array if the AO integral
has multiple components.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 -.5 0; H 0 .5 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nao</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">nao</span><span class="p">,</span><span class="n">nao</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Default, Coulomb matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vj</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Coulomb matrix with 8-fold permutation symmetry for AO integrals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vj</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="s1">&#39;ijkl,ji-&gt;kl&#39;</span><span class="p">,</span> <span class="n">aosym</span><span class="o">=</span><span class="s1">&#39;s8&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Exchange matrix with 8-fold permutation symmetry for AO integrals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vk</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="s1">&#39;ijkl,jk-&gt;il&#39;</span><span class="p">,</span> <span class="n">aosym</span><span class="o">=</span><span class="s1">&#39;s8&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute coulomb and exchange matrices together</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vj</span><span class="p">,</span> <span class="n">vk</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="p">(</span><span class="n">dm</span><span class="p">,</span><span class="n">dm</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;ijkl,ji-&gt;kl&#39;</span><span class="p">,</span><span class="s1">&#39;ijkl,li-&gt;kj&#39;</span><span class="p">),</span> <span class="n">aosym</span><span class="o">=</span><span class="s1">&#39;s8&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Analytical gradients for coulomb matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j1</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm</span><span class="p">,</span> <span class="s1">&#39;ijkl,lk-&gt;ij&#39;</span><span class="p">,</span> <span class="n">intor</span><span class="o">=</span><span class="s1">&#39;int2e_ip1_sph&#39;</span><span class="p">,</span> <span class="n">aosym</span><span class="o">=</span><span class="s1">&#39;s2kl&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># contraction across two molecules</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol1</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 2 0 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nao1</span> <span class="o">=</span> <span class="n">mol1</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">nao1</span><span class="p">,</span><span class="n">nao1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Coulomb interaction between two molecules, note 4-fold symmetry can be applied</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jcross</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">((</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol</span><span class="p">,</span><span class="n">mol</span><span class="p">),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">scripts</span><span class="o">=</span><span class="s1">&#39;ijkl,lk-&gt;ij&#39;</span><span class="p">,</span> <span class="n">aosym</span><span class="o">=</span><span class="s1">&#39;s4&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ecoul</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij&#39;</span><span class="p">,</span> <span class="n">jcross</span><span class="p">,</span> <span class="n">dm1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Exchange interaction between two molecules, no symmetry can be used</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kcross</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">((</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol</span><span class="p">,</span><span class="n">mol</span><span class="p">,</span><span class="n">mol1</span><span class="p">),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">scripts</span><span class="o">=</span><span class="s1">&#39;ijkl,jk-&gt;il&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ex</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ji&#39;</span><span class="p">,</span> <span class="n">kcross</span><span class="p">,</span> <span class="n">dm1</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Analytical gradients for coulomb matrix between two molecules</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jcros1</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">((</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol</span><span class="p">,</span><span class="n">mol</span><span class="p">),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">scripts</span><span class="o">=</span><span class="s1">&#39;ijkl,lk-&gt;ij&#39;</span><span class="p">,</span> <span class="n">intor</span><span class="o">=</span><span class="s1">&#39;int2e_ip1_sph&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Analytical gradients for coulomb interaction between 1s density and the other molecule</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jpart1</span> <span class="o">=</span> <span class="n">get_jk</span><span class="p">((</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol1</span><span class="p">,</span><span class="n">mol</span><span class="p">,</span><span class="n">mol</span><span class="p">),</span> <span class="n">dm</span><span class="p">,</span> <span class="n">scripts</span><span class="o">=</span><span class="s1">&#39;ijkl,lk-&gt;ij&#39;</span><span class="p">,</span> <span class="n">intor</span><span class="o">=</span><span class="s1">&#39;int2e_ip1_sph&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>                <span class="n">shls_slice</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nbas</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nbas</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-pyscf.scf.rohf">
<span id="pyscf-scf-rohf-module"></span><h2>pyscf.scf.rohf module<a class="headerlink" href="#module-pyscf.scf.rohf" title="Link to this heading">#</a></h2>
<p>Restricted Open-shell Hartree-Fock</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.rohf.HF1e">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">HF1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#HF1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.HF1e" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.rohf.ROHF" title="pyscf.scf.rohf.ROHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">ROHF</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.HF1e.scf">
<span class="sig-name descname"><span class="pre">scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.HF1e.scf" title="Link to this definition">#</a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">ROHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.hf.RHF" title="pyscf.scf.hf.RHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">RHF</span></code></a></p>
<p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.CASCI">
<span class="sig-name descname"><span class="pre">CASCI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.CASCI" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.CASSCF">
<span class="sig-name descname"><span class="pre">CASSCF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.CASSCF" title="Link to this definition">#</a></dt>
<dd><p>CASCI/CASSCF</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>mf_or_mol<span class="classifier">SCF object or Mole object</span></dt><dd><p>SCF or Mole to define the problem size.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Number of active orbitals.</p>
</dd>
<dt>nelecas<span class="classifier">int or a pair of int</span></dt><dd><p>Number of electrons in active space.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>ncore<span class="classifier">int</span></dt><dd><p>Number of doubly occupied core orbitals. If not presented, this
parameter can be automatically determined.</p>
</dd>
</dl>
</dd>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code>.</p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code>.</p>
</dd>
<dt>ncas<span class="classifier">int</span></dt><dd><p>Active space size.</p>
</dd>
<dt>nelecas<span class="classifier">tuple of int</span></dt><dd><p>Active (nelec_alpha, nelec_beta)</p>
</dd>
<dt>ncore<span class="classifier">int or tuple of int</span></dt><dd><p>Core electron number.  In UHF-CASSCF, it’s a tuple to indicate the different core electron numbers.</p>
</dd>
<dt>natorb<span class="classifier">bool</span></dt><dd><p>Whether to transform natural orbitals in active space.
Note: when CASCI/CASSCF are combined with DMRG solver or selected
CI solver, enabling this parameter may slightly change the total energy.
False by default.</p>
</dd>
<dt>canonicalization<span class="classifier">bool</span></dt><dd><p>Whether to canonicalize orbitals in core and external space
against the general Fock matrix.
The orbitals in active space are NOT transformed by default. To
get the natural orbitals in active space, the attribute .natorb
needs to be enabled.
True by default.</p>
</dd>
<dt>sorting_mo_energy<span class="classifier">bool</span></dt><dd><p>Whether to sort the orbitals based on the diagonal elements of the
general Fock matrix.  Default is False.</p>
</dd>
<dt>fcisolver<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">FCISolver</span></code></span></dt><dd><p>The pyscf.fci module provides several FCISolver for different scenario.  Generally,
fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
can provide better performance and better numerical stability.  One can either use
<code class="xref py py-func docutils literal notranslate"><span class="pre">fci.solver()</span></code> function to pick the FCISolver by the program or manually assigen
the FCISolver to this attribute, e.g.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">solver</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCISolver</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
</pre></div>
</div>
<p>You can control FCISolver by setting e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">max_cycle</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-7</span>
</pre></div>
</div>
<p>For more details of the parameter for FCISolver, See <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>e_cas<span class="classifier">float</span></dt><dd><p>CAS space FCI energy</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>When canonicalization is specified, the orbitals are canonical
orbitals which make the general Fock matrix (Fock operator on top
of MCSCF 1-particle density matrix) diagonalized within each
subspace (core, active, external).  If natorb (natural orbitals in
active space) is specified, the active segment of the mo_coeff is
natural orbitals.</p>
</dd>
<dt>mo_energy<span class="classifier">ndarray</span></dt><dd><p>Diagonal elements of general Fock matrix (in mo_coeff
representation).</p>
</dd>
<dt>mo_occ<span class="classifier">ndarray</span></dt><dd><p>Occupation numbers of natural orbitals if natorb is specified.</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-108.980200816243354</span>
</pre></div>
</div>
<p>Extra attributes for CASSCF:</p>
<blockquote>
<div><dl>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Converge threshold.  Default is 1e-7</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>Converge threshold for CI gradients and orbital rotation gradients.
If not specified, it is set to sqrt(conv_tol).</p>
</dd>
<dt>max_stepsize<span class="classifier">float</span></dt><dd><p>The step size for orbital rotation.  Small step (0.005 - 0.05) is prefered.
Default is 0.02.</p>
</dd>
<dt>max_cycle_macro<span class="classifier">int</span></dt><dd><p>Max number of macro iterations.  Default is 50.</p>
</dd>
<dt>max_cycle_micro<span class="classifier">int</span></dt><dd><p>Max number of micro iterations in each macro iteration.  Depending on
systems, increasing this value might reduce the total macro
iterations.  Generally, 2 - 5 steps should be enough.  Default is 4.</p>
</dd>
<dt>small_rot_tol<span class="classifier">float</span></dt><dd><p>Threshold for orbital rotation to be considered small. If the largest orbital
rotation is smaller than this value, the CI solver will restart from the
previous iteration if supported.
Default is 0.01</p>
</dd>
<dt>ah_level_shift<span class="classifier">float, for AH solver.</span></dt><dd><p>Level shift for the Davidson diagonalization in AH solver.  Default is 1e-8.</p>
</dd>
<dt>ah_conv_tol<span class="classifier">float, for AH solver.</span></dt><dd><p>converge threshold for AH solver.  Default is 1e-12.</p>
</dd>
<dt>ah_max_cycle<span class="classifier">float, for AH solver.</span></dt><dd><p>Max number of iterations allowd in AH solver.  Default is 30.</p>
</dd>
<dt>ah_lindep<span class="classifier">float, for AH solver.</span></dt><dd><p>Linear dependence threshold for AH solver.  Default is 1e-14.</p>
</dd>
<dt>ah_start_tol<span class="classifier">flat, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 2.5.</p>
</dd>
<dt>ah_start_cycle<span class="classifier">int, for AH solver.</span></dt><dd><p>In AH solver, the orbital rotation is started without completely solving the AH problem.
This value is to control the start point. Default is 3.</p>
<p><code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_max_cycle</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code>, <code class="docutils literal notranslate"><span class="pre">ah_start_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_start_cycle</span></code>
can affect the accuracy and performance of CASSCF solver.  Lower
<code class="docutils literal notranslate"><span class="pre">ah_conv_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">ah_lindep</span></code> might improve the accuracy of CASSCF
optimization, but decrease the performance.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401898486001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">ah_conv_tol</span> <span class="o">=</span> <span class="mf">1e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401887945668</span>
</pre></div>
</div>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>Checkpoint file to save the intermediate orbitals during the CASSCF optimization.
Default is the checkpoint file of mean field object.</p>
</dd>
<dt>ci_response_space<span class="classifier">int</span></dt><dd><p>subspace size to solve the CI vector response.  Default is 3.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>scale_restoration<span class="classifier">float</span></dt><dd><p>When a step of orbital rotation moves out of trust region, the
orbital optimization will be restored to previous state and the
step size of the orbital rotation needs to be reduced.
scale_restoration controls how much to scale down the step size.</p>
</dd>
</dl>
</div></blockquote>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total MCSCF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>e_cas<span class="classifier">float</span></dt><dd><p>CAS space FCI energy</p>
</dd>
<dt>ci<span class="classifier">ndarray</span></dt><dd><p>CAS space FCI coefficients</p>
</dd>
<dt>mo_coeff<span class="classifier">ndarray</span></dt><dd><p>Optimized CASSCF orbitals coefficients. When canonicalization is
specified, the returned orbitals make the general Fock matrix
(Fock operator on top of MCSCF 1-particle density matrix)
diagonalized within each subspace (core, active, external). If
natorb (natural orbitals in active space) is enabled, the active
segment of mo_coeff is transformed to natural orbitals.</p>
</dd>
<dt>mo_energy<span class="classifier">ndarray</span></dt><dd><p>Diagonal elements of general Fock matrix (in mo_coeff
representation).</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">-109.044401882238134</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.CISD">
<span class="sig-name descname"><span class="pre">CISD</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.rohf.ROHF.CISD" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.DFMP2">
<span class="sig-name descname"><span class="pre">DFMP2</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.rohf.ROHF.DFMP2" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.Gradients">
<span class="sig-name descname"><span class="pre">Gradients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.Gradients" title="Link to this definition">#</a></dt>
<dd><p>Non-relativistic restricted open-shell Hartree-Fock gradients</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.MP2">
<span class="sig-name descname"><span class="pre">MP2</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.rohf.ROHF.MP2" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.TDA">
<span class="sig-name descname"><span class="pre">TDA</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.rohf.ROHF.TDA" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.TDHF">
<span class="sig-name descname"><span class="pre">TDHF</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.rohf.ROHF.TDHF" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.analyze">
<span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.canonicalize">
<span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.canonicalize" title="Link to this definition">#</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix within occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.check_sanity">
<span class="sig-name descname"><span class="pre">check_sanity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.check_sanity" title="Link to this definition">#</a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.convert_from_">
<span class="sig-name descname"><span class="pre">convert_from_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.convert_from_" title="Link to this definition">#</a></dt>
<dd><p>Convert the input mean-field object to RHF/ROHF</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.dump_flags">
<span class="sig-name descname"><span class="pre">dump_flags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.dump_flags"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.dump_flags" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.eig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.eig" title="Link to this definition">#</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.energy_elec">
<span class="sig-name descname"><span class="pre">energy_elec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.energy_elec" title="Link to this definition">#</a></dt>
<dd><p>Electronic part of Hartree-Fock energy, for given core hamiltonian and
HF potential</p>
<p>… math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> \<span class="n">sum_</span><span class="p">{</span><span class="n">ij</span><span class="p">}</span><span class="n">h_</span><span class="p">{</span><span class="n">ij</span><span class="p">}</span> \<span class="n">gamma_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span>
  <span class="o">+</span> \<span class="n">frac</span><span class="p">{</span><span class="mi">1</span><span class="p">}{</span><span class="mi">2</span><span class="p">}</span>\<span class="n">sum_</span><span class="p">{</span><span class="n">ijkl</span><span class="p">}</span> \<span class="n">gamma_</span><span class="p">{</span><span class="n">ji</span><span class="p">}</span>\<span class="n">gamma_</span><span class="p">{</span><span class="n">lk</span><span class="p">}</span> \<span class="n">langle</span> <span class="n">ik</span><span class="o">||</span><span class="n">jl</span>\<span class="n">rangle</span>
</pre></div>
</div>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mf : an instance of SCF class</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm<span class="classifier">2D ndarray</span></dt><dd><p>one-particle density matrix</p>
</dd>
<dt>h1e<span class="classifier">2D ndarray</span></dt><dd><p>Core hamiltonian</p>
</dd>
<dt>vhf<span class="classifier">2D ndarray</span></dt><dd><p>HF potential</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Hartree-Fock electronic energy and the Coulomb energy</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.gen_response">
<span class="sig-name descname"><span class="pre">gen_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_j</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.gen_response" title="Link to this definition">#</a></dt>
<dd><p>Generate a function to compute the product of UHF response function and
UHF density matrices.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.get_fock">
<span class="sig-name descname"><span class="pre">get_fock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis_start_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damp_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.get_fock" title="Link to this definition">#</a></dt>
<dd><p>Build fock matrix based on Roothaan’s effective fock.
See also <a class="reference internal" href="#pyscf.scf.rohf.get_roothaan_fock" title="pyscf.scf.rohf.get_roothaan_fock"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_roothaan_fock()</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.get_grad">
<span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.get_grad" title="Link to this definition">#</a></dt>
<dd><p>ROHF gradients is the off-diagonal block [co + cv + ov], where
[ cc co cv ]
[ oc oo ov ]
[ vc vo vv ]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.get_init_guess">
<span class="sig-name descname"><span class="pre">get_init_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'minao'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.get_init_guess" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.get_occ">
<span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.get_occ" title="Link to this definition">#</a></dt>
<dd><p>Label the occupancies for each orbital.
NOTE the occupancies are not assigned based on the orbital energy ordering.
The first N orbitals are assigned to be occupied orbitals.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; O 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 2, 2, 1, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.get_veff">
<span class="sig-name descname"><span class="pre">get_veff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.get_veff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.get_veff" title="Link to this definition">#</a></dt>
<dd><p>Unrestricted Hartree-Fock potential matrix of alpha and beta spins,
for the given density matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}V_{ij}^\alpha &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\alpha \\
V_{ij}^\beta  &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\beta\end{split}\]</div>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">a list of ndarrays</span></dt><dd><p>A list of density matrices, stored as (alpha,alpha,…,beta,beta,…)</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>dm_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The density matrix baseline.  When it is not 0, this function computes
the increment of HF potential w.r.t. the reference HF potential matrix.</p>
</dd>
<dt>vhf_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The reference HF potential matrix.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p><span class="math notranslate nohighlight">\(V_{hf} = (V^\alpha, V^\beta)\)</span>.  <span class="math notranslate nohighlight">\(V^\alpha\)</span> (and <span class="math notranslate nohighlight">\(V^\beta\)</span>)
can be a list matrices, corresponding to the input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dmsa</span><span class="p">,</span><span class="n">dmsb</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="p">,</span> <span class="n">vhfb</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">uhf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfb</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.init_guess_by_1e">
<span class="sig-name descname"><span class="pre">init_guess_by_1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.init_guess_by_1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.init_guess_by_1e" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.init_guess_by_atom">
<span class="sig-name descname"><span class="pre">init_guess_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.init_guess_by_atom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.init_guess_by_atom" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.init_guess_by_chkfile">
<span class="sig-name descname"><span class="pre">init_guess_by_chkfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.init_guess_by_chkfile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.init_guess_by_chkfile" title="Link to this definition">#</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.init_guess_by_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.init_guess_by_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.init_guess_by_huckel" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.init_guess_by_minao">
<span class="sig-name descname"><span class="pre">init_guess_by_minao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.init_guess_by_minao"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.init_guess_by_minao" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix based on ANO basis, then project
the density matrix to the basis set defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">init_guess_by_minao</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">array([[ 0.94758917,  0.09227308],</span>
<span class="go">       [ 0.09227308,  0.94758917]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.init_guess_by_mod_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_mod_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.init_guess_by_mod_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.init_guess_by_mod_huckel" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<p>In contrast to init_guess_by_huckel, this routine employs the
updated GWH rule from doi:10.1021/ja00480a005 to form the guess.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.init_guess_by_sap">
<span class="sig-name descname"><span class="pre">init_guess_by_sap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.init_guess_by_sap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.init_guess_by_sap" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a superposition of
atomic potentials (SAP), doi:10.1021/acs.jctc.8b01089.
This is the Gaussian fit implementation, see doi:10.1063/5.0004046.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mol<span class="classifier">MoleBase object</span></dt><dd><p>the molecule object for which the initial guess is evaluated</p>
</dd>
<dt>sap_basis<span class="classifier">dict</span></dt><dd><p>SAP basis in internal format (python dictionary)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>SAP initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.make_rdm1">
<span class="sig-name descname"><span class="pre">make_rdm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.make_rdm1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.make_rdm1" title="Link to this definition">#</a></dt>
<dd><p>One-particle density matrix.  mo_occ is a 1D array, with occupancy 1 or 2.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.nelec">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelec</span></span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.nelec" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.nelectron_alpha">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelectron_alpha</span></span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.nelectron_alpha" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.nuc_grad_method">
<span class="sig-name descname"><span class="pre">nuc_grad_method</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.nuc_grad_method"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.nuc_grad_method" title="Link to this definition">#</a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.spin_square">
<span class="sig-name descname"><span class="pre">spin_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.spin_square"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.spin_square" title="Link to this definition">#</a></dt>
<dd><p>Spin square and multiplicity of RHF determinant</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.stability">
<span class="sig-name descname"><span class="pre">stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">internal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.stability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.stability" title="Link to this definition">#</a></dt>
<dd><p>ROHF/ROKS stability analysis.</p>
<p>See also pyscf.scf.stability.rohf_stability function.</p>
<dl>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the RHF optimization space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. It is not available in current version.</p>
</dd>
<dt>return_status: bool</dt><dd><p>Whether to return <cite>stable_i</cite> and <cite>stable_e</cite></p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>If return_status is False (default), the return value includes
two set of orbitals, which are more close to the stable condition.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
<p>Else, another two boolean variables (indicating current status:
stable or unstable) are returned.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.to_gpu">
<span class="sig-name descname"><span class="pre">to_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.rohf.ROHF.to_gpu" title="Link to this definition">#</a></dt>
<dd><p>Convert a method to its corresponding GPU variant, and recursively
converts all attributes of a method to cupy objects or gpu4pyscf objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.rohf.ROHF.to_ks">
<span class="sig-name descname"><span class="pre">to_ks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#ROHF.to_ks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.ROHF.to_ks" title="Link to this definition">#</a></dt>
<dd><p>Convert to ROKS object.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.rohf.analyze">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.rohf.canonicalize">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#canonicalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.canonicalize" title="Link to this definition">#</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix within occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.rohf.energy_elec">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">energy_elec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#energy_elec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.energy_elec" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.rohf.get_fock">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">get_fock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis_start_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damp_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#get_fock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.get_fock" title="Link to this definition">#</a></dt>
<dd><p>Build fock matrix based on Roothaan’s effective fock.
See also <a class="reference internal" href="#pyscf.scf.rohf.get_roothaan_fock" title="pyscf.scf.rohf.get_roothaan_fock"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_roothaan_fock()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.rohf.get_grad">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.get_grad" title="Link to this definition">#</a></dt>
<dd><p>ROHF gradients is the off-diagonal block [co + cv + ov], where
[ cc co cv ]
[ oc oo ov ]
[ vc vo vv ]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.rohf.get_occ">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#get_occ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.get_occ" title="Link to this definition">#</a></dt>
<dd><p>Label the occupancies for each orbital.
NOTE the occupancies are not assigned based on the orbital energy ordering.
The first N orbitals are assigned to be occupied orbitals.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; O 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 2, 2, 1, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.rohf.get_roothaan_fock">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">get_roothaan_fock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">focka_fockb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dma_dmb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#get_roothaan_fock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.get_roothaan_fock" title="Link to this definition">#</a></dt>
<dd><p>Roothaan’s effective fock.
Ref. <a class="reference external" href="http://www-theor.ch.cam.ac.uk/people/ross/thesis/node15.html">http://www-theor.ch.cam.ac.uk/people/ross/thesis/node15.html</a></p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>space</p></th>
<th class="head"><p>closed</p></th>
<th class="head"><p>open</p></th>
<th class="head"><p>virtual</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>closed</p></td>
<td><p>Fc</p></td>
<td><p>Fb</p></td>
<td><p>Fc</p></td>
</tr>
<tr class="row-odd"><td><p>open</p></td>
<td><p>Fb</p></td>
<td><p>Fc</p></td>
<td><p>Fa</p></td>
</tr>
<tr class="row-even"><td><p>virtual</p></td>
<td><p>Fc</p></td>
<td><p>Fa</p></td>
<td><p>Fc</p></td>
</tr>
</tbody>
</table>
</div>
<p>where Fc = (Fa + Fb) / 2</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Roothaan effective Fock matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.rohf.init_guess_by_atom">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#init_guess_by_atom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.init_guess_by_atom" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.rohf.init_guess_by_chkfile">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_chkfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chkfile_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#init_guess_by_chkfile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.init_guess_by_chkfile" title="Link to this definition">#</a></dt>
<dd><p>Read SCF chkfile and make the density matrix for ROHF initial guess.</p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.rohf.init_guess_by_minao">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_minao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#init_guess_by_minao"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.init_guess_by_minao" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.rohf.init_guess_by_sap">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_sap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sap_basis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#init_guess_by_sap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.init_guess_by_sap" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.rohf.make_rdm1">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.rohf.</span></span><span class="sig-name descname"><span class="pre">make_rdm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/rohf.html#make_rdm1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.rohf.make_rdm1" title="Link to this definition">#</a></dt>
<dd><p>One-particle density matrix.  mo_occ is a 1D array, with occupancy 1 or 2.</p>
</dd></dl>

</section>
<section id="module-pyscf.scf.stability">
<span id="pyscf-scf-stability-module"></span><h2>pyscf.scf.stability module<a class="headerlink" href="#module-pyscf.scf.stability" title="Link to this heading">#</a></h2>
<p>Wave Function Stability Analysis</p>
<p>Ref.
JCP 66, 3045 (1977); DOI:10.1063/1.434318
JCP 104, 9047 (1996); DOI:10.1063/1.471637</p>
<p>See also tddft/rhf.py and scf/newton_ah.py</p>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability.dhf_stability">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability.</span></span><span class="sig-name descname"><span class="pre">dhf_stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nroots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability.html#dhf_stability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability.dhf_stability" title="Link to this definition">#</a></dt>
<dd><p>Stability analysis for DHF/DKS method.</p>
<dl>
<dt>Args:</dt><dd><p>mf : DHF or DKS object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>return_status: bool</dt><dd><p>Whether to return <cite>stable_i</cite> and <cite>stable_e</cite></p>
</dd>
<dt>nroots<span class="classifier">int</span></dt><dd><p>Number of roots solved by Davidson solver</p>
</dd>
<dt>tol<span class="classifier">float</span></dt><dd><p>Convergence threshold for Davidson solver</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>If return_status is False (default), the return value includes
a new set of orbitals, which are more close to the stable condition.</p>
<p>Else, another one boolean variable (indicating current status:
stable or unstable) is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability.dump_status">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability.</span></span><span class="sig-name descname"><span class="pre">dump_status</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">log</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_class</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stab_type</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability.html#dump_status"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability.dump_status" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability.ghf_stability">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability.</span></span><span class="sig-name descname"><span class="pre">ghf_stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nroots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability.html#ghf_stability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability.ghf_stability" title="Link to this definition">#</a></dt>
<dd><p>Stability analysis for GHF/GKS method.</p>
<dl>
<dt>Args:</dt><dd><p>mf : GHF or GKS object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>return_status: bool</dt><dd><p>Whether to return <cite>stable_i</cite> and <cite>stable_e</cite></p>
</dd>
<dt>nroots<span class="classifier">int</span></dt><dd><p>Number of roots solved by Davidson solver</p>
</dd>
<dt>tol<span class="classifier">float</span></dt><dd><p>Convergence threshold for Davidson solver</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>If return_status is False (default), the return value includes
a new set of orbitals, which are more close to the stable condition.</p>
<p>Else, another one boolean variable (indicating current status:
stable or unstable) is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability.rhf_external">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability.</span></span><span class="sig-name descname"><span class="pre">rhf_external</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nroots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability.html#rhf_external"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability.rhf_external" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability.rhf_internal">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability.</span></span><span class="sig-name descname"><span class="pre">rhf_internal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nroots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability.html#rhf_internal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability.rhf_internal" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability.rhf_stability">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability.</span></span><span class="sig-name descname"><span class="pre">rhf_stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nroots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability.html#rhf_stability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability.rhf_stability" title="Link to this definition">#</a></dt>
<dd><p>Stability analysis for RHF/RKS method.</p>
<dl>
<dt>Args:</dt><dd><p>mf : RHF or RKS object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the RHF space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. Including the RHF -&gt; UHF and real -&gt; complex
stability analysis.</p>
</dd>
<dt>return_status: bool</dt><dd><p>Whether to return <cite>stable_i</cite> and <cite>stable_e</cite></p>
</dd>
<dt>nroots<span class="classifier">int</span></dt><dd><p>Number of roots solved by Davidson solver</p>
</dd>
<dt>tol<span class="classifier">float</span></dt><dd><p>Convergence threshold for Davidson solver</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>If return_status is False (default), the return value includes
two set of orbitals, which are more close to the stable condition.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
<p>Else, another two boolean variables (indicating current status:
stable or unstable) are returned.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability.rohf_external">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability.</span></span><span class="sig-name descname"><span class="pre">rohf_external</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nroots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability.html#rohf_external"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability.rohf_external" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability.rohf_internal">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability.</span></span><span class="sig-name descname"><span class="pre">rohf_internal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nroots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability.html#rohf_internal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability.rohf_internal" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability.rohf_stability">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability.</span></span><span class="sig-name descname"><span class="pre">rohf_stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nroots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability.html#rohf_stability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability.rohf_stability" title="Link to this definition">#</a></dt>
<dd><p>Stability analysis for ROHF/ROKS method.</p>
<dl>
<dt>Args:</dt><dd><p>mf : ROHF or ROKS object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the RHF space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. It is not available in current version.</p>
</dd>
<dt>return_status: bool</dt><dd><p>Whether to return <cite>stable_i</cite> and <cite>stable_e</cite></p>
</dd>
<dt>nroots<span class="classifier">int</span></dt><dd><p>Number of roots solved by Davidson solver</p>
</dd>
<dt>tol<span class="classifier">float</span></dt><dd><p>Convergence threshold for Davidson solver</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>If return_status is False (default), the return value includes
two set of orbitals, which are more close to the stable condition.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
<p>Else, another two boolean variables (indicating current status:
stable or unstable) are returned.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability.uhf_external">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability.</span></span><span class="sig-name descname"><span class="pre">uhf_external</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nroots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability.html#uhf_external"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability.uhf_external" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability.uhf_internal">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability.</span></span><span class="sig-name descname"><span class="pre">uhf_internal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nroots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability.html#uhf_internal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability.uhf_internal" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability.uhf_stability">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability.</span></span><span class="sig-name descname"><span class="pre">uhf_stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nroots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability.html#uhf_stability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability.uhf_stability" title="Link to this definition">#</a></dt>
<dd><p>Stability analysis for UHF/UKS method.</p>
<dl>
<dt>Args:</dt><dd><p>mf : UHF or UKS object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the UHF space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. Including the UHF -&gt; GHF and real -&gt; complex
stability analysis.</p>
</dd>
<dt>return_status: bool</dt><dd><p>Whether to return <cite>stable_i</cite> and <cite>stable_e</cite></p>
</dd>
<dt>nroots<span class="classifier">int</span></dt><dd><p>Number of roots solved by Davidson solver</p>
</dd>
<dt>tol<span class="classifier">float</span></dt><dd><p>Convergence threshold for Davidson solver</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>If return_status is False (default), the return value includes
two set of orbitals, which are more close to the stable condition.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
<p>Else, another two boolean variables (indicating current status:
stable or unstable) are returned.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pyscf.scf.stability_slow">
<span id="pyscf-scf-stability-slow-module"></span><h2>pyscf.scf.stability_slow module<a class="headerlink" href="#module-pyscf.scf.stability_slow" title="Link to this heading">#</a></h2>
<p>Wave Function Stability Analysis</p>
<p>Ref.
JCP, 66, 3045 (1977); DOI:10.1063/1.434318
JCP 104, 9047 (1996); DOI:10.1063/1.471637</p>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability_slow.rhf_external">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability_slow.</span></span><span class="sig-name descname"><span class="pre">rhf_external</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability_slow.html#rhf_external"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability_slow.rhf_external" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability_slow.rhf_internal">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability_slow.</span></span><span class="sig-name descname"><span class="pre">rhf_internal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability_slow.html#rhf_internal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability_slow.rhf_internal" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability_slow.rhf_stability">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability_slow.</span></span><span class="sig-name descname"><span class="pre">rhf_stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability_slow.html#rhf_stability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability_slow.rhf_stability" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability_slow.uhf_external">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability_slow.</span></span><span class="sig-name descname"><span class="pre">uhf_external</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability_slow.html#uhf_external"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability_slow.uhf_external" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability_slow.uhf_internal">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability_slow.</span></span><span class="sig-name descname"><span class="pre">uhf_internal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability_slow.html#uhf_internal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability_slow.uhf_internal" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.stability_slow.uhf_stability">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.stability_slow.</span></span><span class="sig-name descname"><span class="pre">uhf_stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/stability_slow.html#uhf_stability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.stability_slow.uhf_stability" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="module-pyscf.scf.ucphf">
<span id="pyscf-scf-ucphf-module"></span><h2>pyscf.scf.ucphf module<a class="headerlink" href="#module-pyscf.scf.ucphf" title="Link to this heading">#</a></h2>
<p>Unrestricted coupled perturbed Hartree-Fock solver</p>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ucphf.kernel">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ucphf.</span></span><span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fvind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.ucphf.kernel" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>fvind<span class="classifier">function</span></dt><dd><p>Given density matrix, compute (ij|kl)D_{lk}*2 - (ij|kl)D_{jk}</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ucphf.solve">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ucphf.</span></span><span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fvind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ucphf.html#solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ucphf.solve" title="Link to this definition">#</a></dt>
<dd><dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>fvind<span class="classifier">function</span></dt><dd><p>Given density matrix, compute (ij|kl)D_{lk}*2 - (ij|kl)D_{jk}</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ucphf.solve_nos1">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ucphf.</span></span><span class="sig-name descname"><span class="pre">solve_nos1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fvind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ucphf.html#solve_nos1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ucphf.solve_nos1" title="Link to this definition">#</a></dt>
<dd><p>For field independent basis. First order overlap matrix is zero</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ucphf.solve_withs1">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.ucphf.</span></span><span class="sig-name descname"><span class="pre">solve_withs1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fvind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-09</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/ucphf.html#solve_withs1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ucphf.solve_withs1" title="Link to this definition">#</a></dt>
<dd><p>For field dependent basis. First order overlap matrix is non-zero.
The first order orbitals are set to
C^1_{ij} = -1/2 S1
e1 = h1 - s1*e0 + (e0_j-e0_i)*c1 + vhf[c1]</p>
</dd></dl>

</section>
<section id="module-pyscf.scf.uhf">
<span id="pyscf-scf-uhf-module"></span><h2>pyscf.scf.uhf module<a class="headerlink" href="#module-pyscf.scf.uhf" title="Link to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.uhf.HF1e">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">HF1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#HF1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.HF1e" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.uhf.UHF" title="pyscf.scf.uhf.UHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">UHF</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.HF1e.scf">
<span class="sig-name descname"><span class="pre">scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.HF1e.scf" title="Link to this definition">#</a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.HF1e.spin_square">
<span class="sig-name descname"><span class="pre">spin_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#HF1e.spin_square"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.HF1e.spin_square" title="Link to this definition">#</a></dt>
<dd><p>Spin square and multiplicity of UHF determinant</p>
<div class="math notranslate nohighlight">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math notranslate nohighlight">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math notranslate nohighlight">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl>
<dt>There are two possibilities for <span class="math notranslate nohighlight">\(S_+ S_-\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron <span class="math notranslate nohighlight">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math notranslate nohighlight">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math notranslate nohighlight">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="math notranslate nohighlight">
\[\langle S_+ S_- \rangle = \langle ij|s_+ s_-|ij\rangle
                        - \langle ij|s_+ s_-|ji\rangle
                        = -\langle i^\alpha|j^\beta\rangle
                           \langle j^\beta|i^\alpha\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Similarly, for <span class="math notranslate nohighlight">\(S_- S_+\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle S_- S_+ \rangle = -\langle i^\beta|j^\alpha\rangle
                           \langle j^\alpha|i^\beta\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>For <span class="math notranslate nohighlight">\(S_z^2\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}&amp;\frac{1}{2}\sum_{ij}(\langle ij|2s_{z1}s_{z2}|ij\rangle
                     -\langle ij|2s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}(n_\alpha^2 - n_\alpha n_\beta - n_\beta n_\alpha + n_\beta^2)
 -\frac{1}{4}(n_\alpha + n_\beta) \\
&amp;=\frac{1}{4}((n_\alpha-n_\beta)^2 - (n_\alpha+n_\beta))\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<p>In total</p>
<div class="math notranslate nohighlight">
\[\begin{split}\langle S^2\rangle &amp;= \frac{1}{2}
(n_\alpha-\sum_{ij}\langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle
+n_\beta -\sum_{ij}\langle i^\beta|j^\alpha\rangle\langle j^\alpha|i^\beta\rangle)
+ \frac{1}{4}(n_\alpha-n_\beta)^2 \\\end{split}\]</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo<span class="classifier">a list of 2 ndarrays</span></dt><dd><p>Occupied alpha and occupied beta orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>s<span class="classifier">ndarray</span></dt><dd><p>AO overlap</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">UHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.hf.SCF" title="pyscf.scf.hf.SCF"><code class="xref py py-class docutils literal notranslate"><span class="pre">SCF</span></code></a></p>
<p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="simple">
<dt>Attributes for UHF:</dt><dd><dl class="simple">
<dt>nelec<span class="classifier">(int, int)</span></dt><dd><p>If given, freeze the number of (alpha,beta) electrons to the given value.</p>
</dd>
<dt>level_shift<span class="classifier">number or two-element list</span></dt><dd><p>level shift (in Eh) for alpha and beta Fock if two-element list is given.</p>
</dd>
<dt>init_guess_breaksym<span class="classifier">int</span></dt><dd><p>This configuration controls the algorithm used to break the spin
symmetry of the initial guess:
- 0 to disable symmetry breaking in the initial guess.
- 1 to use the default algorithm introduced in pyscf-1.7.
- 2 to adjust the num. electrons for spin-up and spin-down density matrices (issue #1839).</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mf</span><span class="o">.</span><span class="n">spin_square</span><span class="p">())</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.CASCI">
<span class="sig-name descname"><span class="pre">CASCI</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.uhf.UHF.CASCI" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.CASSCF">
<span class="sig-name descname"><span class="pre">CASSCF</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.uhf.UHF.CASSCF" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.CISD">
<span class="sig-name descname"><span class="pre">CISD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.CISD" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.DFMP2">
<span class="sig-name descname"><span class="pre">DFMP2</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.uhf.UHF.DFMP2" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.Gradients">
<span class="sig-name descname"><span class="pre">Gradients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.Gradients" title="Link to this definition">#</a></dt>
<dd><p>Non-relativistic unrestricted Hartree-Fock gradients</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.MP2">
<span class="sig-name descname"><span class="pre">MP2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.MP2" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.TDA">
<span class="sig-name descname"><span class="pre">TDA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.TDA" title="Link to this definition">#</a></dt>
<dd><p>Tamm-Dancoff approximation</p>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Diagonalization convergence tolerance.  Default is 1e-9.</p>
</dd>
<dt>nstates<span class="classifier">int</span></dt><dd><p>Number of TD states to be computed. Default is 3.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Diagonalization converged or not</p>
</dd>
<dt>e<span class="classifier">1D array</span></dt><dd><p>excitation energy for each excited state.</p>
</dd>
<dt>xy<span class="classifier">A list of two 2D arrays</span></dt><dd><p>The two 2D arrays are Excitation coefficients X (shape [nocc,nvir])
and de-excitation coefficients Y (shape [nocc,nvir]) for each
excited state.  (X,Y) are normalized to 1/2 in RHF/RKS methods and
normalized to 1 for UHF/UKS methods. In the TDA calculation, Y = 0.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.TDHF">
<span class="sig-name descname"><span class="pre">TDHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.TDHF" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.analyze">
<span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.canonicalize">
<span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.canonicalize" title="Link to this definition">#</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.convert_from_">
<span class="sig-name descname"><span class="pre">convert_from_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.convert_from_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.convert_from_" title="Link to this definition">#</a></dt>
<dd><p>Create UHF object based on the RHF/ROHF object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.det_ovlp">
<span class="sig-name descname"><span class="pre">det_ovlp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ovlp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.det_ovlp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.det_ovlp" title="Link to this definition">#</a></dt>
<dd><p>Calculate the overlap between two different determinants. It is the product
of single values of molecular orbital overlap matrix.</p>
<div class="math notranslate nohighlight">
\[S_{12} = \langle \Psi_A | \Psi_B \rangle
= (\mathrm{det}\mathbf{U}) (\mathrm{det}\mathbf{V^\dagger})
  \prod\limits_{i=1}\limits^{2N} \lambda_{ii}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{U}, \mathbf{V}, \lambda\)</span> are unitary matrices and single
values generated by single value decomposition(SVD) of the overlap matrix
<span class="math notranslate nohighlight">\(\mathbf{O}\)</span> which is the overlap matrix of two sets of molecular orbitals:</p>
<div class="math notranslate nohighlight">
\[\mathbf{U}^\dagger \mathbf{O} \mathbf{V} = \mathbf{\Lambda}\]</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo1, mo2<span class="classifier">2D ndarrays</span></dt><dd><p>Molecualr orbital coefficients</p>
</dd>
<dt>occ1, occ2: 2D ndarrays</dt><dd><p>occupation numbers</p>
</dd>
</dl>
</dd>
<dt>Return:</dt><dd><dl class="simple">
<dt>A list:</dt><dd><p>the product of single values: float
(x_a, x_b): 1D ndarrays
<span class="math notranslate nohighlight">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>
They are used to calculate asymmetric density matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.dump_flags">
<span class="sig-name descname"><span class="pre">dump_flags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.dump_flags"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.dump_flags" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.eig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.eig" title="Link to this definition">#</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.energy_elec">
<span class="sig-name descname"><span class="pre">energy_elec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.energy_elec" title="Link to this definition">#</a></dt>
<dd><p>Electronic energy of Unrestricted Hartree-Fock</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Hartree-Fock electronic energy and the 2-electron part contribution</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.gen_response">
<span class="sig-name descname"><span class="pre">gen_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_j</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.gen_response" title="Link to this definition">#</a></dt>
<dd><p>Generate a function to compute the product of UHF response function and
UHF density matrices.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.get_fock">
<span class="sig-name descname"><span class="pre">get_fock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis_start_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damp_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.get_fock" title="Link to this definition">#</a></dt>
<dd><p>F = h^{core} + V^{HF}</p>
<p>Special treatment (damping, DIIS, or level shift) will be applied to the
Fock matrix if diis and cycle is specified (The two parameters are passed
to get_fock function during the SCF iteration)</p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>h1e<span class="classifier">2D ndarray</span></dt><dd><p>Core hamiltonian</p>
</dd>
<dt>s1e<span class="classifier">2D ndarray</span></dt><dd><p>Overlap matrix, for DIIS</p>
</dd>
<dt>vhf<span class="classifier">2D ndarray</span></dt><dd><p>HF potential matrix</p>
</dd>
<dt>dm<span class="classifier">2D ndarray</span></dt><dd><p>Density matrix, for DIIS</p>
</dd>
<dt>cycle<span class="classifier">int</span></dt><dd><p>Then present SCF iteration step, for DIIS</p>
</dd>
<dt>diis<span class="classifier">an object of <code class="xref py py-attr docutils literal notranslate"><span class="pre">SCF.DIIS</span></code> class</span></dt><dd><p>DIIS object to hold intermediate Fock and error vectors</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 0.</p>
</dd>
<dt>level_shift_factor<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.get_grad">
<span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.get_grad" title="Link to this definition">#</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Orbital occupancy</p>
</dd>
<dt>fock_ao<span class="classifier">2D ndarray</span></dt><dd><p>Fock matrix in AO representation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.get_init_guess">
<span class="sig-name descname"><span class="pre">get_init_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'minao'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.get_init_guess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.get_init_guess" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.get_jk">
<span class="sig-name descname"><span class="pre">get_jk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_j</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.get_jk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.get_jk" title="Link to this definition">#</a></dt>
<dd><p>Coulomb (J) and exchange (K)</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>dm<span class="classifier">a list of 2D arrays or a list of 3D arrays</span></dt><dd><p>(alpha_dm, beta_dm) or (alpha_dms, beta_dms)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.get_occ">
<span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.get_occ" title="Link to this definition">#</a></dt>
<dd><p>Label the occupancies for each orbital</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">1D ndarray</span></dt><dd><p>Obital energies</p>
</dd>
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 0, 2, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.get_veff">
<span class="sig-name descname"><span class="pre">get_veff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.get_veff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.get_veff" title="Link to this definition">#</a></dt>
<dd><p>Unrestricted Hartree-Fock potential matrix of alpha and beta spins,
for the given density matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}V_{ij}^\alpha &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\alpha \\
V_{ij}^\beta  &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\beta\end{split}\]</div>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">a list of ndarrays</span></dt><dd><p>A list of density matrices, stored as (alpha,alpha,…,beta,beta,…)</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>dm_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The density matrix baseline.  When it is not 0, this function computes
the increment of HF potential w.r.t. the reference HF potential matrix.</p>
</dd>
<dt>vhf_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The reference HF potential matrix.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p><span class="math notranslate nohighlight">\(V_{hf} = (V^\alpha, V^\beta)\)</span>.  <span class="math notranslate nohighlight">\(V^\alpha\)</span> (and <span class="math notranslate nohighlight">\(V^\beta\)</span>)
can be a list matrices, corresponding to the input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dmsa</span><span class="p">,</span><span class="n">dmsb</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="p">,</span> <span class="n">vhfb</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">uhf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfb</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.init_guess_breaksym">
<span class="sig-name descname"><span class="pre">init_guess_breaksym</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#pyscf.scf.uhf.UHF.init_guess_breaksym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.init_guess_by_1e">
<span class="sig-name descname"><span class="pre">init_guess_by_1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.init_guess_by_1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.init_guess_by_1e" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.init_guess_by_atom">
<span class="sig-name descname"><span class="pre">init_guess_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.init_guess_by_atom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.init_guess_by_atom" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.init_guess_by_chkfile">
<span class="sig-name descname"><span class="pre">init_guess_by_chkfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.init_guess_by_chkfile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.init_guess_by_chkfile" title="Link to this definition">#</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.init_guess_by_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.init_guess_by_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.init_guess_by_huckel" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.init_guess_by_minao">
<span class="sig-name descname"><span class="pre">init_guess_by_minao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.init_guess_by_minao"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.init_guess_by_minao" title="Link to this definition">#</a></dt>
<dd><p>Initial guess in terms of the overlap to minimal basis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.init_guess_by_mod_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_mod_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.init_guess_by_mod_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.init_guess_by_mod_huckel" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<p>In contrast to init_guess_by_huckel, this routine employs the
updated GWH rule from doi:10.1021/ja00480a005 to form the guess.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.init_guess_by_sap">
<span class="sig-name descname"><span class="pre">init_guess_by_sap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.init_guess_by_sap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.init_guess_by_sap" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix from a superposition of
atomic potentials (SAP), doi:10.1021/acs.jctc.8b01089.
This is the Gaussian fit implementation, see doi:10.1063/5.0004046.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mol<span class="classifier">MoleBase object</span></dt><dd><p>the molecule object for which the initial guess is evaluated</p>
</dd>
<dt>sap_basis<span class="classifier">dict</span></dt><dd><p>SAP basis in internal format (python dictionary)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>SAP initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.make_asym_dm">
<span class="sig-name descname"><span class="pre">make_asym_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.make_asym_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.make_asym_dm" title="Link to this definition">#</a></dt>
<dd><p>One-particle asymmetric density matrix</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo1, mo2<span class="classifier">2D ndarrays</span></dt><dd><p>Molecualr orbital coefficients</p>
</dd>
<dt>occ1, occ2: 2D ndarrays</dt><dd><p>Occupation numbers</p>
</dd>
<dt>x: 2D ndarrays</dt><dd><p><span class="math notranslate nohighlight">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>.
See also <a class="reference internal" href="#pyscf.scf.uhf.det_ovlp" title="pyscf.scf.uhf.det_ovlp"><code class="xref py py-func docutils literal notranslate"><span class="pre">det_ovlp()</span></code></a></p>
</dd>
</dl>
</dd>
<dt>Return:</dt><dd><p>A list of 2D ndarrays for alpha and beta spin</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.3&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.4&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">intor_cross</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">det</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">det_ovlp</span><span class="p">(</span><span class="n">mf1</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adm</span> <span class="o">=</span> <span class="n">make_asym_dm</span><span class="p">(</span><span class="n">mf1</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adm</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 19, 19)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.make_rdm1">
<span class="sig-name descname"><span class="pre">make_rdm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.make_rdm1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.make_rdm1" title="Link to this definition">#</a></dt>
<dd><p>One-particle density matrix in AO representation</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">tuple of 2D ndarrays</span></dt><dd><p>Orbital coefficients for alpha and beta spins. Each column is one orbital.</p>
</dd>
<dt>mo_occ<span class="classifier">tuple of 1D ndarrays</span></dt><dd><p>Occupancies for alpha and beta spins.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list of 2D ndarrays for alpha and beta spins</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.make_rdm2">
<span class="sig-name descname"><span class="pre">make_rdm2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.make_rdm2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.make_rdm2" title="Link to this definition">#</a></dt>
<dd><p>Two-particle density matrix in AO representation</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">tuple of 2D ndarrays</span></dt><dd><p>Orbital coefficients for alpha and beta spins. Each column is one orbital.</p>
</dd>
<dt>mo_occ<span class="classifier">tuple of 1D ndarrays</span></dt><dd><p>Occupancies for alpha and beta spins.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A tuple of three 4D ndarrays for alpha,alpha and alpha,beta and beta,beta spins</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.mulliken_meta">
<span class="sig-name descname"><span class="pre">mulliken_meta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.mulliken_meta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.mulliken_meta" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carried out within each subsets.</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or 2-item list of ndarray</span></dt><dd><p>Density matrix.  ROHF dm is a 2-item list of 2D array</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.mulliken_meta_spin">
<span class="sig-name descname"><span class="pre">mulliken_meta_spin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.mulliken_meta_spin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.mulliken_meta_spin" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.mulliken_pop">
<span class="sig-name descname"><span class="pre">mulliken_pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.mulliken_pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.mulliken_pop" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.mulliken_spin_pop">
<span class="sig-name descname"><span class="pre">mulliken_spin_pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.mulliken_spin_pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.mulliken_spin_pop" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.nelec">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelec</span></span><a class="headerlink" href="#pyscf.scf.uhf.UHF.nelec" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.nelectron_alpha">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelectron_alpha</span></span><a class="headerlink" href="#pyscf.scf.uhf.UHF.nelectron_alpha" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.nuc_grad_method">
<span class="sig-name descname"><span class="pre">nuc_grad_method</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.nuc_grad_method"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.nuc_grad_method" title="Link to this definition">#</a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.spin_square">
<span class="sig-name descname"><span class="pre">spin_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.spin_square"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.spin_square" title="Link to this definition">#</a></dt>
<dd><p>Spin square and multiplicity of UHF determinant</p>
<div class="math notranslate nohighlight">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math notranslate nohighlight">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math notranslate nohighlight">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl>
<dt>There are two possibilities for <span class="math notranslate nohighlight">\(S_+ S_-\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron <span class="math notranslate nohighlight">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math notranslate nohighlight">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math notranslate nohighlight">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="math notranslate nohighlight">
\[\langle S_+ S_- \rangle = \langle ij|s_+ s_-|ij\rangle
                        - \langle ij|s_+ s_-|ji\rangle
                        = -\langle i^\alpha|j^\beta\rangle
                           \langle j^\beta|i^\alpha\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Similarly, for <span class="math notranslate nohighlight">\(S_- S_+\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle S_- S_+ \rangle = -\langle i^\beta|j^\alpha\rangle
                           \langle j^\alpha|i^\beta\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>For <span class="math notranslate nohighlight">\(S_z^2\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}&amp;\frac{1}{2}\sum_{ij}(\langle ij|2s_{z1}s_{z2}|ij\rangle
                     -\langle ij|2s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}(n_\alpha^2 - n_\alpha n_\beta - n_\beta n_\alpha + n_\beta^2)
 -\frac{1}{4}(n_\alpha + n_\beta) \\
&amp;=\frac{1}{4}((n_\alpha-n_\beta)^2 - (n_\alpha+n_\beta))\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<p>In total</p>
<div class="math notranslate nohighlight">
\[\begin{split}\langle S^2\rangle &amp;= \frac{1}{2}
(n_\alpha-\sum_{ij}\langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle
+n_\beta -\sum_{ij}\langle i^\beta|j^\alpha\rangle\langle j^\alpha|i^\beta\rangle)
+ \frac{1}{4}(n_\alpha-n_\beta)^2 \\\end{split}\]</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo<span class="classifier">a list of 2 ndarrays</span></dt><dd><p>Occupied alpha and occupied beta orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>s<span class="classifier">ndarray</span></dt><dd><p>AO overlap</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.stability">
<span class="sig-name descname"><span class="pre">stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">internal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.stability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.stability" title="Link to this definition">#</a></dt>
<dd><p>Stability analysis for UHF/UKS method.</p>
<p>See also pyscf.scf.stability.uhf_stability function.</p>
<dl>
<dt>Args:</dt><dd><p>mf : UHF or UKS object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the UHF space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. Including the UHF -&gt; GHF and real -&gt; complex
stability analysis.</p>
</dd>
<dt>return_status: bool</dt><dd><p>Whether to return <cite>stable_i</cite> and <cite>stable_e</cite></p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>If return_status is False (default), the return value includes
two set of orbitals, which are more close to the stable condition.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
<p>Else, another two boolean variables (indicating current status:
stable or unstable) are returned.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.to_gpu">
<span class="sig-name descname"><span class="pre">to_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.UHF.to_gpu" title="Link to this definition">#</a></dt>
<dd><p>Convert a method to its corresponding GPU variant, and recursively
converts all attributes of a method to cupy objects or gpu4pyscf objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf.UHF.to_ks">
<span class="sig-name descname"><span class="pre">to_ks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#UHF.to_ks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.UHF.to_ks" title="Link to this definition">#</a></dt>
<dd><p>Convert to UKS object.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.analyze">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Dipole moment;
Spin density for AOs and atoms;</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.canonicalize">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#canonicalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.canonicalize" title="Link to this definition">#</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.det_ovlp">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">det_ovlp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ovlp</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#det_ovlp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.det_ovlp" title="Link to this definition">#</a></dt>
<dd><p>Calculate the overlap between two different determinants. It is the product
of single values of molecular orbital overlap matrix.</p>
<div class="math notranslate nohighlight">
\[S_{12} = \langle \Psi_A | \Psi_B \rangle
= (\mathrm{det}\mathbf{U}) (\mathrm{det}\mathbf{V^\dagger})
  \prod\limits_{i=1}\limits^{2N} \lambda_{ii}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{U}, \mathbf{V}, \lambda\)</span> are unitary matrices and single
values generated by single value decomposition(SVD) of the overlap matrix
<span class="math notranslate nohighlight">\(\mathbf{O}\)</span> which is the overlap matrix of two sets of molecular orbitals:</p>
<div class="math notranslate nohighlight">
\[\mathbf{U}^\dagger \mathbf{O} \mathbf{V} = \mathbf{\Lambda}\]</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo1, mo2<span class="classifier">2D ndarrays</span></dt><dd><p>Molecualr orbital coefficients</p>
</dd>
<dt>occ1, occ2: 2D ndarrays</dt><dd><p>occupation numbers</p>
</dd>
</dl>
</dd>
<dt>Return:</dt><dd><dl class="simple">
<dt>A list:</dt><dd><p>the product of single values: float
(x_a, x_b): 1D ndarrays
<span class="math notranslate nohighlight">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>
They are used to calculate asymmetric density matrix</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.energy_elec">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">energy_elec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#energy_elec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.energy_elec" title="Link to this definition">#</a></dt>
<dd><p>Electronic energy of Unrestricted Hartree-Fock</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Hartree-Fock electronic energy and the 2-electron part contribution</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.get_fock">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">get_fock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis_start_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damp_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#get_fock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.get_fock" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.get_grad">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock_ao</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.get_grad" title="Link to this definition">#</a></dt>
<dd><p>UHF Gradients</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.get_init_guess">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">get_init_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'minao'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#get_init_guess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.get_init_guess" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.get_occ">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#get_occ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.get_occ" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.get_veff">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">get_veff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhfopt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#get_veff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.get_veff" title="Link to this definition">#</a></dt>
<dd><p>Unrestricted Hartree-Fock potential matrix of alpha and beta spins,
for the given density matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}V_{ij}^\alpha &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\alpha \\
V_{ij}^\beta  &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\beta\end{split}\]</div>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">a list of ndarrays</span></dt><dd><p>A list of density matrices, stored as (alpha,alpha,…,beta,beta,…)</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>dm_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The density matrix baseline.  When it is not 0, this function computes
the increment of HF potential w.r.t. the reference HF potential matrix.</p>
</dd>
<dt>vhf_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The reference HF potential matrix.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p><span class="math notranslate nohighlight">\(V_{hf} = (V^\alpha, V^\beta)\)</span>.  <span class="math notranslate nohighlight">\(V^\alpha\)</span> (and <span class="math notranslate nohighlight">\(V^\beta\)</span>)
can be a list matrices, corresponding to the input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dmsa</span><span class="p">,</span><span class="n">dmsb</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="p">,</span> <span class="n">vhfb</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">uhf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfb</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.init_guess_by_1e">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#init_guess_by_1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.init_guess_by_1e" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.init_guess_by_atom">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#init_guess_by_atom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.init_guess_by_atom" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.init_guess_by_chkfile">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_chkfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chkfile_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#init_guess_by_chkfile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.init_guess_by_chkfile" title="Link to this definition">#</a></dt>
<dd><p>Read SCF chkfile and make the density matrix for UHF initial guess.</p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.init_guess_by_huckel">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#init_guess_by_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.init_guess_by_huckel" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.init_guess_by_minao">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_minao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#init_guess_by_minao"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.init_guess_by_minao" title="Link to this definition">#</a></dt>
<dd><p>Generate initial guess density matrix based on ANO basis, then project
the density matrix to the basis set defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrices, a list of 2D ndarrays for alpha and beta spins</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.init_guess_by_mod_huckel">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_mod_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#init_guess_by_mod_huckel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.init_guess_by_mod_huckel" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.init_guess_by_sap">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">init_guess_by_sap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sap_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#init_guess_by_sap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.init_guess_by_sap" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.make_asym_dm">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">make_asym_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#make_asym_dm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.make_asym_dm" title="Link to this definition">#</a></dt>
<dd><p>One-particle asymmetric density matrix</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo1, mo2<span class="classifier">2D ndarrays</span></dt><dd><p>Molecualr orbital coefficients</p>
</dd>
<dt>occ1, occ2: 2D ndarrays</dt><dd><p>Occupation numbers</p>
</dd>
<dt>x: 2D ndarrays</dt><dd><p><span class="math notranslate nohighlight">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>.
See also <a class="reference internal" href="#pyscf.scf.uhf.det_ovlp" title="pyscf.scf.uhf.det_ovlp"><code class="xref py py-func docutils literal notranslate"><span class="pre">det_ovlp()</span></code></a></p>
</dd>
</dl>
</dd>
<dt>Return:</dt><dd><p>A list of 2D ndarrays for alpha and beta spin</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.3&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.4&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">intor_cross</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">det</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">det_ovlp</span><span class="p">(</span><span class="n">mf1</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adm</span> <span class="o">=</span> <span class="n">make_asym_dm</span><span class="p">(</span><span class="n">mf1</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adm</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 19, 19)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.make_rdm1">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">make_rdm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#make_rdm1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.make_rdm1" title="Link to this definition">#</a></dt>
<dd><p>One-particle density matrix in AO representation</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">tuple of 2D ndarrays</span></dt><dd><p>Orbital coefficients for alpha and beta spins. Each column is one orbital.</p>
</dd>
<dt>mo_occ<span class="classifier">tuple of 1D ndarrays</span></dt><dd><p>Occupancies for alpha and beta spins.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list of 2D ndarrays for alpha and beta spins</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.make_rdm2">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">make_rdm2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#make_rdm2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.make_rdm2" title="Link to this definition">#</a></dt>
<dd><p>Two-particle density matrix in AO representation</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">tuple of 2D ndarrays</span></dt><dd><p>Orbital coefficients for alpha and beta spins. Each column is one orbital.</p>
</dd>
<dt>mo_occ<span class="classifier">tuple of 1D ndarrays</span></dt><dd><p>Occupancies for alpha and beta spins.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A tuple of three 4D ndarrays for alpha,alpha and alpha,beta and beta,beta spins</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.mulliken_meta">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">mulliken_meta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#mulliken_meta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.mulliken_meta" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.mulliken_meta_spin">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">mulliken_meta_spin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#mulliken_meta_spin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.mulliken_meta_spin" title="Link to this definition">#</a></dt>
<dd><p>Mulliken spin population analysis, based on meta-Lowdin AOs.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.mulliken_pop">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">mulliken_pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#mulliken_pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.mulliken_pop" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.mulliken_pop_meta_lowdin_ao">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">mulliken_pop_meta_lowdin_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.mulliken_pop_meta_lowdin_ao" title="Link to this definition">#</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.mulliken_spin_pop">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">mulliken_spin_pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#mulliken_spin_pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.mulliken_spin_pop" title="Link to this definition">#</a></dt>
<dd><p>Mulliken spin density analysis</p>
<p>See Eq. 80 in <a class="reference external" href="https://arxiv.org/pdf/1206.2234.pdf">https://arxiv.org/pdf/1206.2234.pdf</a> and the surrounding
text for more details.</p>
<div class="math notranslate nohighlight">
\[M_{ij} = (D^a_{ij} - D^b_{ij}) S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl>
<dt>Returns:</dt><dd><p>A list : spin_pop, Ms</p>
<dl class="simple">
<dt>spin_pop<span class="classifier">nparray</span></dt><dd><p>Mulliken spin density on each atomic orbitals</p>
</dd>
<dt>Ms<span class="classifier">nparray</span></dt><dd><p>Mulliken spin density on each atom</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.mulliken_spin_pop_meta_lowdin_ao">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">mulliken_spin_pop_meta_lowdin_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_ao</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf.mulliken_spin_pop_meta_lowdin_ao" title="Link to this definition">#</a></dt>
<dd><p>Mulliken spin population analysis, based on meta-Lowdin AOs.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf.spin_square">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf.</span></span><span class="sig-name descname"><span class="pre">spin_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf.html#spin_square"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf.spin_square" title="Link to this definition">#</a></dt>
<dd><p>Spin square and multiplicity of UHF determinant</p>
<div class="math notranslate nohighlight">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math notranslate nohighlight">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math notranslate nohighlight">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl>
<dt>There are two possibilities for <span class="math notranslate nohighlight">\(S_+ S_-\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron <span class="math notranslate nohighlight">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math notranslate nohighlight">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math notranslate nohighlight">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="math notranslate nohighlight">
\[\langle S_+ S_- \rangle = \langle ij|s_+ s_-|ij\rangle
                        - \langle ij|s_+ s_-|ji\rangle
                        = -\langle i^\alpha|j^\beta\rangle
                           \langle j^\beta|i^\alpha\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Similarly, for <span class="math notranslate nohighlight">\(S_- S_+\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle S_- S_+ \rangle = -\langle i^\beta|j^\alpha\rangle
                           \langle j^\alpha|i^\beta\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>For <span class="math notranslate nohighlight">\(S_z^2\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}&amp;\frac{1}{2}\sum_{ij}(\langle ij|2s_{z1}s_{z2}|ij\rangle
                     -\langle ij|2s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}(n_\alpha^2 - n_\alpha n_\beta - n_\beta n_\alpha + n_\beta^2)
 -\frac{1}{4}(n_\alpha + n_\beta) \\
&amp;=\frac{1}{4}((n_\alpha-n_\beta)^2 - (n_\alpha+n_\beta))\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<p>In total</p>
<div class="math notranslate nohighlight">
\[\begin{split}\langle S^2\rangle &amp;= \frac{1}{2}
(n_\alpha-\sum_{ij}\langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle
+n_\beta -\sum_{ij}\langle i^\beta|j^\alpha\rangle\langle j^\alpha|i^\beta\rangle)
+ \frac{1}{4}(n_\alpha-n_\beta)^2 \\\end{split}\]</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo<span class="classifier">a list of 2 ndarrays</span></dt><dd><p>Occupied alpha and occupied beta orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>s<span class="classifier">ndarray</span></dt><dd><p>AO overlap</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-pyscf.scf.uhf_symm">
<span id="pyscf-scf-uhf-symm-module"></span><h2>pyscf.scf.uhf_symm module<a class="headerlink" href="#module-pyscf.scf.uhf_symm" title="Link to this heading">#</a></h2>
<p>Non-relativistic unrestricted Hartree-Fock with point group symmetry.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.HF1e">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf_symm.</span></span><span class="sig-name descname"><span class="pre">HF1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#HF1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.HF1e" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.uhf_symm.SymAdaptedUHF" title="pyscf.scf.uhf_symm.SymAdaptedUHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymAdaptedUHF</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.HF1e.scf">
<span class="sig-name descname"><span class="pre">scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf_symm.HF1e.scf" title="Link to this definition">#</a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf_symm.</span></span><span class="sig-name descname"><span class="pre">SymAdaptedUHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#SymAdaptedUHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF" title="Link to this definition">#</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pyscf.scf.uhf.UHF" title="pyscf.scf.uhf.UHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">UHF</span></code></a></p>
<p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="simple">
<dt>Attributes for UHF:</dt><dd><dl class="simple">
<dt>nelec<span class="classifier">(int, int)</span></dt><dd><p>If given, freeze the number of (alpha,beta) electrons to the given value.</p>
</dd>
<dt>level_shift<span class="classifier">number or two-element list</span></dt><dd><p>level shift (in Eh) for alpha and beta Fock if two-element list is given.</p>
</dd>
<dt>init_guess_breaksym<span class="classifier">int</span></dt><dd><p>This configuration controls the algorithm used to break the spin
symmetry of the initial guess:
- 0 to disable symmetry breaking in the initial guess.
- 1 to use the default algorithm introduced in pyscf-1.7.
- 2 to adjust the num. electrons for spin-up and spin-down density matrices (issue #1839).</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mf</span><span class="o">.</span><span class="n">spin_square</span><span class="p">())</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
<dl class="simple">
<dt>Attributes for symmetry allowed UHF:</dt><dd><dl class="simple">
<dt>irrep_nelec<span class="classifier">dict</span></dt><dd><p>Specify the number of alpha/beta electrons for particular irrep
{‘ir_name’:(int,int), …}.
For the irreps not listed in these dicts, the program will choose the
occupancy based on the orbital energies.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-75.623975516256692</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">()</span>
<span class="go">{&#39;A1&#39;: (3, 3), &#39;A2&#39;: (0, 0), &#39;B1&#39;: (1, 1), &#39;B2&#39;: (1, 0)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">irrep_nelec</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;B1&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-75.429189192031131</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">()</span>
<span class="go">{&#39;A1&#39;: (3, 3), &#39;A2&#39;: (0, 0), &#39;B1&#39;: (1, 0), &#39;B2&#39;: (1, 1)}</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.CASCI">
<span class="sig-name descname"><span class="pre">CASCI</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.CASCI" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.CASSCF">
<span class="sig-name descname"><span class="pre">CASSCF</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.CASSCF" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.analyze">
<span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#SymAdaptedUHF.analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.analyze" title="Link to this definition">#</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#SymAdaptedUHF.build"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.build" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.canonicalize">
<span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.canonicalize" title="Link to this definition">#</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix in occupied, virtual
subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.dump_flags">
<span class="sig-name descname"><span class="pre">dump_flags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#SymAdaptedUHF.dump_flags"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.dump_flags" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#SymAdaptedUHF.eig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.eig" title="Link to this definition">#</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.get_grad">
<span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#SymAdaptedUHF.get_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.get_grad" title="Link to this definition">#</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Orbital occupancy</p>
</dd>
<dt>fock_ao<span class="classifier">2D ndarray</span></dt><dd><p>Fock matrix in AO representation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.get_irrep_nelec">
<span class="sig-name descname"><span class="pre">get_irrep_nelec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#SymAdaptedUHF.get_irrep_nelec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.get_irrep_nelec" title="Link to this definition">#</a></dt>
<dd><p>Alpha/beta electron numbers for each irreducible representation.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>mol<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></span></dt><dd><p>To provide irrep_id, and spin-adapted basis</p>
</dd>
<dt>mo_occ<span class="classifier">a list of 1D ndarray</span></dt><dd><p>Regular occupancy, without grouping for irreps</p>
</dd>
<dt>mo_coeff<span class="classifier">a list of 2D ndarray</span></dt><dd><p>Regular orbital coefficients, without grouping for irreps</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>irrep_nelec<span class="classifier">dict</span></dt><dd><p>The number of alpha/beta electrons for each irrep {‘ir_name’:(int,int), …}.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-75.623975516256721</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">uhf_symm</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">)</span>
<span class="go">{&#39;A1&#39;: (3, 3), &#39;A2&#39;: (0, 0), &#39;B1&#39;: (1, 1), &#39;B2&#39;: (1, 0)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.get_occ">
<span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#SymAdaptedUHF.get_occ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.get_occ" title="Link to this definition">#</a></dt>
<dd><p>We assumed mo_energy are grouped by symmetry irreps, (see function
self.eig). The orbitals are sorted after SCF.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.get_orbsym">
<span class="sig-name descname"><span class="pre">get_orbsym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#SymAdaptedUHF.get_orbsym"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.get_orbsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.get_wfnsym">
<span class="sig-name descname"><span class="pre">get_wfnsym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbsym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.get_wfnsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.orbsym">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">orbsym</span></span><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.orbsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.to_gpu">
<span class="sig-name descname"><span class="pre">to_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.to_gpu" title="Link to this definition">#</a></dt>
<dd><p>Convert a method to its corresponding GPU variant, and recursively
converts all attributes of a method to cupy objects or gpu4pyscf objects.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.SymAdaptedUHF.wfnsym">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wfnsym</span></span><a class="headerlink" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.wfnsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.UHF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf_symm.</span></span><span class="sig-name descname"><span class="pre">UHF</span></span><a class="headerlink" href="#pyscf.scf.uhf_symm.UHF" title="Link to this definition">#</a></dt>
<dd><p>alias of <a class="reference internal" href="#pyscf.scf.uhf_symm.SymAdaptedUHF" title="pyscf.scf.uhf_symm.SymAdaptedUHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymAdaptedUHF</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.analyze">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf_symm.</span></span><span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#analyze"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.analyze" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.canonicalize">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf_symm.</span></span><span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#canonicalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.canonicalize" title="Link to this definition">#</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix in occupied, virtual
subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.get_irrep_nelec">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf_symm.</span></span><span class="sig-name descname"><span class="pre">get_irrep_nelec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#get_irrep_nelec"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.get_irrep_nelec" title="Link to this definition">#</a></dt>
<dd><p>Alpha/beta electron numbers for each irreducible representation.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>mol<span class="classifier">an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></span></dt><dd><p>To provide irrep_id, and spin-adapted basis</p>
</dd>
<dt>mo_occ<span class="classifier">a list of 1D ndarray</span></dt><dd><p>Regular occupancy, without grouping for irreps</p>
</dd>
<dt>mo_coeff<span class="classifier">a list of 2D ndarray</span></dt><dd><p>Regular orbital coefficients, without grouping for irreps</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>irrep_nelec<span class="classifier">dict</span></dt><dd><p>The number of alpha/beta electrons for each irrep {‘ir_name’:(int,int), …}.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-75.623975516256721</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">uhf_symm</span><span class="o">.</span><span class="n">get_irrep_nelec</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">)</span>
<span class="go">{&#39;A1&#39;: (3, 3), &#39;A2&#39;: (0, 0), &#39;B1&#39;: (1, 1), &#39;B2&#39;: (1, 0)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.get_orbsym">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf_symm.</span></span><span class="sig-name descname"><span class="pre">get_orbsym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#get_orbsym"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.get_orbsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.uhf_symm.get_wfnsym">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.uhf_symm.</span></span><span class="sig-name descname"><span class="pre">get_wfnsym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbsym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf/uhf_symm.html#get_wfnsym"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.uhf_symm.get_wfnsym" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</section>
<section id="module-pyscf.scf">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pyscf.scf" title="Link to this heading">#</a></h2>
<section id="hartree-fock">
<h3>Hartree-Fock<a class="headerlink" href="#hartree-fock" title="Link to this heading">#</a></h3>
<p>Simple usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">scf.RHF()</span></code> returns an instance of SCF class.  There are some parameters
to control the SCF method.</p>
<blockquote>
<div><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-10</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  Default is 50</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘1e’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>DIIS<span class="classifier">class listed in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code></span></dt><dd><p>Default is <a class="reference internal" href="#pyscf.scf.diis.SCF_DIIS" title="pyscf.scf.diis.SCF_DIIS"><code class="xref py py-class docutils literal notranslate"><span class="pre">diis.SCF_DIIS</span></code></a>. Set it to None/False to turn off DIIS.</p>
</dd>
<dt>diis<span class="classifier">bool</span></dt><dd><p>whether to do DIIS.  Default is True.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 0.</p>
</dd>
<dt>level_shift_factor<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>nelec<span class="classifier">(int,int), for UHF/ROHF class</span></dt><dd><p>freeze the number of (alpha,beta) electrons.</p>
</dd>
<dt>irrep_nelec<span class="classifier">dict, for symmetry- RHF/ROHF/UHF class only</span></dt><dd><p>to indicate the number of electrons for each irreps.
In RHF, give {‘ir_name’:int, …} ;
In ROHF/UHF, give {‘ir_name’:(int,int), …} .
It is effective when <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.symmetry</span></code> is set <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
<dt>auxbasis<span class="classifier">str, for density fitting SCF only</span></dt><dd><p>Auxiliary basis for density fitting.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">density_fit</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
</pre></div>
</div>
<p>Density fitting can be applied to all non-relativistic HF class.</p>
</dd>
<dt>with_ssss<span class="classifier">bool, for Dirac-Hartree-Fock only</span></dt><dd><p>If False, ignore small component integrals (SS|SS).  Default is True.</p>
</dd>
<dt>with_gaunt<span class="classifier">bool, for Dirac-Hartree-Fock only</span></dt><dd><p>If False, ignore Gaunt interaction.  Default is False.</p>
</dd>
</dl>
</div></blockquote>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>SCF converged or not</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
</dl>
</div></blockquote>
</section>
<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.DHF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">DHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#DHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.DHF" title="Link to this definition">#</a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="simple">
<dt>Attributes for Dirac-Hartree-Fock</dt><dd><dl class="simple">
<dt>with_ssss<span class="classifier">bool or string, for Dirac-Hartree-Fock only</span></dt><dd><p>If False, ignore small component integrals (SS|SS).  Default is True.</p>
</dd>
<dt>with_gaunt<span class="classifier">bool, for Dirac-Hartree-Fock only</span></dt><dd><p>Default is False.</p>
</dd>
<dt>with_breit<span class="classifier">bool, for Dirac-Hartree-Fock only</span></dt><dd><p>Gaunt + gauge term.  Default is False.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e0</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">DHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Relativistic effects = </span><span class="si">%.12f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e1</span><span class="o">-</span><span class="n">e0</span><span class="p">))</span>
<span class="go">Relativistic effects = -0.000008854205</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.DKS">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">DKS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#DKS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.DKS" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.GHF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">GHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#GHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.GHF" title="Link to this definition">#</a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="simple">
<dt>Attributes for GHF method</dt><dd><p>GHF orbital coefficients are 2D array.  Let nao be the number of spatial
AOs, mo_coeff[:nao] are the coefficients of AO with alpha spin;
mo_coeff[nao:nao*2] are the coefficients of AO with beta spin.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.GKS">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">GKS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#GKS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.GKS" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.HF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">HF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#HF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.HF" title="Link to this definition">#</a></dt>
<dd><p>A wrap function to create SCF class (RHF or UHF).</p>
<p>SCF base class.   non-relativistic RHF.</p>
<blockquote>
<div><dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.KS">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">KS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#KS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.KS" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.RHF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">RHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#RHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.RHF" title="Link to this definition">#</a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.RKS">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">RKS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#RKS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.RKS" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ROHF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">ROHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#ROHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ROHF" title="Link to this definition">#</a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.ROKS">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">ROKS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#ROKS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.ROKS" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.UHF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">UHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#UHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.UHF" title="Link to this definition">#</a></dt>
<dd><p>SCF base class.   non-relativistic RHF.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>chkfile<span class="classifier">str</span></dt><dd><p>checkpoint file to save MOs, orbital energies etc.  Writing to
chkfile can be disabled if this attribute is set to None or False.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-9</p>
</dd>
<dt>conv_tol_grad<span class="classifier">float</span></dt><dd><p>gradients converge threshold.  Default is sqrt(conv_tol)</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  If max_cycle &lt;= 0, SCF iteration will
be skipped and the kernel function will compute only the total
energy based on the initial guess. Default value is 50.</p>
</dd>
<dt>init_guess<span class="classifier">str</span></dt><dd><p>initial guess method.  It can be one of ‘minao’, ‘atom’, ‘huckel’, ‘hcore’, ‘1e’, ‘sap’, ‘chkfile’.
Default is ‘minao’</p>
</dd>
<dt>sap_basis<span class="classifier">str or dict</span></dt><dd><p>basis for SAP initial guess, either filename or path as str or
internal format dictionary.</p>
</dd>
<dt>DIIS<span class="classifier">DIIS class</span></dt><dd><p>The class to generate diis object.  It can be one of
diis.SCF_DIIS, diis.ADIIS, diis.EDIIS.</p>
</dd>
<dt>diis<span class="classifier">boolean or object of DIIS class defined in <code class="xref py py-mod docutils literal notranslate"><span class="pre">scf.diis</span></code>.</span></dt><dd><p>Default is the object associated to the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">self.DIIS</span></code>.
Set it to None/False to turn off DIIS.
Note if this attribute is initialized as a DIIS object, the SCF driver
will use this object in the iteration. The DIIS information (vector
basis and error vector) will be held inside this object. When kernel
function is called again, the old states (vector basis and error
vector) will be reused.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  By default, 8 Fock matrices and errors vector are stored.</p>
</dd>
<dt>diis_damp<span class="classifier">float</span></dt><dd><p>DIIS damping factor.  Default is 0.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 1.</p>
</dd>
<dt>diis_file: ‘str’</dt><dd><p>File to store DIIS vectors and error vectors.</p>
</dd>
<dt>level_shift<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>Direct SCF is used by default.</p>
</dd>
<dt>direct_scf_tol<span class="classifier">float</span></dt><dd><p>Direct SCF cutoff threshold.  Default is 1e-13.</p>
</dd>
<dt>callback<span class="classifier">function(envs_dict) =&gt; None</span></dt><dd><p>callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd>
<dt>conv_check<span class="classifier">bool</span></dt><dd><p>An extra cycle to check convergence after SCF iterations.</p>
</dd>
<dt>check_convergence<span class="classifier">function(envs) =&gt; bool</span></dt><dd><p>A hook for overloading convergence criteria in SCF iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the SCF iteration converged</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total HF energy (electronic energy plus nuclear repulsion)</p>
</dd>
<dt>mo_energy :</dt><dd><p>Orbital energies</p>
</dd>
<dt>mo_occ</dt><dd><p>Orbital occupancy</p>
</dd>
<dt>mo_coeff</dt><dd><p>Orbital coefficients</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">.4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="go">-1.0811707843775884</span>
</pre></div>
</div>
<dl class="simple">
<dt>Attributes for UHF:</dt><dd><dl class="simple">
<dt>nelec<span class="classifier">(int, int)</span></dt><dd><p>If given, freeze the number of (alpha,beta) electrons to the given value.</p>
</dd>
<dt>level_shift<span class="classifier">number or two-element list</span></dt><dd><p>level shift (in Eh) for alpha and beta Fock if two-element list is given.</p>
</dd>
<dt>init_guess_breaksym<span class="classifier">int</span></dt><dd><p>This configuration controls the algorithm used to break the spin
symmetry of the initial guess:
- 0 to disable symmetry breaking in the initial guess.
- 1 to use the default algorithm introduced in pyscf-1.7.
- 2 to adjust the num. electrons for spin-up and spin-down density matrices (issue #1839).</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mf</span><span class="o">.</span><span class="n">spin_square</span><span class="p">())</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.UKS">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">UKS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#UKS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.UKS" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.X2C">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">X2C</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#X2C"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.X2C" title="Link to this definition">#</a></dt>
<dd><p>X2C Hartree-Fock</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.X2C_HF">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">X2C_HF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.X2C_HF" title="Link to this definition">#</a></dt>
<dd><p>X2C Hartree-Fock</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.density_fit">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">density_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">auxbasis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_df</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">only_dfj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#density_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.density_fit" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.newton">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">newton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#newton"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.newton" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.sfx2c">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">sfx2c</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.scf.sfx2c" title="Link to this definition">#</a></dt>
<dd><p>spin-free (the scalar part) X2C with 1-electron X-matrix</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyscf.scf.sfx2c1e">
<span class="sig-prename descclassname"><span class="pre">pyscf.scf.</span></span><span class="sig-name descname"><span class="pre">sfx2c1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/scf.html#sfx2c1e"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pyscf.scf.sfx2c1e" title="Link to this definition">#</a></dt>
<dd><p>spin-free (the scalar part) X2C with 1-electron X-matrix</p>
</dd></dl>

</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#submodules">Submodules</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.addons">pyscf.scf.addons module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.canonical_orth_"><code class="docutils literal notranslate"><span class="pre">canonical_orth_()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.convert_to_ghf"><code class="docutils literal notranslate"><span class="pre">convert_to_ghf()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.convert_to_rhf"><code class="docutils literal notranslate"><span class="pre">convert_to_rhf()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.convert_to_uhf"><code class="docutils literal notranslate"><span class="pre">convert_to_uhf()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.dynamic_level_shift"><code class="docutils literal notranslate"><span class="pre">dynamic_level_shift()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.dynamic_level_shift_"><code class="docutils literal notranslate"><span class="pre">dynamic_level_shift_()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.dynamic_occ"><code class="docutils literal notranslate"><span class="pre">dynamic_occ()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.dynamic_occ_"><code class="docutils literal notranslate"><span class="pre">dynamic_occ_()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.dynamic_sz_"><code class="docutils literal notranslate"><span class="pre">dynamic_sz_()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.fast_newton"><code class="docutils literal notranslate"><span class="pre">fast_newton()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.float_occ"><code class="docutils literal notranslate"><span class="pre">float_occ()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.float_occ_"><code class="docutils literal notranslate"><span class="pre">float_occ_()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.follow_state"><code class="docutils literal notranslate"><span class="pre">follow_state()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.follow_state_"><code class="docutils literal notranslate"><span class="pre">follow_state_()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.frac_occ"><code class="docutils literal notranslate"><span class="pre">frac_occ()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.frac_occ_"><code class="docutils literal notranslate"><span class="pre">frac_occ_()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.get_ghf_orbspin"><code class="docutils literal notranslate"><span class="pre">get_ghf_orbspin()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.mom_occ"><code class="docutils literal notranslate"><span class="pre">mom_occ()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.mom_occ_"><code class="docutils literal notranslate"><span class="pre">mom_occ_()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.partial_cholesky_orth_"><code class="docutils literal notranslate"><span class="pre">partial_cholesky_orth_()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.project_dm_nr2nr"><code class="docutils literal notranslate"><span class="pre">project_dm_nr2nr()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.project_dm_nr2r"><code class="docutils literal notranslate"><span class="pre">project_dm_nr2r()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.project_dm_r2r"><code class="docutils literal notranslate"><span class="pre">project_dm_r2r()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.project_mo_nr2nr"><code class="docutils literal notranslate"><span class="pre">project_mo_nr2nr()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.project_mo_nr2r"><code class="docutils literal notranslate"><span class="pre">project_mo_nr2r()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.project_mo_r2r"><code class="docutils literal notranslate"><span class="pre">project_mo_r2r()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.remove_linear_dep"><code class="docutils literal notranslate"><span class="pre">remove_linear_dep()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.remove_linear_dep_"><code class="docutils literal notranslate"><span class="pre">remove_linear_dep_()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.smearing"><code class="docutils literal notranslate"><span class="pre">smearing()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.addons.smearing_"><code class="docutils literal notranslate"><span class="pre">smearing_()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.atom_hf">pyscf.scf.atom_hf module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf.AtomHF1e"><code class="docutils literal notranslate"><span class="pre">AtomHF1e</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf.AtomHF1e.eig"><code class="docutils literal notranslate"><span class="pre">AtomHF1e.eig()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf.AtomSphAverageRHF"><code class="docutils literal notranslate"><span class="pre">AtomSphAverageRHF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf.AtomSphAverageRHF.check_sanity"><code class="docutils literal notranslate"><span class="pre">AtomSphAverageRHF.check_sanity()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf.AtomSphAverageRHF.dump_flags"><code class="docutils literal notranslate"><span class="pre">AtomSphAverageRHF.dump_flags()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf.AtomSphAverageRHF.eig"><code class="docutils literal notranslate"><span class="pre">AtomSphAverageRHF.eig()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf.AtomSphAverageRHF.get_grad"><code class="docutils literal notranslate"><span class="pre">AtomSphAverageRHF.get_grad()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf.AtomSphAverageRHF.get_occ"><code class="docutils literal notranslate"><span class="pre">AtomSphAverageRHF.get_occ()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf.AtomSphAverageRHF.scf"><code class="docutils literal notranslate"><span class="pre">AtomSphAverageRHF.scf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf.AtomSphericAverageRHF"><code class="docutils literal notranslate"><span class="pre">AtomSphericAverageRHF</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf.frac_occ"><code class="docutils literal notranslate"><span class="pre">frac_occ()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf.get_atm_nrhf"><code class="docutils literal notranslate"><span class="pre">get_atm_nrhf()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.atom_hf_pp">pyscf.scf.atom_hf_pp module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf_pp.AtomHF1ePP"><code class="docutils literal notranslate"><span class="pre">AtomHF1ePP</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf_pp.AtomHF1ePP.eig"><code class="docutils literal notranslate"><span class="pre">AtomHF1ePP.eig()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf_pp.AtomHF1ePP.get_hcore"><code class="docutils literal notranslate"><span class="pre">AtomHF1ePP.get_hcore()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf_pp.AtomSCFPP"><code class="docutils literal notranslate"><span class="pre">AtomSCFPP</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf_pp.AtomSCFPP.get_hcore"><code class="docutils literal notranslate"><span class="pre">AtomSCFPP.get_hcore()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf_pp.get_pp_loc"><code class="docutils literal notranslate"><span class="pre">get_pp_loc()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf_pp.get_pp_loc_part1_rs"><code class="docutils literal notranslate"><span class="pre">get_pp_loc_part1_rs()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf_pp.get_pp_loc_part2"><code class="docutils literal notranslate"><span class="pre">get_pp_loc_part2()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_hf_pp.get_pp_nl"><code class="docutils literal notranslate"><span class="pre">get_pp_nl()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.atom_ks">pyscf.scf.atom_ks module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_ks.AtomSphAverageRKS"><code class="docutils literal notranslate"><span class="pre">AtomSphAverageRKS</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_ks.AtomSphAverageRKS.eig"><code class="docutils literal notranslate"><span class="pre">AtomSphAverageRKS.eig()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_ks.AtomSphAverageRKS.get_grad"><code class="docutils literal notranslate"><span class="pre">AtomSphAverageRKS.get_grad()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_ks.AtomSphAverageRKS.get_occ"><code class="docutils literal notranslate"><span class="pre">AtomSphAverageRKS.get_occ()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_ks.AtomSphericAverageRKS"><code class="docutils literal notranslate"><span class="pre">AtomSphericAverageRKS</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.atom_ks.get_atm_nrks"><code class="docutils literal notranslate"><span class="pre">get_atm_nrks()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.chkfile">pyscf.scf.chkfile module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.chkfile.dump_scf"><code class="docutils literal notranslate"><span class="pre">dump_scf()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.chkfile.load_scf"><code class="docutils literal notranslate"><span class="pre">load_scf()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.cphf">pyscf.scf.cphf module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.cphf.kernel"><code class="docutils literal notranslate"><span class="pre">kernel()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.cphf.solve"><code class="docutils literal notranslate"><span class="pre">solve()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.cphf.solve_nos1"><code class="docutils literal notranslate"><span class="pre">solve_nos1()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.cphf.solve_withs1"><code class="docutils literal notranslate"><span class="pre">solve_withs1()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.dhf">pyscf.scf.dhf module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF"><code class="docutils literal notranslate"><span class="pre">DHF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.Gradients"><code class="docutils literal notranslate"><span class="pre">DHF.Gradients()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.TDA"><code class="docutils literal notranslate"><span class="pre">DHF.TDA()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.TDHF"><code class="docutils literal notranslate"><span class="pre">DHF.TDHF()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.analyze"><code class="docutils literal notranslate"><span class="pre">DHF.analyze()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.build"><code class="docutils literal notranslate"><span class="pre">DHF.build()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.conv_tol"><code class="docutils literal notranslate"><span class="pre">DHF.conv_tol</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.dip_moment"><code class="docutils literal notranslate"><span class="pre">DHF.dip_moment()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.dump_flags"><code class="docutils literal notranslate"><span class="pre">DHF.dump_flags()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.energy_elec"><code class="docutils literal notranslate"><span class="pre">DHF.energy_elec()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.gen_response"><code class="docutils literal notranslate"><span class="pre">DHF.gen_response()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.get_grad"><code class="docutils literal notranslate"><span class="pre">DHF.get_grad()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.get_hcore"><code class="docutils literal notranslate"><span class="pre">DHF.get_hcore()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.get_jk"><code class="docutils literal notranslate"><span class="pre">DHF.get_jk()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.get_occ"><code class="docutils literal notranslate"><span class="pre">DHF.get_occ()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.get_ovlp"><code class="docutils literal notranslate"><span class="pre">DHF.get_ovlp()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.get_veff"><code class="docutils literal notranslate"><span class="pre">DHF.get_veff()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.init_direct_scf"><code class="docutils literal notranslate"><span class="pre">DHF.init_direct_scf()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.init_guess_by_atom"><code class="docutils literal notranslate"><span class="pre">DHF.init_guess_by_atom()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.init_guess_by_chkfile"><code class="docutils literal notranslate"><span class="pre">DHF.init_guess_by_chkfile()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.init_guess_by_huckel"><code class="docutils literal notranslate"><span class="pre">DHF.init_guess_by_huckel()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.init_guess_by_minao"><code class="docutils literal notranslate"><span class="pre">DHF.init_guess_by_minao()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.init_guess_by_mod_huckel"><code class="docutils literal notranslate"><span class="pre">DHF.init_guess_by_mod_huckel()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.init_guess_by_sap"><code class="docutils literal notranslate"><span class="pre">DHF.init_guess_by_sap()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.make_rdm1"><code class="docutils literal notranslate"><span class="pre">DHF.make_rdm1()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.mulliken_pop"><code class="docutils literal notranslate"><span class="pre">DHF.mulliken_pop()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.nuc_grad_method"><code class="docutils literal notranslate"><span class="pre">DHF.nuc_grad_method()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.reset"><code class="docutils literal notranslate"><span class="pre">DHF.reset()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.scf"><code class="docutils literal notranslate"><span class="pre">DHF.scf()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.sfx2c1e"><code class="docutils literal notranslate"><span class="pre">DHF.sfx2c1e()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.ssss_approx"><code class="docutils literal notranslate"><span class="pre">DHF.ssss_approx</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.stability"><code class="docutils literal notranslate"><span class="pre">DHF.stability()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.to_dhf"><code class="docutils literal notranslate"><span class="pre">DHF.to_dhf()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.to_dks"><code class="docutils literal notranslate"><span class="pre">DHF.to_dks()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.to_ghf"><code class="docutils literal notranslate"><span class="pre">DHF.to_ghf()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.to_gks"><code class="docutils literal notranslate"><span class="pre">DHF.to_gks()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.to_gpu"><code class="docutils literal notranslate"><span class="pre">DHF.to_gpu()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.to_ks"><code class="docutils literal notranslate"><span class="pre">DHF.to_ks()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.to_rhf"><code class="docutils literal notranslate"><span class="pre">DHF.to_rhf()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.to_rks"><code class="docutils literal notranslate"><span class="pre">DHF.to_rks()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.to_uhf"><code class="docutils literal notranslate"><span class="pre">DHF.to_uhf()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.to_uks"><code class="docutils literal notranslate"><span class="pre">DHF.to_uks()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.with_breit"><code class="docutils literal notranslate"><span class="pre">DHF.with_breit</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.with_gaunt"><code class="docutils literal notranslate"><span class="pre">DHF.with_gaunt</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.with_ssss"><code class="docutils literal notranslate"><span class="pre">DHF.with_ssss</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.x2c"><code class="docutils literal notranslate"><span class="pre">DHF.x2c()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.DHF.x2c1e"><code class="docutils literal notranslate"><span class="pre">DHF.x2c1e()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.HF1e"><code class="docutils literal notranslate"><span class="pre">HF1e</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.HF1e.scf"><code class="docutils literal notranslate"><span class="pre">HF1e.scf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.RDHF"><code class="docutils literal notranslate"><span class="pre">RDHF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.RDHF.TDA"><code class="docutils literal notranslate"><span class="pre">RDHF.TDA()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.RDHF.TDHF"><code class="docutils literal notranslate"><span class="pre">RDHF.TDHF()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.RDHF.to_dks"><code class="docutils literal notranslate"><span class="pre">RDHF.to_dks()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.RDHF.x2c"><code class="docutils literal notranslate"><span class="pre">RDHF.x2c()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.RDHF.x2c1e"><code class="docutils literal notranslate"><span class="pre">RDHF.x2c1e()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.RHF"><code class="docutils literal notranslate"><span class="pre">RHF</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.UDHF"><code class="docutils literal notranslate"><span class="pre">UDHF</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.UHF"><code class="docutils literal notranslate"><span class="pre">UHF</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.analyze"><code class="docutils literal notranslate"><span class="pre">analyze()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.dip_moment"><code class="docutils literal notranslate"><span class="pre">dip_moment()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.energy_elec"><code class="docutils literal notranslate"><span class="pre">energy_elec()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.get_grad"><code class="docutils literal notranslate"><span class="pre">get_grad()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.get_hcore"><code class="docutils literal notranslate"><span class="pre">get_hcore()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.get_init_guess"><code class="docutils literal notranslate"><span class="pre">get_init_guess()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.get_jk"><code class="docutils literal notranslate"><span class="pre">get_jk()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.get_jk_coulomb"><code class="docutils literal notranslate"><span class="pre">get_jk_coulomb()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.get_ovlp"><code class="docutils literal notranslate"><span class="pre">get_ovlp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.init_guess_by_1e"><code class="docutils literal notranslate"><span class="pre">init_guess_by_1e()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.init_guess_by_atom"><code class="docutils literal notranslate"><span class="pre">init_guess_by_atom()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.init_guess_by_chkfile"><code class="docutils literal notranslate"><span class="pre">init_guess_by_chkfile()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.init_guess_by_huckel"><code class="docutils literal notranslate"><span class="pre">init_guess_by_huckel()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.init_guess_by_minao"><code class="docutils literal notranslate"><span class="pre">init_guess_by_minao()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.init_guess_by_mod_huckel"><code class="docutils literal notranslate"><span class="pre">init_guess_by_mod_huckel()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.init_guess_by_sap"><code class="docutils literal notranslate"><span class="pre">init_guess_by_sap()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.kernel"><code class="docutils literal notranslate"><span class="pre">kernel()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.mulliken_pop"><code class="docutils literal notranslate"><span class="pre">mulliken_pop()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dhf.time_reversal_matrix"><code class="docutils literal notranslate"><span class="pre">time_reversal_matrix()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.diis">pyscf.scf.diis module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.ADIIS"><code class="docutils literal notranslate"><span class="pre">ADIIS</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.ADIIS.update"><code class="docutils literal notranslate"><span class="pre">ADIIS.update()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.CDIIS"><code class="docutils literal notranslate"><span class="pre">CDIIS</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.CDIIS.get_num_vec"><code class="docutils literal notranslate"><span class="pre">CDIIS.get_num_vec()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.CDIIS.update"><code class="docutils literal notranslate"><span class="pre">CDIIS.update()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.DIIS"><code class="docutils literal notranslate"><span class="pre">DIIS</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.EDIIS"><code class="docutils literal notranslate"><span class="pre">EDIIS</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.EDIIS.update"><code class="docutils literal notranslate"><span class="pre">EDIIS.update()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.SCFDIIS"><code class="docutils literal notranslate"><span class="pre">SCFDIIS</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.SCF_DIIS"><code class="docutils literal notranslate"><span class="pre">SCF_DIIS</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.adiis_minimize"><code class="docutils literal notranslate"><span class="pre">adiis_minimize()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.ediis_minimize"><code class="docutils literal notranslate"><span class="pre">ediis_minimize()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.get_err_vec"><code class="docutils literal notranslate"><span class="pre">get_err_vec()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.get_err_vec_orig"><code class="docutils literal notranslate"><span class="pre">get_err_vec_orig()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.diis.get_err_vec_orth"><code class="docutils literal notranslate"><span class="pre">get_err_vec_orth()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.dispersion">pyscf.scf.dispersion module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dispersion.check_disp"><code class="docutils literal notranslate"><span class="pre">check_disp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dispersion.get_dispersion"><code class="docutils literal notranslate"><span class="pre">get_dispersion()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dispersion.parse_dft"><code class="docutils literal notranslate"><span class="pre">parse_dft()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.dispersion.parse_disp"><code class="docutils literal notranslate"><span class="pre">parse_disp()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.ghf">pyscf.scf.ghf module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF"><code class="docutils literal notranslate"><span class="pre">GHF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.CISD"><code class="docutils literal notranslate"><span class="pre">GHF.CISD()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.MP2"><code class="docutils literal notranslate"><span class="pre">GHF.MP2()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.TDA"><code class="docutils literal notranslate"><span class="pre">GHF.TDA()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.TDHF"><code class="docutils literal notranslate"><span class="pre">GHF.TDHF()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.analyze"><code class="docutils literal notranslate"><span class="pre">GHF.analyze()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.convert_from_"><code class="docutils literal notranslate"><span class="pre">GHF.convert_from_()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.det_ovlp"><code class="docutils literal notranslate"><span class="pre">GHF.det_ovlp()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.dip_moment"><code class="docutils literal notranslate"><span class="pre">GHF.dip_moment()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.gen_response"><code class="docutils literal notranslate"><span class="pre">GHF.gen_response()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.get_grad"><code class="docutils literal notranslate"><span class="pre">GHF.get_grad()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.get_hcore"><code class="docutils literal notranslate"><span class="pre">GHF.get_hcore()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.get_init_guess"><code class="docutils literal notranslate"><span class="pre">GHF.get_init_guess()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.get_jk"><code class="docutils literal notranslate"><span class="pre">GHF.get_jk()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.get_occ"><code class="docutils literal notranslate"><span class="pre">GHF.get_occ()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.get_ovlp"><code class="docutils literal notranslate"><span class="pre">GHF.get_ovlp()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.get_veff"><code class="docutils literal notranslate"><span class="pre">GHF.get_veff()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.init_guess_by_atom"><code class="docutils literal notranslate"><span class="pre">GHF.init_guess_by_atom()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.init_guess_by_chkfile"><code class="docutils literal notranslate"><span class="pre">GHF.init_guess_by_chkfile()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.init_guess_by_huckel"><code class="docutils literal notranslate"><span class="pre">GHF.init_guess_by_huckel()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.init_guess_by_minao"><code class="docutils literal notranslate"><span class="pre">GHF.init_guess_by_minao()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.init_guess_by_mod_huckel"><code class="docutils literal notranslate"><span class="pre">GHF.init_guess_by_mod_huckel()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.init_guess_by_sap"><code class="docutils literal notranslate"><span class="pre">GHF.init_guess_by_sap()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.mulliken_meta"><code class="docutils literal notranslate"><span class="pre">GHF.mulliken_meta()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.mulliken_pop"><code class="docutils literal notranslate"><span class="pre">GHF.mulliken_pop()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.nuc_grad_method"><code class="docutils literal notranslate"><span class="pre">GHF.nuc_grad_method()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.spin_square"><code class="docutils literal notranslate"><span class="pre">GHF.spin_square()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.stability"><code class="docutils literal notranslate"><span class="pre">GHF.stability()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.to_gpu"><code class="docutils literal notranslate"><span class="pre">GHF.to_gpu()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.to_ks"><code class="docutils literal notranslate"><span class="pre">GHF.to_ks()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.with_soc"><code class="docutils literal notranslate"><span class="pre">GHF.with_soc</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.x2c"><code class="docutils literal notranslate"><span class="pre">GHF.x2c()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.GHF.x2c1e"><code class="docutils literal notranslate"><span class="pre">GHF.x2c1e()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.HF1e"><code class="docutils literal notranslate"><span class="pre">HF1e</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.HF1e.scf"><code class="docutils literal notranslate"><span class="pre">HF1e.scf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.analyze"><code class="docutils literal notranslate"><span class="pre">analyze()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.det_ovlp"><code class="docutils literal notranslate"><span class="pre">det_ovlp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.dip_moment"><code class="docutils literal notranslate"><span class="pre">dip_moment()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.get_jk"><code class="docutils literal notranslate"><span class="pre">get_jk()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.get_occ"><code class="docutils literal notranslate"><span class="pre">get_occ()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.guess_orbspin"><code class="docutils literal notranslate"><span class="pre">guess_orbspin()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.init_guess_by_chkfile"><code class="docutils literal notranslate"><span class="pre">init_guess_by_chkfile()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.mulliken_meta"><code class="docutils literal notranslate"><span class="pre">mulliken_meta()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.mulliken_pop"><code class="docutils literal notranslate"><span class="pre">mulliken_pop()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf.spin_square"><code class="docutils literal notranslate"><span class="pre">spin_square()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.ghf_symm">pyscf.scf.ghf_symm module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.GHF"><code class="docutils literal notranslate"><span class="pre">GHF</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.HF1e"><code class="docutils literal notranslate"><span class="pre">HF1e</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.HF1e.scf"><code class="docutils literal notranslate"><span class="pre">HF1e.scf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.SymAdaptedGHF"><code class="docutils literal notranslate"><span class="pre">SymAdaptedGHF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.analyze"><code class="docutils literal notranslate"><span class="pre">SymAdaptedGHF.analyze()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.build"><code class="docutils literal notranslate"><span class="pre">SymAdaptedGHF.build()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.canonicalize"><code class="docutils literal notranslate"><span class="pre">SymAdaptedGHF.canonicalize()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.dump_flags"><code class="docutils literal notranslate"><span class="pre">SymAdaptedGHF.dump_flags()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.eig"><code class="docutils literal notranslate"><span class="pre">SymAdaptedGHF.eig()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.get_grad"><code class="docutils literal notranslate"><span class="pre">SymAdaptedGHF.get_grad()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.get_irrep_nelec"><code class="docutils literal notranslate"><span class="pre">SymAdaptedGHF.get_irrep_nelec()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.get_occ"><code class="docutils literal notranslate"><span class="pre">SymAdaptedGHF.get_occ()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.get_orbsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedGHF.get_orbsym()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.orbsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedGHF.orbsym</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.SymAdaptedGHF.to_gpu"><code class="docutils literal notranslate"><span class="pre">SymAdaptedGHF.to_gpu()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.analyze"><code class="docutils literal notranslate"><span class="pre">analyze()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.canonicalize"><code class="docutils literal notranslate"><span class="pre">canonicalize()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ghf_symm.get_orbsym"><code class="docutils literal notranslate"><span class="pre">get_orbsym()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.hf">pyscf.scf.hf module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.Kgwh"><code class="docutils literal notranslate"><span class="pre">Kgwh()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF"><code class="docutils literal notranslate"><span class="pre">RHF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.CASCI"><code class="docutils literal notranslate"><span class="pre">RHF.CASCI()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.CASSCF"><code class="docutils literal notranslate"><span class="pre">RHF.CASSCF()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.CISD"><code class="docutils literal notranslate"><span class="pre">RHF.CISD()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.DFMP2"><code class="docutils literal notranslate"><span class="pre">RHF.DFMP2()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.Gradients"><code class="docutils literal notranslate"><span class="pre">RHF.Gradients()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.MP2"><code class="docutils literal notranslate"><span class="pre">RHF.MP2()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.TDA"><code class="docutils literal notranslate"><span class="pre">RHF.TDA()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.TDHF"><code class="docutils literal notranslate"><span class="pre">RHF.TDHF()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.check_sanity"><code class="docutils literal notranslate"><span class="pre">RHF.check_sanity()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.convert_from_"><code class="docutils literal notranslate"><span class="pre">RHF.convert_from_()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.gen_response"><code class="docutils literal notranslate"><span class="pre">RHF.gen_response()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.get_init_guess"><code class="docutils literal notranslate"><span class="pre">RHF.get_init_guess()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.get_jk"><code class="docutils literal notranslate"><span class="pre">RHF.get_jk()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.get_veff"><code class="docutils literal notranslate"><span class="pre">RHF.get_veff()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.nuc_grad_method"><code class="docutils literal notranslate"><span class="pre">RHF.nuc_grad_method()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.spin_square"><code class="docutils literal notranslate"><span class="pre">RHF.spin_square()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.stability"><code class="docutils literal notranslate"><span class="pre">RHF.stability()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.to_gpu"><code class="docutils literal notranslate"><span class="pre">RHF.to_gpu()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.RHF.to_ks"><code class="docutils literal notranslate"><span class="pre">RHF.to_ks()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF"><code class="docutils literal notranslate"><span class="pre">SCF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.CCSD"><code class="docutils literal notranslate"><span class="pre">SCF.CCSD()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.DIIS"><code class="docutils literal notranslate"><span class="pre">SCF.DIIS</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.QCISD"><code class="docutils literal notranslate"><span class="pre">SCF.QCISD()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.QMMM"><code class="docutils literal notranslate"><span class="pre">SCF.QMMM()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.analyze"><code class="docutils literal notranslate"><span class="pre">SCF.analyze()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.apply"><code class="docutils literal notranslate"><span class="pre">SCF.apply()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.as_scanner"><code class="docutils literal notranslate"><span class="pre">SCF.as_scanner()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.build"><code class="docutils literal notranslate"><span class="pre">SCF.build()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.callback"><code class="docutils literal notranslate"><span class="pre">SCF.callback</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.canonicalize"><code class="docutils literal notranslate"><span class="pre">SCF.canonicalize()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.check_convergence"><code class="docutils literal notranslate"><span class="pre">SCF.check_convergence</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.check_sanity"><code class="docutils literal notranslate"><span class="pre">SCF.check_sanity()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.conv_check"><code class="docutils literal notranslate"><span class="pre">SCF.conv_check</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.conv_tol"><code class="docutils literal notranslate"><span class="pre">SCF.conv_tol</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.conv_tol_cpscf"><code class="docutils literal notranslate"><span class="pre">SCF.conv_tol_cpscf</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.conv_tol_grad"><code class="docutils literal notranslate"><span class="pre">SCF.conv_tol_grad</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.convert_from_"><code class="docutils literal notranslate"><span class="pre">SCF.convert_from_()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.damp"><code class="docutils literal notranslate"><span class="pre">SCF.damp</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.density_fit"><code class="docutils literal notranslate"><span class="pre">SCF.density_fit()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.diis"><code class="docutils literal notranslate"><span class="pre">SCF.diis</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.diis_damp"><code class="docutils literal notranslate"><span class="pre">SCF.diis_damp</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.diis_file"><code class="docutils literal notranslate"><span class="pre">SCF.diis_file</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.diis_space"><code class="docutils literal notranslate"><span class="pre">SCF.diis_space</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.diis_space_rollback"><code class="docutils literal notranslate"><span class="pre">SCF.diis_space_rollback</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.diis_start_cycle"><code class="docutils literal notranslate"><span class="pre">SCF.diis_start_cycle</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.dip_moment"><code class="docutils literal notranslate"><span class="pre">SCF.dip_moment()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.direct_scf"><code class="docutils literal notranslate"><span class="pre">SCF.direct_scf</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.direct_scf_tol"><code class="docutils literal notranslate"><span class="pre">SCF.direct_scf_tol</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.disp"><code class="docutils literal notranslate"><span class="pre">SCF.disp</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.do_disp"><code class="docutils literal notranslate"><span class="pre">SCF.do_disp()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.dump_chk"><code class="docutils literal notranslate"><span class="pre">SCF.dump_chk()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.dump_flags"><code class="docutils literal notranslate"><span class="pre">SCF.dump_flags()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.dump_scf_summary"><code class="docutils literal notranslate"><span class="pre">SCF.dump_scf_summary()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.eig"><code class="docutils literal notranslate"><span class="pre">SCF.eig()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.energy_elec"><code class="docutils literal notranslate"><span class="pre">SCF.energy_elec()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.energy_nuc"><code class="docutils literal notranslate"><span class="pre">SCF.energy_nuc()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.energy_tot"><code class="docutils literal notranslate"><span class="pre">SCF.energy_tot()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.from_chk"><code class="docutils literal notranslate"><span class="pre">SCF.from_chk()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.get_dispersion"><code class="docutils literal notranslate"><span class="pre">SCF.get_dispersion()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.get_fock"><code class="docutils literal notranslate"><span class="pre">SCF.get_fock()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.get_grad"><code class="docutils literal notranslate"><span class="pre">SCF.get_grad()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.get_hcore"><code class="docutils literal notranslate"><span class="pre">SCF.get_hcore()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.get_init_guess"><code class="docutils literal notranslate"><span class="pre">SCF.get_init_guess()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.get_j"><code class="docutils literal notranslate"><span class="pre">SCF.get_j()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.get_jk"><code class="docutils literal notranslate"><span class="pre">SCF.get_jk()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.get_k"><code class="docutils literal notranslate"><span class="pre">SCF.get_k()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.get_occ"><code class="docutils literal notranslate"><span class="pre">SCF.get_occ()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.get_ovlp"><code class="docutils literal notranslate"><span class="pre">SCF.get_ovlp()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.get_veff"><code class="docutils literal notranslate"><span class="pre">SCF.get_veff()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.init_direct_scf"><code class="docutils literal notranslate"><span class="pre">SCF.init_direct_scf()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.init_guess"><code class="docutils literal notranslate"><span class="pre">SCF.init_guess</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.init_guess_by_1e"><code class="docutils literal notranslate"><span class="pre">SCF.init_guess_by_1e()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.init_guess_by_atom"><code class="docutils literal notranslate"><span class="pre">SCF.init_guess_by_atom()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.init_guess_by_chkfile"><code class="docutils literal notranslate"><span class="pre">SCF.init_guess_by_chkfile()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.init_guess_by_huckel"><code class="docutils literal notranslate"><span class="pre">SCF.init_guess_by_huckel()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.init_guess_by_minao"><code class="docutils literal notranslate"><span class="pre">SCF.init_guess_by_minao()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.init_guess_by_mod_huckel"><code class="docutils literal notranslate"><span class="pre">SCF.init_guess_by_mod_huckel()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.init_guess_by_sap"><code class="docutils literal notranslate"><span class="pre">SCF.init_guess_by_sap()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.istype"><code class="docutils literal notranslate"><span class="pre">SCF.istype()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.kernel"><code class="docutils literal notranslate"><span class="pre">SCF.kernel()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.level_shift"><code class="docutils literal notranslate"><span class="pre">SCF.level_shift</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.make_rdm1"><code class="docutils literal notranslate"><span class="pre">SCF.make_rdm1()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.make_rdm2"><code class="docutils literal notranslate"><span class="pre">SCF.make_rdm2()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.max_cycle"><code class="docutils literal notranslate"><span class="pre">SCF.max_cycle</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.mulliken_meta"><code class="docutils literal notranslate"><span class="pre">SCF.mulliken_meta()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.mulliken_pop"><code class="docutils literal notranslate"><span class="pre">SCF.mulliken_pop()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.mulliken_pop_meta_lowdin_ao"><code class="docutils literal notranslate"><span class="pre">SCF.mulliken_pop_meta_lowdin_ao()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.newton"><code class="docutils literal notranslate"><span class="pre">SCF.newton()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.nuc_grad_method"><code class="docutils literal notranslate"><span class="pre">SCF.nuc_grad_method()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.opt"><code class="docutils literal notranslate"><span class="pre">SCF.opt</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.pop"><code class="docutils literal notranslate"><span class="pre">SCF.pop()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.quad_moment"><code class="docutils literal notranslate"><span class="pre">SCF.quad_moment()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.remove_soscf"><code class="docutils literal notranslate"><span class="pre">SCF.remove_soscf()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.reset"><code class="docutils literal notranslate"><span class="pre">SCF.reset()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.sap_basis"><code class="docutils literal notranslate"><span class="pre">SCF.sap_basis</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.scf"><code class="docutils literal notranslate"><span class="pre">SCF.scf()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.sfx2c1e"><code class="docutils literal notranslate"><span class="pre">SCF.sfx2c1e()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.stability"><code class="docutils literal notranslate"><span class="pre">SCF.stability()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.to_ghf"><code class="docutils literal notranslate"><span class="pre">SCF.to_ghf()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.to_gks"><code class="docutils literal notranslate"><span class="pre">SCF.to_gks()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.to_gpu"><code class="docutils literal notranslate"><span class="pre">SCF.to_gpu()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.to_ks"><code class="docutils literal notranslate"><span class="pre">SCF.to_ks()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.to_rhf"><code class="docutils literal notranslate"><span class="pre">SCF.to_rhf()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.to_rks"><code class="docutils literal notranslate"><span class="pre">SCF.to_rks()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.to_uhf"><code class="docutils literal notranslate"><span class="pre">SCF.to_uhf()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.to_uks"><code class="docutils literal notranslate"><span class="pre">SCF.to_uks()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.update"><code class="docutils literal notranslate"><span class="pre">SCF.update()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.update_"><code class="docutils literal notranslate"><span class="pre">SCF.update_()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.update_from_chk"><code class="docutils literal notranslate"><span class="pre">SCF.update_from_chk()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.update_from_chk_"><code class="docutils literal notranslate"><span class="pre">SCF.update_from_chk_()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.x2c"><code class="docutils literal notranslate"><span class="pre">SCF.x2c()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF.x2c1e"><code class="docutils literal notranslate"><span class="pre">SCF.x2c1e()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.SCF_Scanner"><code class="docutils literal notranslate"><span class="pre">SCF_Scanner</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.analyze"><code class="docutils literal notranslate"><span class="pre">analyze()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.as_scanner"><code class="docutils literal notranslate"><span class="pre">as_scanner()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.canonicalize"><code class="docutils literal notranslate"><span class="pre">canonicalize()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.damping"><code class="docutils literal notranslate"><span class="pre">damping()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.dip_moment"><code class="docutils literal notranslate"><span class="pre">dip_moment()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.dot_eri_dm"><code class="docutils literal notranslate"><span class="pre">dot_eri_dm()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.dump_scf_summary"><code class="docutils literal notranslate"><span class="pre">dump_scf_summary()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.eig"><code class="docutils literal notranslate"><span class="pre">eig()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.energy_elec"><code class="docutils literal notranslate"><span class="pre">energy_elec()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.energy_tot"><code class="docutils literal notranslate"><span class="pre">energy_tot()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.get_fock"><code class="docutils literal notranslate"><span class="pre">get_fock()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.get_grad"><code class="docutils literal notranslate"><span class="pre">get_grad()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.get_hcore"><code class="docutils literal notranslate"><span class="pre">get_hcore()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.get_init_guess"><code class="docutils literal notranslate"><span class="pre">get_init_guess()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.get_jk"><code class="docutils literal notranslate"><span class="pre">get_jk()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.get_occ"><code class="docutils literal notranslate"><span class="pre">get_occ()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.get_ovlp"><code class="docutils literal notranslate"><span class="pre">get_ovlp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.get_veff"><code class="docutils literal notranslate"><span class="pre">get_veff()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.init_guess_by_1e"><code class="docutils literal notranslate"><span class="pre">init_guess_by_1e()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.init_guess_by_atom"><code class="docutils literal notranslate"><span class="pre">init_guess_by_atom()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.init_guess_by_chkfile"><code class="docutils literal notranslate"><span class="pre">init_guess_by_chkfile()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.init_guess_by_huckel"><code class="docutils literal notranslate"><span class="pre">init_guess_by_huckel()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.init_guess_by_minao"><code class="docutils literal notranslate"><span class="pre">init_guess_by_minao()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.init_guess_by_mod_huckel"><code class="docutils literal notranslate"><span class="pre">init_guess_by_mod_huckel()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.init_guess_by_sap"><code class="docutils literal notranslate"><span class="pre">init_guess_by_sap()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.kernel"><code class="docutils literal notranslate"><span class="pre">kernel()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.level_shift"><code class="docutils literal notranslate"><span class="pre">level_shift()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.make_rdm1"><code class="docutils literal notranslate"><span class="pre">make_rdm1()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.make_rdm2"><code class="docutils literal notranslate"><span class="pre">make_rdm2()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.make_sap"><code class="docutils literal notranslate"><span class="pre">make_sap()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.mulliken_meta"><code class="docutils literal notranslate"><span class="pre">mulliken_meta()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.mulliken_pop"><code class="docutils literal notranslate"><span class="pre">mulliken_pop()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.mulliken_pop_meta_lowdin_ao"><code class="docutils literal notranslate"><span class="pre">mulliken_pop_meta_lowdin_ao()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.pack_uniq_var"><code class="docutils literal notranslate"><span class="pre">pack_uniq_var()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.quad_moment"><code class="docutils literal notranslate"><span class="pre">quad_moment()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.uniq_var_indices"><code class="docutils literal notranslate"><span class="pre">uniq_var_indices()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf.unpack_uniq_var"><code class="docutils literal notranslate"><span class="pre">unpack_uniq_var()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.hf_symm">pyscf.scf.hf_symm module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.HF1e"><code class="docutils literal notranslate"><span class="pre">HF1e</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.HF1e.scf"><code class="docutils literal notranslate"><span class="pre">HF1e.scf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.RHF"><code class="docutils literal notranslate"><span class="pre">RHF</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.ROHF"><code class="docutils literal notranslate"><span class="pre">ROHF</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.CASCI"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.CASCI()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.CASSCF"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.CASSCF()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.analyze"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.analyze()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.build"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.build()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.canonicalize"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.canonicalize()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.eig"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.eig()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.get_grad"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.get_grad()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.get_irrep_nelec"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.get_irrep_nelec()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.get_occ"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.get_occ()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.get_orbsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.get_orbsym()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.get_wfnsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.get_wfnsym()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.orbsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.orbsym</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.to_gpu"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.to_gpu()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedRHF.wfnsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedRHF.wfnsym</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.CASCI"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.CASCI()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.CASSCF"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.CASSCF()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.TDA"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.TDA</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.TDHF"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.TDHF</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.analyze"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.analyze()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.build"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.build()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.canonicalize"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.canonicalize()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.dump_flags"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.dump_flags()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.eig"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.eig()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.get_grad"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.get_grad()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.get_irrep_nelec"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.get_irrep_nelec()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.get_occ"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.get_occ()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.get_orbsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.get_orbsym()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.get_wfnsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.get_wfnsym()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.make_rdm1"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.make_rdm1()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.orbsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.orbsym</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.to_gpu"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.to_gpu()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.SymAdaptedROHF.wfnsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedROHF.wfnsym</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.analyze"><code class="docutils literal notranslate"><span class="pre">analyze()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.canonicalize"><code class="docutils literal notranslate"><span class="pre">canonicalize()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.check_irrep_nelec"><code class="docutils literal notranslate"><span class="pre">check_irrep_nelec()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.eig"><code class="docutils literal notranslate"><span class="pre">eig()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.get_irrep_nelec"><code class="docutils literal notranslate"><span class="pre">get_irrep_nelec()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.get_orbsym"><code class="docutils literal notranslate"><span class="pre">get_orbsym()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.get_wfnsym"><code class="docutils literal notranslate"><span class="pre">get_wfnsym()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.map_degeneracy"><code class="docutils literal notranslate"><span class="pre">map_degeneracy()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.hf_symm.so2ao_mo_coeff"><code class="docutils literal notranslate"><span class="pre">so2ao_mo_coeff()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.jk">pyscf.scf.jk module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.jk.get_jk"><code class="docutils literal notranslate"><span class="pre">get_jk()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.jk.jk_build"><code class="docutils literal notranslate"><span class="pre">jk_build()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.rohf">pyscf.scf.rohf module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.HF1e"><code class="docutils literal notranslate"><span class="pre">HF1e</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.HF1e.scf"><code class="docutils literal notranslate"><span class="pre">HF1e.scf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF"><code class="docutils literal notranslate"><span class="pre">ROHF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.CASCI"><code class="docutils literal notranslate"><span class="pre">ROHF.CASCI()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.CASSCF"><code class="docutils literal notranslate"><span class="pre">ROHF.CASSCF()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.CISD"><code class="docutils literal notranslate"><span class="pre">ROHF.CISD</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.DFMP2"><code class="docutils literal notranslate"><span class="pre">ROHF.DFMP2</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.Gradients"><code class="docutils literal notranslate"><span class="pre">ROHF.Gradients()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.MP2"><code class="docutils literal notranslate"><span class="pre">ROHF.MP2</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.TDA"><code class="docutils literal notranslate"><span class="pre">ROHF.TDA</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.TDHF"><code class="docutils literal notranslate"><span class="pre">ROHF.TDHF</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.analyze"><code class="docutils literal notranslate"><span class="pre">ROHF.analyze()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.canonicalize"><code class="docutils literal notranslate"><span class="pre">ROHF.canonicalize()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.check_sanity"><code class="docutils literal notranslate"><span class="pre">ROHF.check_sanity()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.convert_from_"><code class="docutils literal notranslate"><span class="pre">ROHF.convert_from_()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.dump_flags"><code class="docutils literal notranslate"><span class="pre">ROHF.dump_flags()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.eig"><code class="docutils literal notranslate"><span class="pre">ROHF.eig()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.energy_elec"><code class="docutils literal notranslate"><span class="pre">ROHF.energy_elec()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.gen_response"><code class="docutils literal notranslate"><span class="pre">ROHF.gen_response()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.get_fock"><code class="docutils literal notranslate"><span class="pre">ROHF.get_fock()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.get_grad"><code class="docutils literal notranslate"><span class="pre">ROHF.get_grad()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.get_init_guess"><code class="docutils literal notranslate"><span class="pre">ROHF.get_init_guess()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.get_occ"><code class="docutils literal notranslate"><span class="pre">ROHF.get_occ()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.get_veff"><code class="docutils literal notranslate"><span class="pre">ROHF.get_veff()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.init_guess_by_1e"><code class="docutils literal notranslate"><span class="pre">ROHF.init_guess_by_1e()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.init_guess_by_atom"><code class="docutils literal notranslate"><span class="pre">ROHF.init_guess_by_atom()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.init_guess_by_chkfile"><code class="docutils literal notranslate"><span class="pre">ROHF.init_guess_by_chkfile()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.init_guess_by_huckel"><code class="docutils literal notranslate"><span class="pre">ROHF.init_guess_by_huckel()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.init_guess_by_minao"><code class="docutils literal notranslate"><span class="pre">ROHF.init_guess_by_minao()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.init_guess_by_mod_huckel"><code class="docutils literal notranslate"><span class="pre">ROHF.init_guess_by_mod_huckel()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.init_guess_by_sap"><code class="docutils literal notranslate"><span class="pre">ROHF.init_guess_by_sap()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.make_rdm1"><code class="docutils literal notranslate"><span class="pre">ROHF.make_rdm1()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.nelec"><code class="docutils literal notranslate"><span class="pre">ROHF.nelec</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.nelectron_alpha"><code class="docutils literal notranslate"><span class="pre">ROHF.nelectron_alpha</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.nuc_grad_method"><code class="docutils literal notranslate"><span class="pre">ROHF.nuc_grad_method()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.spin_square"><code class="docutils literal notranslate"><span class="pre">ROHF.spin_square()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.stability"><code class="docutils literal notranslate"><span class="pre">ROHF.stability()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.to_gpu"><code class="docutils literal notranslate"><span class="pre">ROHF.to_gpu()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.ROHF.to_ks"><code class="docutils literal notranslate"><span class="pre">ROHF.to_ks()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.analyze"><code class="docutils literal notranslate"><span class="pre">analyze()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.canonicalize"><code class="docutils literal notranslate"><span class="pre">canonicalize()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.energy_elec"><code class="docutils literal notranslate"><span class="pre">energy_elec()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.get_fock"><code class="docutils literal notranslate"><span class="pre">get_fock()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.get_grad"><code class="docutils literal notranslate"><span class="pre">get_grad()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.get_occ"><code class="docutils literal notranslate"><span class="pre">get_occ()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.get_roothaan_fock"><code class="docutils literal notranslate"><span class="pre">get_roothaan_fock()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.init_guess_by_atom"><code class="docutils literal notranslate"><span class="pre">init_guess_by_atom()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.init_guess_by_chkfile"><code class="docutils literal notranslate"><span class="pre">init_guess_by_chkfile()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.init_guess_by_minao"><code class="docutils literal notranslate"><span class="pre">init_guess_by_minao()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.init_guess_by_sap"><code class="docutils literal notranslate"><span class="pre">init_guess_by_sap()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.rohf.make_rdm1"><code class="docutils literal notranslate"><span class="pre">make_rdm1()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.stability">pyscf.scf.stability module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability.dhf_stability"><code class="docutils literal notranslate"><span class="pre">dhf_stability()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability.dump_status"><code class="docutils literal notranslate"><span class="pre">dump_status()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability.ghf_stability"><code class="docutils literal notranslate"><span class="pre">ghf_stability()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability.rhf_external"><code class="docutils literal notranslate"><span class="pre">rhf_external()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability.rhf_internal"><code class="docutils literal notranslate"><span class="pre">rhf_internal()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability.rhf_stability"><code class="docutils literal notranslate"><span class="pre">rhf_stability()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability.rohf_external"><code class="docutils literal notranslate"><span class="pre">rohf_external()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability.rohf_internal"><code class="docutils literal notranslate"><span class="pre">rohf_internal()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability.rohf_stability"><code class="docutils literal notranslate"><span class="pre">rohf_stability()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability.uhf_external"><code class="docutils literal notranslate"><span class="pre">uhf_external()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability.uhf_internal"><code class="docutils literal notranslate"><span class="pre">uhf_internal()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability.uhf_stability"><code class="docutils literal notranslate"><span class="pre">uhf_stability()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.stability_slow">pyscf.scf.stability_slow module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability_slow.rhf_external"><code class="docutils literal notranslate"><span class="pre">rhf_external()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability_slow.rhf_internal"><code class="docutils literal notranslate"><span class="pre">rhf_internal()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability_slow.rhf_stability"><code class="docutils literal notranslate"><span class="pre">rhf_stability()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability_slow.uhf_external"><code class="docutils literal notranslate"><span class="pre">uhf_external()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability_slow.uhf_internal"><code class="docutils literal notranslate"><span class="pre">uhf_internal()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.stability_slow.uhf_stability"><code class="docutils literal notranslate"><span class="pre">uhf_stability()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.ucphf">pyscf.scf.ucphf module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ucphf.kernel"><code class="docutils literal notranslate"><span class="pre">kernel()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ucphf.solve"><code class="docutils literal notranslate"><span class="pre">solve()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ucphf.solve_nos1"><code class="docutils literal notranslate"><span class="pre">solve_nos1()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ucphf.solve_withs1"><code class="docutils literal notranslate"><span class="pre">solve_withs1()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.uhf">pyscf.scf.uhf module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.HF1e"><code class="docutils literal notranslate"><span class="pre">HF1e</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.HF1e.scf"><code class="docutils literal notranslate"><span class="pre">HF1e.scf()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.HF1e.spin_square"><code class="docutils literal notranslate"><span class="pre">HF1e.spin_square()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF"><code class="docutils literal notranslate"><span class="pre">UHF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.CASCI"><code class="docutils literal notranslate"><span class="pre">UHF.CASCI</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.CASSCF"><code class="docutils literal notranslate"><span class="pre">UHF.CASSCF</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.CISD"><code class="docutils literal notranslate"><span class="pre">UHF.CISD()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.DFMP2"><code class="docutils literal notranslate"><span class="pre">UHF.DFMP2</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.Gradients"><code class="docutils literal notranslate"><span class="pre">UHF.Gradients()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.MP2"><code class="docutils literal notranslate"><span class="pre">UHF.MP2()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.TDA"><code class="docutils literal notranslate"><span class="pre">UHF.TDA()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.TDHF"><code class="docutils literal notranslate"><span class="pre">UHF.TDHF()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.analyze"><code class="docutils literal notranslate"><span class="pre">UHF.analyze()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.canonicalize"><code class="docutils literal notranslate"><span class="pre">UHF.canonicalize()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.convert_from_"><code class="docutils literal notranslate"><span class="pre">UHF.convert_from_()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.det_ovlp"><code class="docutils literal notranslate"><span class="pre">UHF.det_ovlp()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.dump_flags"><code class="docutils literal notranslate"><span class="pre">UHF.dump_flags()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.eig"><code class="docutils literal notranslate"><span class="pre">UHF.eig()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.energy_elec"><code class="docutils literal notranslate"><span class="pre">UHF.energy_elec()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.gen_response"><code class="docutils literal notranslate"><span class="pre">UHF.gen_response()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.get_fock"><code class="docutils literal notranslate"><span class="pre">UHF.get_fock()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.get_grad"><code class="docutils literal notranslate"><span class="pre">UHF.get_grad()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.get_init_guess"><code class="docutils literal notranslate"><span class="pre">UHF.get_init_guess()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.get_jk"><code class="docutils literal notranslate"><span class="pre">UHF.get_jk()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.get_occ"><code class="docutils literal notranslate"><span class="pre">UHF.get_occ()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.get_veff"><code class="docutils literal notranslate"><span class="pre">UHF.get_veff()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.init_guess_breaksym"><code class="docutils literal notranslate"><span class="pre">UHF.init_guess_breaksym</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.init_guess_by_1e"><code class="docutils literal notranslate"><span class="pre">UHF.init_guess_by_1e()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.init_guess_by_atom"><code class="docutils literal notranslate"><span class="pre">UHF.init_guess_by_atom()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.init_guess_by_chkfile"><code class="docutils literal notranslate"><span class="pre">UHF.init_guess_by_chkfile()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.init_guess_by_huckel"><code class="docutils literal notranslate"><span class="pre">UHF.init_guess_by_huckel()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.init_guess_by_minao"><code class="docutils literal notranslate"><span class="pre">UHF.init_guess_by_minao()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.init_guess_by_mod_huckel"><code class="docutils literal notranslate"><span class="pre">UHF.init_guess_by_mod_huckel()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.init_guess_by_sap"><code class="docutils literal notranslate"><span class="pre">UHF.init_guess_by_sap()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.make_asym_dm"><code class="docutils literal notranslate"><span class="pre">UHF.make_asym_dm()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.make_rdm1"><code class="docutils literal notranslate"><span class="pre">UHF.make_rdm1()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.make_rdm2"><code class="docutils literal notranslate"><span class="pre">UHF.make_rdm2()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.mulliken_meta"><code class="docutils literal notranslate"><span class="pre">UHF.mulliken_meta()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.mulliken_meta_spin"><code class="docutils literal notranslate"><span class="pre">UHF.mulliken_meta_spin()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.mulliken_pop"><code class="docutils literal notranslate"><span class="pre">UHF.mulliken_pop()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.mulliken_spin_pop"><code class="docutils literal notranslate"><span class="pre">UHF.mulliken_spin_pop()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.nelec"><code class="docutils literal notranslate"><span class="pre">UHF.nelec</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.nelectron_alpha"><code class="docutils literal notranslate"><span class="pre">UHF.nelectron_alpha</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.nuc_grad_method"><code class="docutils literal notranslate"><span class="pre">UHF.nuc_grad_method()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.spin_square"><code class="docutils literal notranslate"><span class="pre">UHF.spin_square()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.stability"><code class="docutils literal notranslate"><span class="pre">UHF.stability()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.to_gpu"><code class="docutils literal notranslate"><span class="pre">UHF.to_gpu()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.UHF.to_ks"><code class="docutils literal notranslate"><span class="pre">UHF.to_ks()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.analyze"><code class="docutils literal notranslate"><span class="pre">analyze()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.canonicalize"><code class="docutils literal notranslate"><span class="pre">canonicalize()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.det_ovlp"><code class="docutils literal notranslate"><span class="pre">det_ovlp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.energy_elec"><code class="docutils literal notranslate"><span class="pre">energy_elec()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.get_fock"><code class="docutils literal notranslate"><span class="pre">get_fock()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.get_grad"><code class="docutils literal notranslate"><span class="pre">get_grad()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.get_init_guess"><code class="docutils literal notranslate"><span class="pre">get_init_guess()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.get_occ"><code class="docutils literal notranslate"><span class="pre">get_occ()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.get_veff"><code class="docutils literal notranslate"><span class="pre">get_veff()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.init_guess_by_1e"><code class="docutils literal notranslate"><span class="pre">init_guess_by_1e()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.init_guess_by_atom"><code class="docutils literal notranslate"><span class="pre">init_guess_by_atom()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.init_guess_by_chkfile"><code class="docutils literal notranslate"><span class="pre">init_guess_by_chkfile()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.init_guess_by_huckel"><code class="docutils literal notranslate"><span class="pre">init_guess_by_huckel()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.init_guess_by_minao"><code class="docutils literal notranslate"><span class="pre">init_guess_by_minao()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.init_guess_by_mod_huckel"><code class="docutils literal notranslate"><span class="pre">init_guess_by_mod_huckel()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.init_guess_by_sap"><code class="docutils literal notranslate"><span class="pre">init_guess_by_sap()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.make_asym_dm"><code class="docutils literal notranslate"><span class="pre">make_asym_dm()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.make_rdm1"><code class="docutils literal notranslate"><span class="pre">make_rdm1()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.make_rdm2"><code class="docutils literal notranslate"><span class="pre">make_rdm2()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.mulliken_meta"><code class="docutils literal notranslate"><span class="pre">mulliken_meta()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.mulliken_meta_spin"><code class="docutils literal notranslate"><span class="pre">mulliken_meta_spin()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.mulliken_pop"><code class="docutils literal notranslate"><span class="pre">mulliken_pop()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.mulliken_pop_meta_lowdin_ao"><code class="docutils literal notranslate"><span class="pre">mulliken_pop_meta_lowdin_ao()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.mulliken_spin_pop"><code class="docutils literal notranslate"><span class="pre">mulliken_spin_pop()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.mulliken_spin_pop_meta_lowdin_ao"><code class="docutils literal notranslate"><span class="pre">mulliken_spin_pop_meta_lowdin_ao()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf.spin_square"><code class="docutils literal notranslate"><span class="pre">spin_square()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf.uhf_symm">pyscf.scf.uhf_symm module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.HF1e"><code class="docutils literal notranslate"><span class="pre">HF1e</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.HF1e.scf"><code class="docutils literal notranslate"><span class="pre">HF1e.scf()</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.CASCI"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.CASCI</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.CASSCF"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.CASSCF</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.analyze"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.analyze()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.build"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.build()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.canonicalize"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.canonicalize()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.dump_flags"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.dump_flags()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.eig"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.eig()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.get_grad"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.get_grad()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.get_irrep_nelec"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.get_irrep_nelec()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.get_occ"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.get_occ()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.get_orbsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.get_orbsym()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.get_wfnsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.get_wfnsym()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.orbsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.orbsym</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.to_gpu"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.to_gpu()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.SymAdaptedUHF.wfnsym"><code class="docutils literal notranslate"><span class="pre">SymAdaptedUHF.wfnsym</span></code></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.UHF"><code class="docutils literal notranslate"><span class="pre">UHF</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.analyze"><code class="docutils literal notranslate"><span class="pre">analyze()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.canonicalize"><code class="docutils literal notranslate"><span class="pre">canonicalize()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.get_irrep_nelec"><code class="docutils literal notranslate"><span class="pre">get_irrep_nelec()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.get_orbsym"><code class="docutils literal notranslate"><span class="pre">get_orbsym()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.uhf_symm.get_wfnsym"><code class="docutils literal notranslate"><span class="pre">get_wfnsym()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-pyscf.scf">Module contents</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hartree-fock">Hartree-Fock</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.DHF"><code class="docutils literal notranslate"><span class="pre">DHF()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.DKS"><code class="docutils literal notranslate"><span class="pre">DKS()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.GHF"><code class="docutils literal notranslate"><span class="pre">GHF()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.GKS"><code class="docutils literal notranslate"><span class="pre">GKS()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.HF"><code class="docutils literal notranslate"><span class="pre">HF()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.KS"><code class="docutils literal notranslate"><span class="pre">KS()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.RHF"><code class="docutils literal notranslate"><span class="pre">RHF()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.RKS"><code class="docutils literal notranslate"><span class="pre">RKS()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ROHF"><code class="docutils literal notranslate"><span class="pre">ROHF()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.ROKS"><code class="docutils literal notranslate"><span class="pre">ROKS()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.UHF"><code class="docutils literal notranslate"><span class="pre">UHF()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.UKS"><code class="docutils literal notranslate"><span class="pre">UKS()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.X2C"><code class="docutils literal notranslate"><span class="pre">X2C()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.X2C_HF"><code class="docutils literal notranslate"><span class="pre">X2C_HF()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.density_fit"><code class="docutils literal notranslate"><span class="pre">density_fit()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.newton"><code class="docutils literal notranslate"><span class="pre">newton()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.sfx2c"><code class="docutils literal notranslate"><span class="pre">sfx2c()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pyscf.scf.sfx2c1e"><code class="docutils literal notranslate"><span class="pre">sfx2c1e()</span></code></a></li>
</ul>
</li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">

  
  <div class="tocsection editthispage">
    <a href="https://github.com/pyscf/pyscf.github.io/edit/master/source/pyscf_api_docs/pyscf.scf.rst">
      <i class="fa-solid fa-pencil"></i>
      
      
        
          Edit on GitHub
        
      
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2024, The PySCF Developers.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>