
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>pbc.scf — Self-consistent field with periodic boundary conditions &#8212; PySCF 2.0.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/material.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../../../_static/favicon-32x32.png"/>
    <link rel="author" title="About these documents" href="../../../about/" />
    <link rel="index" title="Index" href="../../../genindex/" />
    <link rel="search" title="Search" href="../../../search/" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=indigo data-md-color-accent=amber>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#modules/pbc/scf" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../../" title="PySCF 2.0.0 documentation"
           class="md-header-nav__button md-logo">
          
              <img src="../../../_static/pyscf-logo-white.svg" height="26"
                   alt="PySCF 2.0.0 documentation logo">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">PySCF 2.0</span>
          <span class="md-header-nav__topic"> pbc.scf — Self-consistent field with periodic boundary conditions </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../../search/" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/pyscf/pyscf/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    PySCF
  </div>
</a>
          </div>
        </div>
      
      
  
  <script src="../../../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../../../"versions.json"",
        target_loc = "../../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
            
            <li class="md-tabs__item"><a href="../../../" class="md-tabs__link">Home</a></li>
            
            <li class="md-tabs__item"><a href="../../../overview/" class="md-tabs__link">Overview</a></li>
            
            <li class="md-tabs__item"><a href="../../../install/" class="md-tabs__link">Install</a></li>
            
            <li class="md-tabs__item"><a href="../../../quickstart/" class="md-tabs__link">Quickstart</a></li>
            
            <li class="md-tabs__item"><a href="../../../user/" class="md-tabs__link">User Guide</a></li>
            
            <li class="md-tabs__item"><a href="../../../pyscf_api_docs/modules/" class="md-tabs__link">API</a></li>
            
            <li class="md-tabs__item"><a href="../../../about/" class="md-tabs__link">About</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../../" title="PySCF 2.0.0 documentation" class="md-nav__button md-logo">
      
        <img src="../../../_static/pyscf-logo-white.svg" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../../../"
       title="PySCF 2.0.0 documentation">PySCF 2.0</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/pyscf/pyscf/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    PySCF
  </div>
</a>
    </div>
  
  

  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
    
      <a href="../../../overview/" class="md-nav__link">1. Overview</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../install/" class="md-nav__link">2. Install</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../quickstart/" class="md-nav__link">3. Quickstart</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../user/" class="md-nav__link">4. User Guide</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../pyscf_api_docs/pyscf/" class="md-nav__link">5. API</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../interface/" class="md-nav__link">6. Interface</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../about/" class="md-nav__link">7. About</a>
      
    
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
    <label class="md-nav__title" for="__toc">Contents</label>
  <ul class="md-nav__list" data-md-scrollfix="">
        <li class="md-nav__item"><a href="#modules-pbc-scf--page-root" class="md-nav__link"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pbc.scf</span></code> — Self-consistent field with periodic boundary conditions</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#gamma-point-and-single-k-point-calculation" class="md-nav__link">Gamma point and single k-point calculation</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#mixing-with-molecular-program-for-post-hf-methods" class="md-nav__link">Mixing with molecular program for post-HF methods</a>
        </li></ul>
            </nav>
        </li>
        <li class="md-nav__item"><a href="#k-point-sampling" class="md-nav__link">k-point sampling</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#smearing" class="md-nav__link">Smearing</a>
        </li></ul>
            </nav>
        </li>
        <li class="md-nav__item"><a href="#exchange-divergence-treatment" class="md-nav__link">Exchange divergence treatment</a>
        </li>
        <li class="md-nav__item"><a href="#gaussian-density-fitting" class="md-nav__link">Gaussian density fitting</a>
        </li>
        <li class="md-nav__item"><a href="#module-pyscf.pbc.scf.hf" class="md-nav__link">Program reference</a>
        </li></ul>
            </nav>
        </li>
    
<li class="md-nav__item"><a class="md-nav__extra_link" href="../../../_sources/modules/pbc/scf.rst.txt">Show Source</a> </li>

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  
<span id="pbc-scf-self-consistent-field-with-periodic-boundary-conditions"></span><span id="pbc-scf"></span><h1 id="modules-pbc-scf--page-root"><a class="reference internal" href="#modules-pbc-scf--page-root" title="pbc.scf: Hartree-Fock methods with periodic boundary conditions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pbc.scf</span></code></a> — Self-consistent field with periodic boundary conditions<a class="headerlink" href="#modules-pbc-scf--page-root" title="Permalink to this headline">¶</a></h1>
<p>This module is constructed to be analogous to the molecular <a class="reference internal" href="../../scf/#module-scf" title="scf: restricted and unrestricted, closed shell and open shell Hartree-Fock methods"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scf</span></code></a> module to handle
mean-field calculations with periodic boundary conditions.</p>

<h2 id="gamma-point-and-single-k-point-calculation">Gamma point and single k-point calculation<a class="headerlink" href="#gamma-point-and-single-k-point-calculation" title="Permalink to this headline">¶</a></h2>
<p>The usage of the Gamma point Hartree-Fock program is very close to that of the
molecular program.  In a PBC Gamma point calculation, one needs to initialize the
<code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object and the corresponding <a class="reference internal" href="../../../pyscf_api_docs/pyscf.pbc.scf/#pyscf.pbc.scf.hf.RHF" title="pyscf.pbc.scf.hf.RHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.pbc.scf.hf.RHF</span></code></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">'''H     0.      0.      0.</span>
<span class="s1">              H     0.8917  0.8917  0.8917'''</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">'sto3g'</span><span class="p">,</span>
    <span class="n">h</span> <span class="o">=</span> <span class="s1">'''</span>
<span class="s1">    0       1.7834  1.7834</span>
<span class="s1">    1.7834  0       1.7834</span>
<span class="s1">    1.7834  1.7834  0     '''</span><span class="p">,</span>
    <span class="n">gs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>Compared to the <a class="reference internal" href="../../../pyscf_api_docs/pyscf.scf/#pyscf.scf.hf.RHF" title="pyscf.scf.hf.RHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.scf.hf.RHF</span></code></a> object for molecular calculations,
the PBC-HF calculation with <a class="reference internal" href="../../../pyscf_api_docs/pyscf.pbc.scf/#pyscf.pbc.scf.hf.RHF" title="pyscf.pbc.scf.hf.RHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.pbc.scf.hf.RHF</span></code></a> or
<a class="reference internal" href="../../../pyscf_api_docs/pyscf.pbc.scf/#pyscf.pbc.scf.uhf.UHF" title="pyscf.pbc.scf.uhf.UHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.pbc.scf.uhf.UHF</span></code></a> has three differences</p>
<ul>
<li><p><a class="reference internal" href="../../../pyscf_api_docs/pyscf.pbc.scf/#pyscf.pbc.scf.hf.RHF" title="pyscf.pbc.scf.hf.RHF"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.pbc.scf.hf.RHF</span></code></a> is the single k-point PBC HF class.  By default,
it creates a Gamma point instance.  You can change to other (single) k-points by
setting the <code class="xref py py-attr docutils literal notranslate"><span class="pre">kpt</span></code> attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kpt</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_abs_kpts</span><span class="p">([</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="o">.</span><span class="mi">25</span><span class="p">])</span>  <span class="c1"># convert from scaled kpts</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p>The exchange integrals of the PBC Hartree-Fock method show a slow convergence
with respect to the number of k-points.  A proper treatment for the divergent
part of the exchange integral can improve the convergence.  The attribute
<code class="xref py py-attr docutils literal notranslate"><span class="pre">exxdiv</span></code> is used to control the method to handle the divergent exchange
term.  The default <code class="docutils literal notranslate"><span class="pre">exxdiv='ewald'</span></code> can be used for most scenarios.  However,
if molecular post-HF methods are mixed with the Gamma point mean-field methods (see
<a class="reference internal" href="#mix-to-mol"><span class="std std-ref">Mixing with molecular program for post-HF methods</span></a>, you will need to explicitly use <code class="docutils literal notranslate"><span class="pre">exxdiv=None</span></code> to obtain a consistent total
energy (see <a class="reference internal" href="#exxdiv"><span class="std std-ref">Exchange divergence treatment</span></a>). If PBC post-HF methods are used, the <code class="xref py py-mod docutils literal notranslate"><span class="pre">exxdiv</span></code> attribute
is always treated as <code class="docutils literal notranslate"><span class="pre">None</span></code> in the correlated calculation to obtain a consistent total energy.</p></li>
<li><p>In PBC calculations there are different choices for how to
evaluate 2-electron integrals.  The default integral scheme (FFTDF) is accurate   for pseudo-potentials and fast for DFT calculations but
slow in other scenarios. A second integral
scheme which is a good balance of speed and accuracy for
Hartree-Fock, all-electron, and post-Hartree-Fock calculations, is
Gaussian density fitting. This can be used by setting the <code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df</span></code> attribute (see <a class="reference internal" href="../df/#pbc-df"><span class="std std-ref">pbc.df — PBC denisty fitting</span></a>) or, conveniently, by using the <code class="xref py py-func docutils literal notranslate"><span class="pre">density_fit()</span></code> function (see <a class="reference internal" href="#pbc-density-fit"><span class="std std-ref">Gaussian density fitting</span></a>). For</p></li>
</ul>
<dl class="simple">
<dt>higher accuracy, you may wish to use</dt><dd><p>mixed density fitting (MDF) (see <a class="reference internal" href="../df/#pbc-mdf"><span class="std std-ref">MDF — mixed density fitting</span></a>).  Here is an example to update <code class="xref py py-attr docutils literal notranslate"><span class="pre">with_df</span></code></p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">'''</span>
<span class="sd">Gamma point Hartree-Fock/DFT for all-electron calculation</span>

<span class="sd">The default FFT-based 2-electron integrals may not be accurate enough for</span>
<span class="sd">all-electron calculation.  It's recommended to use MDF (mixed density fitting)</span>
<span class="sd">technique to improve the accuracy.</span>

<span class="sd">See also</span>
<span class="sd">examples/df/00-with_df.py</span>
<span class="sd">examples/df/01-auxbasis.py</span>
<span class="sd">examples/df/40-precomupte_df_ints.py</span>
<span class="sd">'''</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">dft</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mf">3.5668</span><span class="p">,</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">'''C     0.      0.      0.    </span>
<span class="s1">              C     0.8917  0.8917  0.8917</span>
<span class="s1">              C     1.7834  1.7834  0.    </span>
<span class="s1">              C     2.6751  2.6751  0.8917</span>
<span class="s1">              C     1.7834  0.      1.7834</span>
<span class="s1">              C     2.6751  0.8917  2.6751</span>
<span class="s1">              C     0.      1.7834  1.7834</span>
<span class="s1">              C     0.8917  2.6751  2.6751'''</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">'6-31g'</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1"># Mixed density fitting is another option for all-electron calculations</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">mix_density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span>  <span class="c1"># Tune #PWs in MDF for performance/accuracy balance</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1"># Or use even-tempered Gaussian basis as auxiliary fitting functions.</span>
<span class="c1"># The following auxbasis is generated based on the expression</span>
<span class="c1">#    alpha = a * 1.7^i   i = 0..N</span>
<span class="c1"># where a and N are determined by the smallest and largest exponents of AO basis.</span>
<span class="kn">import</span> <span class="nn">pyscf.df</span>
<span class="n">auxbasis</span> <span class="o">=</span> <span class="n">pyscf</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">aug_etb</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.7</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">(</span><span class="n">auxbasis</span><span class="o">=</span><span class="n">auxbasis</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># Second order SCF solver can be used in the PBC SCF code the same way in the</span>
<span class="c1"># molecular calculation</span>
<span class="c1">#</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">(</span><span class="n">auxbasis</span><span class="o">=</span><span class="s1">'weigend'</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="s1">'bp86'</span>
<span class="c1"># You should first set mf.xc then apply newton method (see also</span>
<span class="c1"># examples/scf/22-newton.py)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">newton</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># The computational costs to initialize PBC DF object is high.  The density</span>
<span class="c1"># fitting integral tensor created in the initialization can be cached for</span>
<span class="c1"># future use.  See also examples/df/40-precomupte_df_ints.py</span>
<span class="c1">#</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">(</span><span class="n">auxbasis</span><span class="o">=</span><span class="s1">'weigend'</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">_cderi_to_save</span> <span class="o">=</span> <span class="s1">'df_ints.h5'</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="c1">#</span>
<span class="c1"># The DF integral tensor can be preloaded in an independent calculation.</span>
<span class="c1">#</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">_cderi</span> <span class="o">=</span> <span class="s1">'df_ints.h5'</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>

<span id="mix-to-mol"></span><h3 id="mixing-with-molecular-program-for-post-hf-methods">Mixing with molecular program for post-HF methods<a class="headerlink" href="#mixing-with-molecular-program-for-post-hf-methods" title="Permalink to this headline">¶</a></h3>
<p>The Gamma point HF code adopts the same code structure, function and
method names and argument’ conventions as the molecular SCF code.
This desgin allows one to mix PBC HF objects with the existing molecular post-HF
code for PBC electron correlation treatments.  A typical molecular post-HF
calculation starts from the finite-size HF method with the <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code>
object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'H 0 0 0; H 0 0 1'</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">'ccpvdz'</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">cc</span>
<span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>The PBC Gamma point post-HF calculation requires the <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object and
PBC HF object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'H 0 0 0; H 0 0 1'</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">'ccpvdz'</span><span class="p">,</span>
             <span class="n">h</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">gs</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">cc</span>
<span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>The differences are the <code class="docutils literal notranslate"><span class="pre">mol</span></code> or <code class="docutils literal notranslate"><span class="pre">cell</span></code> object to create and the
<code class="docutils literal notranslate"><span class="pre">scf</span></code> module to import.  With the system-specific mean-field object, one
can carry out various post-HF methods (MP2, Coupled cluster, CISD, TDHF,
TDDFT, …) using the same code for finite-size and extended systems.
See <a class="reference internal" href="../../../user/pbc/mix_mol/#mix-mol"><span class="std std-ref">Mixing PBC and molecular modules</span></a> for more details of the interface between PBC and molecular
modules.</p>



<h2 id="k-point-sampling">k-point sampling<a class="headerlink" href="#k-point-sampling" title="Permalink to this headline">¶</a></h2>
<p>An example demonstrating the use of k-points for a KRHF, KRKS calculation, and using the Newton (second-order SCF) solver.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">'''</span>
<span class="sd">Mean field with k-points sampling</span>

<span class="sd">The 2-electron integrals are computed using Poisson solver with FFT by default.</span>
<span class="sd">In most scenario, it should be used with pseudo potential.</span>
<span class="sd">'''</span>

<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">dft</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mf">3.5668</span><span class="p">,</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">'''C     0.      0.      0.    </span>
<span class="s1">              C     0.8917  0.8917  0.8917</span>
<span class="s1">              C     1.7834  1.7834  0.    </span>
<span class="s1">              C     2.6751  2.6751  0.8917</span>
<span class="s1">              C     1.7834  0.      1.7834</span>
<span class="s1">              C     2.6751  0.8917  2.6751</span>
<span class="s1">              C     0.      1.7834  1.7834</span>
<span class="s1">              C     0.8917  2.6751  2.6751'''</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">'gth-szv'</span><span class="p">,</span>
    <span class="n">pseudo</span> <span class="o">=</span> <span class="s1">'gth-pade'</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">nk</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>  <span class="c1"># 4 k-points for each axis, 4^3=64 kpts in total</span>
<span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>

<span class="c1"># Note: the default JK builder calls FFTDF scheme which is quite slow for KHF</span>
<span class="c1"># calculations. The gaussian density fitting (GDF) or range-separation</span>
<span class="c1"># integration (rsjk builder) methods are more efficient (see example</span>
<span class="c1"># 21-k_points_all_electron_scf.py)</span>
<span class="n">kmf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">KRHF</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="n">kmf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="n">kmf</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">KRKS</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="c1"># Turn to the atomic grids if you like</span>
<span class="n">kmf</span><span class="o">.</span><span class="n">grids</span> <span class="o">=</span> <span class="n">dft</span><span class="o">.</span><span class="n">gen_grid</span><span class="o">.</span><span class="n">BeckeGrids</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
<span class="n">kmf</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="s1">'m06,m06'</span>
<span class="n">kmf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>


<span class="c1">#</span>
<span class="c1"># Second order SCF solver can be used in the PBC SCF code the same way in the</span>
<span class="c1"># molecular calculation</span>
<span class="c1">#</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">KRHF</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span><span class="o">.</span><span class="n">newton</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

</pre></div>
</div>

<h3 id="smearing">Smearing<a class="headerlink" href="#smearing" title="Permalink to this headline">¶</a></h3>
<p>In many periodic systems, the HOMO-LUMO gap may become very small. In such a case, one needs to use occupation number smearing
to converge the SCF calculation, as illustrated here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Cell</span><span class="p">()</span>
<span class="n">cell</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">'''</span>
<span class="s1">He 0 0 1</span>
<span class="s1">He 1 0 1</span>
<span class="s1">'''</span>
<span class="n">cell</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="s1">'ccpvdz'</span>
<span class="n">cell</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
<span class="n">cell</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">cell</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># Use scf.addons.smearing_ function to modify the</span>
<span class="c1"># PBC (gamma-point or k-points) SCF object</span>
<span class="c1">#</span>
<span class="n">nks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">KRHF</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">(</span><span class="n">nks</span><span class="p">))</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">smearing_</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">'fermi'</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>



<span id="exxdiv"></span><h2 id="exchange-divergence-treatment">Exchange divergence treatment<a class="headerlink" href="#exchange-divergence-treatment" title="Permalink to this headline">¶</a></h2>
<p>The attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">exxdiv</span></code> controls the handling of the slow convergence
of the HF exchange integrals.
Generally, <code class="xref py py-attr docutils literal notranslate"><span class="pre">exxdiv</span></code> leads to a shift in the total energy that
can be thought of as a HF finite size-correction. It also modifies the spectrum of
the occupied orbitals. When a Gamma-point PBC mean-field calculation is mixed with a molecular post-HF implementation, setting this attribute to anything other than <code class="docutils literal notranslate"><span class="pre">None</span></code> will lead to an inconsistency in the total energy.</p>
<p>Possible values are <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">vcut_sph</span></code> (spherical cutoff), <code class="docutils literal notranslate"><span class="pre">vcut_ws</span></code> (Wigner-Seitz cutoff), <code class="docutils literal notranslate"><span class="pre">ewald</span></code> (probe-charge Ewald correction).
<code class="docutils literal notranslate"><span class="pre">vcut_sph</span></code> and <code class="docutils literal notranslate"><span class="pre">vcut_ws</span></code> are only available when using FFTDF. When using hybrid functionals, the exchange treatment will use the <code class="xref py py-attr docutils literal notranslate"><span class="pre">exxdiv</span></code> attribute.</p>
<p>Note that when calling <code class="xref py py-func docutils literal notranslate"><span class="pre">get_bands()</span></code>, the choice of <code class="xref py py-attr docutils literal notranslate"><span class="pre">exxdiv</span></code> affects the band structure. In particular, <code class="docutils literal notranslate"><span class="pre">vcut_sph</span></code> (spherical cutoff), <code class="docutils literal notranslate"><span class="pre">vcut_ws</span></code> (Wigner-Seitz cutoff) should be used to obtain smooth bands, otherwise, the band structure should be computed by twisting the
SCF calculation (i.e. redoing self-consistency at each k point).</p>


<span id="pbc-density-fit"></span><h2 id="gaussian-density-fitting">Gaussian density fitting<a class="headerlink" href="#gaussian-density-fitting" title="Permalink to this headline">¶</a></h2>
<p>This example uses the <code class="xref py py-func docutils literal notranslate"><span class="pre">density_fit()</span></code> function to enable Gaussian density fitting:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span> <span class="k">as</span> <span class="n">mol_gto</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">df</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Cell</span><span class="p">()</span>
<span class="n">cell</span><span class="o">.</span><span class="n">atom</span><span class="o">=</span><span class="s1">'''</span>
<span class="s1">C 0.000000000000   0.000000000000   0.000000000000</span>
<span class="s1">C 1.685068664391   1.685068664391   1.685068664391</span>
<span class="s1">'''</span>
<span class="n">cell</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="s1">'gth-dzv'</span>
<span class="n">cell</span><span class="o">.</span><span class="n">pseudo</span> <span class="o">=</span> <span class="s1">'gth-pade'</span>
<span class="n">cell</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="s1">'''</span>
<span class="s1">0.000000000, 3.370137329, 3.370137329</span>
<span class="s1">3.370137329, 0.000000000, 3.370137329</span>
<span class="s1">3.370137329, 3.370137329, 0.000000000'''</span>
<span class="n">cell</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="s1">'B'</span>
<span class="n">cell</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">cell</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># Default DF auxiliary basis is a set of even-tempered gaussian basis (with</span>
<span class="c1"># exponents alpha * beta**i, i = 1,..,N).  The even-tempered parameter alpha</span>
<span class="c1"># is determined automatically based on the orbital basis.  beta is set to 2.0</span>
<span class="c1">#</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>


<span id="program-reference"></span><h2 id="module-pyscf.pbc.scf.hf">Program reference<a class="headerlink" href="#module-pyscf.pbc.scf.hf" title="Permalink to this headline">¶</a></h2>
<p>Hartree-Fock for periodic systems at a single k-point</p>
<dl class="simple">
<dt>See Also:</dt><dd><p>pyscf.pbc.scf.khf.py : Hartree-Fock for periodic systems with k-point sampling</p>
</dd>
</dl>
<dl class="py class">
<dt id="pyscf.pbc.scf.hf.RHF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">RHF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">array([0., 0., 0.])</span></em>, <em class="sig-param"><span class="n">exxdiv</span><span class="o">=</span><span class="default_value">'ewald'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#RHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.RHF" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="pyscf.pbc.scf.hf.RHF.convert_from_">
<code class="sig-name descname">convert_from_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#RHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.RHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to RHF</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.RHF.stability">
<code class="sig-name descname">stability</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">internal</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">external</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/hf/#RHF.stability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.RHF.stability" title="Permalink to this definition">¶</a></dt>
<dd><p>RHF/RKS stability analysis.</p>
<p>See also pyscf.scf.stability.rhf_stability function.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the RHF optimization space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. Including the RHF -&gt; UHF and real -&gt; complex
stability analysis.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>New orbitals that are more close to the stable condition.  The return
value includes two set of orbitals.  The first corresponds to the
internal stability and the second corresponds to the external stability.</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="pyscf.pbc.scf.hf.SCF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">SCF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">array([0., 0., 0.])</span></em>, <em class="sig-param"><span class="n">exxdiv</span><span class="o">=</span><span class="default_value">'ewald'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class adapted for PBCs.</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>kpt<span class="classifier">(3,) ndarray</span></dt><dd><p>The AO k-point in Cartesian coordinates, in units of 1/Bohr.</p>
</dd>
<dt>exxdiv<span class="classifier">str</span></dt><dd><p>Exchange divergence treatment, can be one of</p>
<div class="line-block">
<div class="line">None : ignore G=0 contribution in exchange</div>
<div class="line">‘ewald’ : Ewald probe charge correction [JCP 122, 234102 (2005); DOI:10.1063/1.1926272]</div>
</div>
</dd>
<dt>with_df<span class="classifier">density fitting object</span></dt><dd><p>Default is the FFT based DF model. For all-electron calculation,
MDF model is favored for better accuracy.  See also <a class="reference internal" href="../../../pyscf_api_docs/pyscf.pbc.df/#module-pyscf.pbc.df" title="pyscf.pbc.df"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyscf.pbc.df</span></code></a>.</p>
</dd>
<dt>direct_scf<span class="classifier">bool</span></dt><dd><p>When this flag is set to true, the J/K matrices will be computed
directly through the underlying with_df methods.  Otherwise,
depending the available memory, the 4-index integrals may be cached
and J/K matrices are computed based on the 4-index integrals.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.check_sanity">
<code class="sig-name descname">check_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.check_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.check_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.dip_moment">
<code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">unit</span><span class="o">=</span><span class="default_value">'Debye'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell (is it well defined)?</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm (ndarray) : density matrix</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.from_chk">
<code class="sig-name descname">from_chk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">project</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.from_chk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.from_chk" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.get_bands">
<code class="sig-name descname">get_bands</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kpts_band</span></em>, <em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) ‘band’ k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span></dt><dd><p>Bands energies E_n(k)</p>
</dd>
<dt>mo_coeff<span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span></dt><dd><p>Band orbitals psi_n(k)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.get_j">
<code class="sig-name descname">get_j</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">omega</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J matrix for the given density matrix and k-point (kpt).
When kpts_band is given, the J matrices on kpts_band are evaluated.</p>
<blockquote>
<div><p>J_{pq} = sum_{rs} (pq|rs) dm[s,r]</p>
</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.get_jk">
<code class="sig-name descname">get_jk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">with_j</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">with_k</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">omega</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Coulomb (J) and exchange (K) following <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_jk_()</span></code>.
for particular k-point (kpt).</p>
<p>When kpts_band is given, the J, K matrices on kpts_band are evaluated.</p>
<blockquote>
<div><p>J_{pq} = sum_{rs} (pq|rs) dm[s,r]
K_{pq} = sum_{rs} (pr|sq) dm[r,s]</p>
</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.get_jk_incore">
<code class="sig-name descname">get_jk_incore</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">omega</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.get_jk_incore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_jk_incore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Coulomb (J) and exchange (K) following <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_jk_()</span></code>.</p>
<p><em>Incore</em> version of Coulomb and exchange build only.
Currently RHF always uses PBC AO integrals (unlike RKS), since
exchange is currently computed by building PBC AO integrals.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.get_k">
<code class="sig-name descname">get_k</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">omega</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.get_k"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_k" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute K matrix for the given density matrix.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.get_rho">
<code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">vhf_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.init_guess_by_1e">
<code class="sig-name descname">init_guess_by_1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.init_guess_by_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.init_guess_by_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.init_guess_by_chkfile">
<code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">project</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.nuc_grad_method">
<code class="sig-name descname">nuc_grad_method</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.nuc_grad_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.nuc_grad_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset cell and relevant attributes associated to the old cell object</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.to_ghf">
<code class="sig-name descname">to_ghf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.to_ghf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.to_ghf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a GHF/GKS object</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.to_rhf">
<code class="sig-name descname">to_rhf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.to_rhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.to_rhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a RHF/ROHF/RKS/ROKS object</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.hf.SCF.to_uhf">
<code class="sig-name descname">to_uhf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#SCF.to_uhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.SCF.to_uhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a UHF/UKS object</p>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.hf.dip_moment">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">dm</span></em>, <em class="sig-param"><span class="n">unit</span><span class="o">=</span><span class="default_value">'Debye'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">grids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rho</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">array([0., 0., 0.])</span></em>, <em class="sig-param"><span class="n">origin</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell (is it well defined)?</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm (ndarray) : density matrix</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.hf.get_bands">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_bands</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">kpts_band</span></em>, <em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) ‘band’ k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span></dt><dd><p>Bands energies E_n(k)</p>
</dd>
<dt>mo_coeff<span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span></dt><dd><p>Band orbitals psi_n(k)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.hf.get_hcore">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_hcore</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">array([0., 0., 0.])</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#get_hcore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_hcore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the core Hamiltonian AO matrix.</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.hf.get_j">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_j</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">dm</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">vhfopt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">array([0., 0., 0.])</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Coulomb (J) AO matrix for the given density matrix.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian
| 0 : no hermitian or symmetric
| 1 : hermitian
| 2 : anti-hermitian</p>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
<dt>kpt<span class="classifier">(3,) ndarray</span></dt><dd><p>The “inner” dummy k-point at which the DM was evaluated (or
sampled).</p>
</dd>
<dt>kpts_band<span class="classifier">(3,) ndarray or (<a href="#id1"><span class="problematic" id="id2">*</span></a>,3) ndarray</span></dt><dd><p>An arbitrary “band” k-point at which J is evaluated.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>The function returns one J matrix, corresponding to the input
density matrix (both order and shape).</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.hf.get_jk">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_jk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">dm</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">vhfopt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">array([0., 0., 0.])</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">with_j</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">with_k</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">omega</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Coulomb (J) and exchange (K) AO matrices for the given density matrix.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>dm<span class="classifier">ndarray or list of ndarrays</span></dt><dd><p>A density matrix or a list of density matrices</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian
| 0 : no hermitian or symmetric
| 1 : hermitian
| 2 : anti-hermitian</p>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
<dt>kpt<span class="classifier">(3,) ndarray</span></dt><dd><p>The “inner” dummy k-point at which the DM was evaluated (or
sampled).</p>
</dd>
<dt>kpts_band<span class="classifier">(3,) ndarray or (<a href="#id3"><span class="problematic" id="id4">*</span></a>,3) ndarray</span></dt><dd><p>An arbitrary “band” k-point at which J and K are evaluated.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>The function returns one J and one K matrix, corresponding to the input
density matrix (both order and shape).</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.hf.get_nuc">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_nuc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">array([0., 0., 0.])</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#get_nuc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_nuc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bare periodic nuc-el AO matrix, with G=0 removed.</p>
<p>See Martin (12.16)-(12.21).</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.hf.get_ovlp">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_ovlp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">array([0., 0., 0.])</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#get_ovlp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the overlap AO matrix.</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.hf.get_rho">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#get_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.hf.get_t">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">get_t</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">array([0., 0., 0.])</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#get_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.get_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the kinetic energy AO matrix.</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.hf.init_guess_by_chkfile">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">chkfile_name</span></em>, <em class="sig-param"><span class="n">project</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">cell</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, (nao,nao) ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.hf.makov_payne_correction">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">makov_payne_correction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#makov_payne_correction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.makov_payne_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Makov-Payne correction (Phys. Rev. B, 51, 4014)</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.hf.normalize_dm_">
<code class="sig-prename descclassname">pyscf.pbc.scf.hf.</code><code class="sig-name descname">normalize_dm_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">dm</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/hf/#normalize_dm_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.hf.normalize_dm_" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale density matrix to make it produce the correct number of electrons.</p>
</dd></dl>
<span class="target" id="module-pyscf.pbc.scf.uhf"></span><p>Unrestricted Hartree-Fock for periodic systems at a single k-point</p>
<dl class="simple">
<dt>See Also:</dt><dd><p>pyscf/pbc/scf/khf.py : Hartree-Fock for periodic systems with k-point sampling</p>
</dd>
</dl>
<dl class="py class">
<dt id="pyscf.pbc.scf.uhf.UHF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.uhf.</code><code class="sig-name descname">UHF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">array([0., 0., 0.])</span></em>, <em class="sig-param"><span class="n">exxdiv</span><span class="o">=</span><span class="default_value">'ewald'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/uhf/#UHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF" title="Permalink to this definition">¶</a></dt>
<dd><p>UHF class for PBCs.</p>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.analyze">
<code class="sig-name descname">analyze</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">with_meta_lowdin</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/uhf/#UHF.analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.canonicalize">
<code class="sig-name descname">canonicalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff</span></em>, <em class="sig-param"><span class="n">mo_occ</span></em>, <em class="sig-param"><span class="n">fock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.convert_from_">
<code class="sig-name descname">convert_from_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/uhf/#UHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to RHF/ROHF</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.dip_moment">
<code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">unit</span><span class="o">=</span><span class="default_value">'Debye'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/uhf/#UHF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (a list of ndarrays) : density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.eig">
<code class="sig-name descname">eig</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fock</span></em>, <em class="sig-param"><span class="n">s</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/uhf/#UHF.eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.energy_elec">
<code class="sig-name descname">energy_elec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">h1e</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vhf</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Electronic energy of Unrestricted Hartree-Fock</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Hartree-Fock electronic energy and the 2-electron part contribution</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_bands">
<code class="sig-name descname">get_bands</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kpts_band</span></em>, <em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/uhf/#UHF.get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) ‘band’ k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span></dt><dd><p>Bands energies E_n(k)</p>
</dd>
<dt>mo_coeff<span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span></dt><dd><p>Band orbitals psi_n(k)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_grad">
<code class="sig-name descname">get_grad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff</span></em>, <em class="sig-param"><span class="n">mo_occ</span></em>, <em class="sig-param"><span class="n">fock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/uhf/#UHF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Orbital occupancy</p>
</dd>
<dt>fock_ao<span class="classifier">2D ndarray</span></dt><dd><p>Fock matrix in AO representation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_rho">
<code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">vhf_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/uhf/#UHF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.init_guess_by_1e">
<code class="sig-name descname">init_guess_by_1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/uhf/#UHF.init_guess_by_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.init_guess_by_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.init_guess_by_atom">
<code class="sig-name descname">init_guess_by_atom</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">breaksym</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/uhf/#UHF.init_guess_by_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.init_guess_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.init_guess_by_chkfile">
<code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">project</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/uhf/#UHF.init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.init_guess_by_huckel">
<code class="sig-name descname">init_guess_by_huckel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">breaksym</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/uhf/#UHF.init_guess_by_huckel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.init_guess_by_huckel" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.init_guess_by_minao">
<code class="sig-name descname">init_guess_by_minao</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">breaksym</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/uhf/#UHF.init_guess_by_minao"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.init_guess_by_minao" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess in terms of the overlap to minimal basis.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/uhf/#UHF.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrix</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>A list of 2D ndarrays for alpha and beta spins</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.mulliken_meta">
<code class="sig-name descname">mulliken_meta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">pre_orth_method</span><span class="o">=</span><span class="default_value">'ANO'</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/uhf/#UHF.mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carreid out within each subsets.</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or 2-item list of ndarray</span></dt><dd><p>Density matrix.  ROHF dm is a 2-item list of 2D array</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.mulliken_pop">
<code class="sig-name descname">mulliken_pop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">5</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/uhf/#UHF.mulliken_pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.mulliken_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.spin_square">
<code class="sig-name descname">spin_square</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/uhf/#UHF.spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square and multiplicity of UHF determinant</p>
<div class="math notranslate nohighlight">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math notranslate nohighlight">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math notranslate nohighlight">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl>
<dt>There are two possibilities for <span class="math notranslate nohighlight">\(S_+ S_-\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron <span class="math notranslate nohighlight">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math notranslate nohighlight">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math notranslate nohighlight">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="math notranslate nohighlight">
\[\langle S_+ S_- \rangle = \langle ij|s_+ s_-|ij\rangle
                        - \langle ij|s_+ s_-|ji\rangle
                        = -\langle i^\alpha|j^\beta\rangle
                           \langle j^\beta|i^\alpha\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Similarly, for <span class="math notranslate nohighlight">\(S_- S_+\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle S_- S_+ \rangle = -\langle i^\beta|j^\alpha\rangle
                           \langle j^\alpha|i^\beta\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>For <span class="math notranslate nohighlight">\(S_z^2\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}&amp;\frac{1}{2}\sum_{ij}(\langle ij|2s_{z1}s_{z2}|ij\rangle
                     -\langle ij|2s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}(n_\alpha^2 - n_\alpha n_\beta - n_\beta n_\alpha + n_\beta^2)
 -\frac{1}{4}(n_\alpha + n_\beta) \\
&amp;=\frac{1}{4}((n_\alpha-n_\beta)^2 - (n_\alpha+n_\beta))\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<p>In total</p>
<div class="math notranslate nohighlight">
\[\begin{split}\langle S^2\rangle &amp;= \frac{1}{2}
(n_\alpha-\sum_{ij}\langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle
+n_\beta -\sum_{ij}\langle i^\beta|j^\alpha\rangle\langle j^\alpha|i^\beta\rangle)
+ \frac{1}{4}(n_\alpha-n_\beta)^2 \\\end{split}\]</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo<span class="classifier">a list of 2 ndarrays</span></dt><dd><p>Occupied alpha and occupied beta orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>s<span class="classifier">ndarray</span></dt><dd><p>AO overlap</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'O 0 0 0; H 0 0 1; H 0 1 0'</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">'ccpvdz'</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">'S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">'</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">'int1e_ovlp_sph'</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.uhf.UHF.stability">
<code class="sig-name descname">stability</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">internal</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">external</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/uhf/#UHF.stability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.UHF.stability" title="Permalink to this definition">¶</a></dt>
<dd><p>Stability analysis for RHF/RKS method.</p>
<p>See also pyscf.scf.stability.uhf_stability function.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mf : UHF or UKS object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the UHF space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. Including the UHF -&gt; GHF and real -&gt; complex
stability analysis.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>New orbitals that are more close to the stable condition.  The return
value includes two set of orbitals.  The first corresponds to the
internal stability and the second corresponds to the external stability.</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.uhf.dip_moment">
<code class="sig-prename descclassname">pyscf.pbc.scf.uhf.</code><code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">dm</span></em>, <em class="sig-param"><span class="n">unit</span><span class="o">=</span><span class="default_value">'Debye'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">grids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rho</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">array([0., 0., 0.])</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/uhf/#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (a list of ndarrays) : density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.uhf.init_guess_by_chkfile">
<code class="sig-prename descclassname">pyscf.pbc.scf.uhf.</code><code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">chkfile_name</span></em>, <em class="sig-param"><span class="n">project</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/uhf/#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.uhf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file and make the density matrix
for UHF initial guess.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, (nao,nao) ndarray</p>
</dd>
</dl>
</dd></dl>
<span class="target" id="module-pyscf.pbc.scf.rohf"></span><p>Restricted open-shell Hartree-Fock for periodic systems at a single k-point</p>
<dl class="simple">
<dt>See Also:</dt><dd><p>pyscf/pbc/scf/khf.py : Hartree-Fock for periodic systems with k-point sampling</p>
</dd>
</dl>
<dl class="py class">
<dt id="pyscf.pbc.scf.rohf.ROHF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.rohf.</code><code class="sig-name descname">ROHF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">array([0., 0., 0.])</span></em>, <em class="sig-param"><span class="n">exxdiv</span><span class="o">=</span><span class="default_value">'ewald'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/rohf/#ROHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF" title="Permalink to this definition">¶</a></dt>
<dd><p>ROHF class for PBCs.</p>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.analyze">
<code class="sig-name descname">analyze</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">with_meta_lowdin</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/rohf/#ROHF.analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.canonicalize">
<code class="sig-name descname">canonicalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff</span></em>, <em class="sig-param"><span class="n">mo_occ</span></em>, <em class="sig-param"><span class="n">fock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix within occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.convert_from_">
<code class="sig-name descname">convert_from_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/rohf/#ROHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to RHF/ROHF</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.dip_moment">
<code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">unit</span><span class="o">=</span><span class="default_value">'Debye'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/rohf/#ROHF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (a list of ndarrays) : density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.eig">
<code class="sig-name descname">eig</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fock</span></em>, <em class="sig-param"><span class="n">s</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/rohf/#ROHF.eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.get_bands">
<code class="sig-name descname">get_bands</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kpts_band</span></em>, <em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/rohf/#ROHF.get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) ‘band’ k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span></dt><dd><p>Bands energies E_n(k)</p>
</dd>
<dt>mo_coeff<span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span></dt><dd><p>Band orbitals psi_n(k)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.get_fock">
<code class="sig-name descname">get_fock</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">s1e</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vhf</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cycle</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">diis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">diis_start_cycle</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level_shift_factor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">damp_factor</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.get_fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Build fock matrix based on Roothaan’s effective fock.
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">get_roothaan_fock()</span></code></p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.get_grad">
<code class="sig-name descname">get_grad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff</span></em>, <em class="sig-param"><span class="n">mo_occ</span></em>, <em class="sig-param"><span class="n">fock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/rohf/#ROHF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>ROHF gradients is the off-diagonal block [co + cv + ov], where
[ cc co cv ]
[ oc oo ov ]
[ vc vo vv ]</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.get_occ">
<code class="sig-name descname">get_occ</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_energy</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital.
NOTE the occupancies are not assigned based on the orbital energy ordering.
The first N orbitals are assigned to be occupied orbitals.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'H 0 0 0; O 0 0 1.1'</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 2, 2, 1, 0])</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.get_rho">
<code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">vhf_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/rohf/#ROHF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.init_guess_by_1e">
<code class="sig-name descname">init_guess_by_1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/rohf/#ROHF.init_guess_by_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.init_guess_by_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.init_guess_by_atom">
<code class="sig-name descname">init_guess_by_atom</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/rohf/#ROHF.init_guess_by_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.init_guess_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.init_guess_by_chkfile">
<code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">project</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/rohf/#ROHF.init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.init_guess_by_huckel">
<code class="sig-name descname">init_guess_by_huckel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/rohf/#ROHF.init_guess_by_huckel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.init_guess_by_huckel" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.init_guess_by_minao">
<code class="sig-name descname">init_guess_by_minao</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/rohf/#ROHF.init_guess_by_minao"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.init_guess_by_minao" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix based on ANO basis, then project
the density matrix to the basis set defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'H 0 0 0; H 0 0 1.1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">init_guess_by_minao</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">array([[ 0.94758917,  0.09227308],</span>
<span class="go">       [ 0.09227308,  0.94758917]])</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/rohf/#ROHF.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle densit matrix.  mo_occ is a 1D array, with occupancy 1 or 2.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.spin_square">
<code class="sig-name descname">spin_square</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/rohf/#ROHF.spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square and multiplicity of RHF determinant</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.rohf.ROHF.stability">
<code class="sig-name descname">stability</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">internal</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">external</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/rohf/#ROHF.stability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.rohf.ROHF.stability" title="Permalink to this definition">¶</a></dt>
<dd><p>ROHF/ROKS stability analysis.</p>
<p>See also pyscf.scf.stability.rohf_stability function.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the RHF optimization space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. It is not available in current version.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>The return value includes two set of orbitals which are more close to
the required stable condition.</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<span class="target" id="module-pyscf.pbc.scf.ghf"></span><p>Generalized Hartree-Fock for periodic systems at a single k-point</p>
<dl class="py class">
<dt id="pyscf.pbc.scf.ghf.GHF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.ghf.</code><code class="sig-name descname">GHF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">array([0., 0., 0.])</span></em>, <em class="sig-param"><span class="n">exxdiv</span><span class="o">=</span><span class="default_value">'ewald'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/ghf/#GHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.ghf.GHF" title="Permalink to this definition">¶</a></dt>
<dd><p>GHF class for PBCs.</p>
<dl class="py method">
<dt id="pyscf.pbc.scf.ghf.GHF.convert_from_">
<code class="sig-name descname">convert_from_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/ghf/#GHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.ghf.GHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to RHF/ROHF</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.ghf.GHF.get_bands">
<code class="sig-name descname">get_bands</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kpts_band</span></em>, <em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/ghf/#GHF.get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.ghf.GHF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) ‘band’ k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span></dt><dd><p>Bands energies E_n(k)</p>
</dd>
<dt>mo_coeff<span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span></dt><dd><p>Band orbitals psi_n(k)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.ghf.GHF.get_grad">
<code class="sig-name descname">get_grad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff</span></em>, <em class="sig-param"><span class="n">mo_occ</span></em>, <em class="sig-param"><span class="n">fock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/scf/ghf/#GHF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.ghf.GHF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Orbital occupancy</p>
</dd>
<dt>fock_ao<span class="classifier">2D ndarray</span></dt><dd><p>Fock matrix in AO representation</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.ghf.GHF.get_j">
<code class="sig-name descname">get_j</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/ghf/#GHF.get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.ghf.GHF.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J matrix for the given density matrix and k-point (kpt).
When kpts_band is given, the J matrices on kpts_band are evaluated.</p>
<blockquote>
<div><p>J_{pq} = sum_{rs} (pq|rs) dm[s,r]</p>
</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.ghf.GHF.get_k">
<code class="sig-name descname">get_k</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/ghf/#GHF.get_k"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.ghf.GHF.get_k" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute K matrix for the given density matrix.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.ghf.GHF.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">vhf_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/ghf/#GHF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.ghf.GHF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>
</dd></dl>
<span class="target" id="module-pyscf.pbc.scf.khf"></span><p>Hartree-Fock for periodic systems with k-point sampling</p>
<dl class="simple">
<dt>See Also:</dt><dd><p>hf.py : Hartree-Fock for periodic systems at a single k-point</p>
</dd>
</dl>
<dl class="py class">
<dt id="pyscf.pbc.scf.khf.KRHF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">KRHF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">array([[0., 0., 0.]])</span></em>, <em class="sig-param"><span class="n">exxdiv</span><span class="o">=</span><span class="default_value">'ewald'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KRHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KRHF" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="pyscf.pbc.scf.khf.KRHF.check_sanity">
<code class="sig-name descname">check_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KRHF.check_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KRHF.check_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KRHF.convert_from_">
<code class="sig-name descname">convert_from_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KRHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KRHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to KRHF</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KRHF.nuc_grad_method">
<code class="sig-name descname">nuc_grad_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KRHF.nuc_grad_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KRHF.nuc_grad_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt id="pyscf.pbc.scf.khf.KSCF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">KSCF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">array([[0., 0., 0.]])</span></em>, <em class="sig-param"><span class="n">exxdiv</span><span class="o">=</span><span class="default_value">'ewald'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF" title="Permalink to this definition">¶</a></dt>
<dd><p>SCF base class with k-point sampling.</p>
<p>Compared to molecular SCF, some members such as mo_coeff, mo_occ
now have an additional first dimension for the k-points,
e.g. mo_coeff is (nkpts, nao, nao) ndarray</p>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>kpts<span class="classifier">(nks,3) ndarray</span></dt><dd><p>The sampling k-points in Cartesian coordinates, in units of 1/Bohr.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.analyze">
<code class="sig-name descname">analyze</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">with_meta_lowdin</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.check_sanity">
<code class="sig-name descname">check_sanity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.check_sanity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.check_sanity" title="Permalink to this definition">¶</a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.dip_moment">
<code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">unit</span><span class="o">=</span><span class="default_value">'Debye'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell (is it well defined)?</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (a list of ndarrays) : density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.eig">
<code class="sig-name descname">eig</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h_kpts</span></em>, <em class="sig-param"><span class="n">s_kpts</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.energy_elec">
<code class="sig-name descname">energy_elec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">h1e_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vhf_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.from_chk">
<code class="sig-name descname">from_chk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">project</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.from_chk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.from_chk" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_bands">
<code class="sig-name descname">get_bands</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kpts_band</span></em>, <em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) ‘band’ k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span></dt><dd><p>Bands energies E_n(k)</p>
</dd>
<dt>mo_coeff<span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span></dt><dd><p>Band orbitals psi_n(k)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_fermi">
<code class="sig-name descname">get_fermi</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_energy_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_fermi" title="Permalink to this definition">¶</a></dt>
<dd><p>Fermi level</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_grad">
<code class="sig-name descname">get_grad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff_kpts</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span></em>, <em class="sig-param"><span class="n">fock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>returns 1D array of gradients, like non K-pt version
note that occ and virt indices of different k pts now occur
in sequential patches of the 1D array</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_hcore">
<code class="sig-name descname">get_hcore</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_hcore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the core Hamiltonian AO matrices at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>kpts : (nkpts, 3) ndarray</p>
</dd>
<dt>Returns:</dt><dd><p>hcore : (nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_j">
<code class="sig-name descname">get_j</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">omega</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J matrix for the given density matrix and k-point (kpt).
When kpts_band is given, the J matrices on kpts_band are evaluated.</p>
<blockquote>
<div><p>J_{pq} = sum_{rs} (pq|rs) dm[s,r]</p>
</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_jk">
<code class="sig-name descname">get_jk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">with_j</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">with_k</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">omega</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Coulomb (J) and exchange (K) following <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_jk_()</span></code>.
for particular k-point (kpt).</p>
<p>When kpts_band is given, the J, K matrices on kpts_band are evaluated.</p>
<blockquote>
<div><p>J_{pq} = sum_{rs} (pq|rs) dm[s,r]
K_{pq} = sum_{rs} (pr|sq) dm[r,s]</p>
</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_k">
<code class="sig-name descname">get_k</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">omega</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.get_k"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_k" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute K matrix for the given density matrix.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_occ">
<code class="sig-name descname">get_occ</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_energy_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_ovlp">
<code class="sig-name descname">get_ovlp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the overlap AO matrices at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>kpts : (nkpts, 3) ndarray</p>
</dd>
<dt>Returns:</dt><dd><p>ovlp_kpts : (nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_rho">
<code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">vhf_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.init_guess_by_1e">
<code class="sig-name descname">init_guess_by_1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.init_guess_by_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.init_guess_by_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.init_guess_by_chkfile">
<code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">project</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrix in AO representation</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Orbital coefficients. Each column is one orbital.</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Occupancy</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.mulliken_meta">
<code class="sig-name descname">mulliken_meta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">pre_orth_method</span><span class="o">=</span><span class="default_value">'ANO'</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carreid out within each subsets.</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or 2-item list of ndarray</span></dt><dd><p>Density matrix.  ROHF dm is a 2-item list of 2D array</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.mulliken_pop">
<code class="sig-name descname">mulliken_pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.mulliken_pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.mulliken_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.to_ghf">
<code class="sig-name descname">to_ghf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.to_ghf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.to_ghf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a KGHF/KGKS object</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.to_rhf">
<code class="sig-name descname">to_rhf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.to_rhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.to_rhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a KRHF/KROHF/KRKS/KROKS object</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.khf.KSCF.to_uhf">
<code class="sig-name descname">to_uhf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#KSCF.to_uhf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.KSCF.to_uhf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input mean-field object to a KUHF/KUKS object</p>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.analyze">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">analyze</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">with_meta_lowdin</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Dipole moment</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.dip_moment">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">dm_kpts</span></em>, <em class="sig-param"><span class="n">unit</span><span class="o">=</span><span class="default_value">'Debye'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">grids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rho</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">array([[0., 0., 0.]])</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell (is it well defined)?</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (a list of ndarrays) : density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.energy_elec">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">energy_elec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">h1e_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vhf_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#energy_elec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.get_fermi">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_fermi</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">mo_energy_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#get_fermi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_fermi" title="Permalink to this definition">¶</a></dt>
<dd><p>Fermi level</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.get_grad">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_grad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff_kpts</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span></em>, <em class="sig-param"><span class="n">fock</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>returns 1D array of gradients, like non K-pt version
note that occ and virt indices of different k pts now occur
in sequential patches of the 1D array</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.get_hcore">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_hcore</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#get_hcore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_hcore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the core Hamiltonian AO matrices at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>kpts : (nkpts, 3) ndarray</p>
</dd>
<dt>Returns:</dt><dd><p>hcore : (nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.get_j">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_j</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">dm_kpts</span></em>, <em class="sig-param"><span class="n">kpts</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Coulomb (J) AO matrix at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>dm_kpts<span class="classifier">(nkpts, nao, nao) ndarray or a list of (nkpts,nao,nao) ndarray</span></dt><dd><p>Density matrix at each k-point.  If a list of k-point DMs, eg,
UHF alpha and beta DM, the alpha and beta DMs are contracted
separately.  It needs to be Hermitian.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>kpts_band<span class="classifier">(k,3) ndarray</span></dt><dd><p>A list of arbitrary “band” k-points at which to evalute the matrix.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>vj : (nkpts, nao, nao) ndarray
or list of vj if the input dm_kpts is a list of DMs</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.get_jk">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_jk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">dm_kpts</span></em>, <em class="sig-param"><span class="n">kpts</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">with_j</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">with_k</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">omega</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#get_jk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_jk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Coulomb (J) and exchange (K) AO matrices at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>dm_kpts<span class="classifier">(nkpts, nao, nao) ndarray</span></dt><dd><p>Density matrix at each k-point. It needs to be Hermitian.</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>kpts_band<span class="classifier">(3,) ndarray</span></dt><dd><p>A list of arbitrary “band” k-point at which to evalute the matrix.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>vj : (nkpts, nao, nao) ndarray
vk : (nkpts, nao, nao) ndarray
or list of vj and vk if the input dm_kpts is a list of DMs</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.get_occ">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_occ</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">mo_energy_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#get_occ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.get_ovlp">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_ovlp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#get_ovlp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the overlap AO matrices at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>kpts : (nkpts, 3) ndarray</p>
</dd>
<dt>Returns:</dt><dd><p>ovlp_kpts : (nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.get_rho">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#get_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.init_guess_by_chkfile">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">chkfile_name</span></em>, <em class="sig-param"><span class="n">project</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the KHF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">cell</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 3D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.make_rdm1">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff_kpts</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One particle density matrices for all k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>dm_kpts : (nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.khf.mulliken_meta">
<code class="sig-prename descclassname">pyscf.pbc.scf.khf.</code><code class="sig-name descname">mulliken_meta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">dm_ao_kpts</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">pre_orth_method</span><span class="o">=</span><span class="default_value">'ANO'</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/khf/#mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.khf.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>A modified Mulliken population analysis, based on meta-Lowdin AOs.</p>
<p>Note this function only computes the Mulliken population for the gamma
point density matrix.</p>
</dd></dl>
<span class="target" id="module-pyscf.pbc.scf.kuhf"></span><p>Hartree-Fock for periodic systems with k-point sampling</p>
<dl class="simple">
<dt>See Also:</dt><dd><p>hf.py : Hartree-Fock for periodic systems at a single k-point</p>
</dd>
</dl>
<dl class="py class">
<dt id="pyscf.pbc.scf.kuhf.KUHF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">KUHF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">array([[0., 0., 0.]])</span></em>, <em class="sig-param"><span class="n">exxdiv</span><span class="o">=</span><span class="default_value">'ewald'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF" title="Permalink to this definition">¶</a></dt>
<dd><p>UHF class with k-point sampling.</p>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.analyze">
<code class="sig-name descname">analyze</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">with_meta_lowdin</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.canonicalize">
<code class="sig-name descname">canonicalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff_kpts</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span></em>, <em class="sig-param"><span class="n">fock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.convert_from_">
<code class="sig-name descname">convert_from_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to KUHF</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.dip_moment">
<code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">unit</span><span class="o">=</span><span class="default_value">'Debye'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (two lists of ndarrays) : KUHF density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.eig">
<code class="sig-name descname">eig</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h_kpts</span></em>, <em class="sig-param"><span class="n">s_kpts</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.energy_elec">
<code class="sig-name descname">energy_elec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">h1e_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vhf_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_bands">
<code class="sig-name descname">get_bands</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kpts_band</span></em>, <em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) ‘band’ k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span></dt><dd><p>Bands energies E_n(k)</p>
</dd>
<dt>mo_coeff<span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span></dt><dd><p>Band orbitals psi_n(k)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_fermi">
<code class="sig-name descname">get_fermi</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_energy_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_fermi" title="Permalink to this definition">¶</a></dt>
<dd><p>A pair of Fermi level for spin-up and spin-down orbitals</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_grad">
<code class="sig-name descname">get_grad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff_kpts</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span></em>, <em class="sig-param"><span class="n">fock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>returns 1D array of gradients, like non K-pt version
note that occ and virt indices of different k pts now occur
in sequential patches of the 1D array</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_occ">
<code class="sig-name descname">get_occ</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_energy_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_rho">
<code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">vhf_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.init_guess_by_1e">
<code class="sig-name descname">init_guess_by_1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.init_guess_by_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.init_guess_by_atom">
<code class="sig-name descname">init_guess_by_atom</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">breaksym</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.init_guess_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.init_guess_by_chkfile">
<code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">project</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.init_guess_by_huckel">
<code class="sig-name descname">init_guess_by_huckel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">breaksym</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.init_guess_by_huckel" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.init_guess_by_minao">
<code class="sig-name descname">init_guess_by_minao</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">breaksym</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.init_guess_by_minao" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess in terms of the overlap to minimal basis.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle density matrix</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>A list of 2D ndarrays for alpha and beta spins</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.mulliken_meta">
<code class="sig-name descname">mulliken_meta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">pre_orth_method</span><span class="o">=</span><span class="default_value">'ANO'</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>A modified Mulliken population analysis, based on meta-Lowdin AOs.</p>
<p>Note this function only computes the Mulliken population for the gamma
point density matrix.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.mulliken_pop">
<code class="sig-name descname">mulliken_pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.mulliken_pop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.mulliken_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.nuc_grad_method">
<code class="sig-name descname">nuc_grad_method</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.nuc_grad_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.nuc_grad_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.spin_square">
<code class="sig-name descname">spin_square</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square and multiplicity of UHF determinant</p>
<div class="math notranslate nohighlight">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math notranslate nohighlight">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math notranslate nohighlight">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl>
<dt>There are two possibilities for <span class="math notranslate nohighlight">\(S_+ S_-\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron <span class="math notranslate nohighlight">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math notranslate nohighlight">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math notranslate nohighlight">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="math notranslate nohighlight">
\[\langle S_+ S_- \rangle = \langle ij|s_+ s_-|ij\rangle
                        - \langle ij|s_+ s_-|ji\rangle
                        = -\langle i^\alpha|j^\beta\rangle
                           \langle j^\beta|i^\alpha\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Similarly, for <span class="math notranslate nohighlight">\(S_- S_+\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle S_- S_+ \rangle = -\langle i^\beta|j^\alpha\rangle
                           \langle j^\alpha|i^\beta\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>For <span class="math notranslate nohighlight">\(S_z^2\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}&amp;\frac{1}{2}\sum_{ij}(\langle ij|2s_{z1}s_{z2}|ij\rangle
                     -\langle ij|2s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}(n_\alpha^2 - n_\alpha n_\beta - n_\beta n_\alpha + n_\beta^2)
 -\frac{1}{4}(n_\alpha + n_\beta) \\
&amp;=\frac{1}{4}((n_\alpha-n_\beta)^2 - (n_\alpha+n_\beta))\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<p>In total</p>
<div class="math notranslate nohighlight">
\[\begin{split}\langle S^2\rangle &amp;= \frac{1}{2}
(n_\alpha-\sum_{ij}\langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle
+n_\beta -\sum_{ij}\langle i^\beta|j^\alpha\rangle\langle j^\alpha|i^\beta\rangle)
+ \frac{1}{4}(n_\alpha-n_\beta)^2 \\\end{split}\]</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo<span class="classifier">a list of 2 ndarrays</span></dt><dd><p>Occupied alpha and occupied beta orbitals</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>s<span class="classifier">ndarray</span></dt><dd><p>AO overlap</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'O 0 0 0; H 0 0 1; H 0 1 0'</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">'ccpvdz'</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">'S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">'</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">'int1e_ovlp_sph'</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kuhf.KUHF.stability">
<code class="sig-name descname">stability</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">internal</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">external</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#KUHF.stability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.KUHF.stability" title="Permalink to this definition">¶</a></dt>
<dd><p>Stability analysis for RHF/RKS method.</p>
<p>See also pyscf.scf.stability.uhf_stability function.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>mf : UHF or UKS object</p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the UHF space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. Including the UHF -&gt; GHF and real -&gt; complex
stability analysis.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>New orbitals that are more close to the stable condition.  The return
value includes two set of orbitals.  The first corresponds to the
internal stability and the second corresponds to the external stability.</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.kuhf.canonicalize">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">canonicalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">mo_coeff_kpts</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span></em>, <em class="sig-param"><span class="n">fock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#canonicalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.kuhf.dip_moment">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">dm_kpts</span></em>, <em class="sig-param"><span class="n">unit</span><span class="o">=</span><span class="default_value">'Debye'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="n">grids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rho</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">array([[0., 0., 0.]])</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (two lists of ndarrays) : KUHF density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.kuhf.energy_elec">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">energy_elec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">h1e_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vhf_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#energy_elec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.kuhf.get_fermi">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">get_fermi</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">mo_energy_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#get_fermi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.get_fermi" title="Permalink to this definition">¶</a></dt>
<dd><p>A pair of Fermi level for spin-up and spin-down orbitals</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.kuhf.get_occ">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">get_occ</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">mo_energy_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#get_occ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.kuhf.init_guess_by_chkfile">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">chkfile_name</span></em>, <em class="sig-param"><span class="n">project</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the KHF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">cell</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 3D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.kuhf.make_rdm1">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff_kpts</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha and beta spin one particle density matrices for all k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>dm_kpts : (2, nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.kuhf.mulliken_meta">
<code class="sig-prename descclassname">pyscf.pbc.scf.kuhf.</code><code class="sig-name descname">mulliken_meta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">dm_ao_kpts</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">pre_orth_method</span><span class="o">=</span><span class="default_value">'ANO'</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kuhf/#mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kuhf.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>A modified Mulliken population analysis, based on meta-Lowdin AOs.</p>
<p>Note this function only computes the Mulliken population for the gamma
point density matrix.</p>
</dd></dl>
<span class="target" id="module-pyscf.pbc.scf.krohf"></span><p>Restricted open-shell Hartree-Fock for periodic systems with k-point sampling</p>
<dl class="py class">
<dt id="pyscf.pbc.scf.krohf.KROHF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.krohf.</code><code class="sig-name descname">KROHF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">array([[0., 0., 0.]])</span></em>, <em class="sig-param"><span class="n">exxdiv</span><span class="o">=</span><span class="default_value">'ewald'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#KROHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF" title="Permalink to this definition">¶</a></dt>
<dd><p>UHF class with k-point sampling.</p>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.analyze">
<code class="sig-name descname">analyze</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">with_meta_lowdin</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#KROHF.analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.canonicalize">
<code class="sig-name descname">canonicalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff_kpts</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span></em>, <em class="sig-param"><span class="n">fock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the ROHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.convert_from_">
<code class="sig-name descname">convert_from_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#KROHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to KUHF</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.dip_moment">
<code class="sig-name descname">dip_moment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">unit</span><span class="o">=</span><span class="default_value">'Debye'</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">3</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#KROHF.dip_moment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.dip_moment" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole moment in the unit cell.</p>
<dl>
<dt>Args:</dt><dd><p>cell : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>dm_kpts (two lists of ndarrays) : KUHF density matrices of k-points</p>
</dd>
<dt>Return:</dt><dd><p>A list: the dipole moment on x, y and z components</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.eig">
<code class="sig-name descname">eig</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fock</span></em>, <em class="sig-param"><span class="n">s</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#KROHF.eig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.eig" title="Permalink to this definition">¶</a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.energy_elec">
<code class="sig-name descname">energy_elec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">h1e_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vhf_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.get_grad">
<code class="sig-name descname">get_grad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff_kpts</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span></em>, <em class="sig-param"><span class="n">fock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#KROHF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>returns 1D array of gradients, like non K-pt version
note that occ and virt indices of different k pts now occur
in sequential patches of the 1D array</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.get_occ">
<code class="sig-name descname">get_occ</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_energy_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.get_rho">
<code class="sig-name descname">get_rho</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grids</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.get_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute density in real space</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">vhf_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#KROHF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.init_guess_by_atom">
<code class="sig-name descname">init_guess_by_atom</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.init_guess_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.init_guess_by_chkfile">
<code class="sig-name descname">init_guess_by_chkfile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chk</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">project</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#KROHF.init_guess_by_chkfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.init_guess_by_chkfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.init_guess_by_huckel">
<code class="sig-name descname">init_guess_by_huckel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.init_guess_by_huckel" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.init_guess_by_minao">
<code class="sig-name descname">init_guess_by_minao</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.init_guess_by_minao" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate initial guess density matrix based on ANO basis, then project
the density matrix to the basis set defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'H 0 0 0; H 0 0 1.1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">init_guess_by_minao</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">array([[ 0.94758917,  0.09227308],</span>
<span class="go">       [ 0.09227308,  0.94758917]])</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#KROHF.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>One-particle densit matrix.  mo_occ is a 1D array, with occupancy 1 or 2.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.mulliken_meta">
<code class="sig-name descname">mulliken_meta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">pre_orth_method</span><span class="o">=</span><span class="default_value">'ANO'</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#KROHF.mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carreid out within each subsets.</p>
<dl>
<dt>Args:</dt><dd><p>mol : an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
<dl class="simple">
<dt>dm<span class="classifier">ndarray or 2-item list of ndarray</span></dt><dd><p>Density matrix.  ROHF dm is a 2-item list of 2D array</p>
</dd>
</dl>
</dd>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list : pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.spin_square">
<code class="sig-name descname">spin_square</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square and multiplicity of RHF determinant</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.krohf.KROHF.stability">
<code class="sig-name descname">stability</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">internal</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">external</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#KROHF.stability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.KROHF.stability" title="Permalink to this definition">¶</a></dt>
<dd><p>ROHF/ROKS stability analysis.</p>
<p>See also pyscf.scf.stability.rohf_stability function.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the RHF optimization space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. It is not available in current version.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>The return value includes two set of orbitals which are more close to
the required stable condition.</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.krohf.canonicalize">
<code class="sig-prename descclassname">pyscf.pbc.scf.krohf.</code><code class="sig-name descname">canonicalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">mo_coeff_kpts</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span></em>, <em class="sig-param"><span class="n">fock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#canonicalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.canonicalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Canonicalization diagonalizes the ROHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.krohf.get_occ">
<code class="sig-prename descclassname">pyscf.pbc.scf.krohf.</code><code class="sig-name descname">get_occ</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">mo_energy_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#get_occ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.krohf.get_roothaan_fock">
<code class="sig-prename descclassname">pyscf.pbc.scf.krohf.</code><code class="sig-name descname">get_roothaan_fock</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">focka_fockb</span></em>, <em class="sig-param"><span class="n">dma_dmb</span></em>, <em class="sig-param"><span class="n">s</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#get_roothaan_fock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.get_roothaan_fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Roothaan’s effective fock.</p>
<table>
<colgroup>
<col style="width: 26%"/>
<col style="width: 26%"/>
<col style="width: 19%"/>
<col style="width: 29%"/>
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>space</p></th>
<th class="head"><p>closed</p></th>
<th class="head"><p>open</p></th>
<th class="head"><p>virtual</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>closed</p></td>
<td><p>Fc</p></td>
<td><p>Fb</p></td>
<td><p>Fc</p></td>
</tr>
<tr class="row-odd"><td><p>open</p></td>
<td><p>Fb</p></td>
<td><p>Fc</p></td>
<td><p>Fa</p></td>
</tr>
<tr class="row-even"><td><p>virtual</p></td>
<td><p>Fc</p></td>
<td><p>Fa</p></td>
<td><p>Fc</p></td>
</tr>
</tbody>
</table>
<p>where Fc = (Fa + Fb) / 2</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Roothaan effective Fock matrix</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.krohf.make_rdm1">
<code class="sig-prename descclassname">pyscf.pbc.scf.krohf.</code><code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff_kpts</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha and beta spin one particle density matrices for all k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>dm_kpts : (2, nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.krohf.mulliken_meta">
<code class="sig-prename descclassname">pyscf.pbc.scf.krohf.</code><code class="sig-name descname">mulliken_meta</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">dm_ao_kpts</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">pre_orth_method</span><span class="o">=</span><span class="default_value">'ANO'</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/krohf/#mulliken_meta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.krohf.mulliken_meta" title="Permalink to this definition">¶</a></dt>
<dd><p>A modified Mulliken population analysis, based on meta-Lowdin AOs.</p>
<p>Note this function only computes the Mulliken population for the gamma
point density matrix.</p>
</dd></dl>
<span class="target" id="module-pyscf.pbc.scf.kghf"></span><p>Generalized Hartree-Fock for periodic systems with k-point sampling</p>
<dl class="py class">
<dt id="pyscf.pbc.scf.kghf.KGHF">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.pbc.scf.kghf.</code><code class="sig-name descname">KGHF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">array([[0., 0., 0.]])</span></em>, <em class="sig-param"><span class="n">exxdiv</span><span class="o">=</span><span class="default_value">'ewald'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kghf/#KGHF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kghf.KGHF" title="Permalink to this definition">¶</a></dt>
<dd><p>GHF class for PBCs.</p>
<dl class="py method">
<dt id="pyscf.pbc.scf.kghf.KGHF.convert_from_">
<code class="sig-name descname">convert_from_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kghf/#KGHF.convert_from_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kghf.KGHF.convert_from_" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert given mean-field object to RHF/ROHF</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kghf.KGHF.energy_elec">
<code class="sig-name descname">energy_elec</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">h1e_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">vhf_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kghf.KGHF.energy_elec" title="Permalink to this definition">¶</a></dt>
<dd><p>Following pyscf.scf.hf.energy_elec()</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kghf.KGHF.gen_response">
<code class="sig-name descname">gen_response</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">with_j</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">max_memory</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kghf.KGHF.gen_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a function to compute the product of KGHF response function and
KGHF density matrices.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kghf.KGHF.get_bands">
<code class="sig-name descname">get_bands</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kpts_band</span></em>, <em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kghf/#KGHF.get_bands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kghf.KGHF.get_bands" title="Permalink to this definition">¶</a></dt>
<dd><p>Get energy bands at the given (arbitrary) ‘band’ k-points.</p>
<dl class="simple">
<dt>Returns:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">(nmo,) ndarray or a list of (nmo,) ndarray</span></dt><dd><p>Bands energies E_n(k)</p>
</dd>
<dt>mo_coeff<span class="classifier">(nao, nmo) ndarray or a list of (nao,nmo) ndarray</span></dt><dd><p>Band orbitals psi_n(k)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kghf.KGHF.get_grad">
<code class="sig-name descname">get_grad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_coeff_kpts</span></em>, <em class="sig-param"><span class="n">mo_occ_kpts</span></em>, <em class="sig-param"><span class="n">fock</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kghf/#KGHF.get_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kghf.KGHF.get_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>returns 1D array of gradients, like non K-pt version
note that occ and virt indices of different k pts now occur
in sequential patches of the 1D array</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kghf.KGHF.get_hcore">
<code class="sig-name descname">get_hcore</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kghf/#KGHF.get_hcore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kghf.KGHF.get_hcore" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the core Hamiltonian AO matrices at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>kpts : (nkpts, 3) ndarray</p>
</dd>
<dt>Returns:</dt><dd><p>hcore : (nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kghf.KGHF.get_j">
<code class="sig-name descname">get_j</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kghf/#KGHF.get_j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kghf.KGHF.get_j" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute J matrix for the given density matrix and k-point (kpt).
When kpts_band is given, the J matrices on kpts_band are evaluated.</p>
<blockquote>
<div><p>J_{pq} = sum_{rs} (pq|rs) dm[s,r]</p>
</div></blockquote>
<p>where r,s are orbitals on kpt. p and q are orbitals on kpts_band
if kpts_band is given otherwise p and q are orbitals on kpt.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kghf.KGHF.get_k">
<code class="sig-name descname">get_k</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kghf/#KGHF.get_k"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kghf.KGHF.get_k" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute K matrix for the given density matrix.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kghf.KGHF.get_occ">
<code class="sig-name descname">get_occ</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mo_energy_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.pbc.scf.kghf.KGHF.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kghf.KGHF.get_ovlp">
<code class="sig-name descname">get_ovlp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kghf/#KGHF.get_ovlp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kghf.KGHF.get_ovlp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the overlap AO matrices at sampled k-points.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>kpts : (nkpts, 3) ndarray</p>
</dd>
<dt>Returns:</dt><dd><p>ovlp_kpts : (nkpts, nao, nao) ndarray</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.pbc.scf.kghf.KGHF.get_veff">
<code class="sig-name descname">get_veff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cell</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dm_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">vhf_last</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">hermi</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">kpts_band</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kghf/#KGHF.get_veff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kghf.KGHF.get_veff" title="Permalink to this definition">¶</a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.get_veff()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.RHF.get_veff()</span></code></p>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.pbc.scf.kghf.get_occ">
<code class="sig-prename descclassname">pyscf.pbc.scf.kghf.</code><code class="sig-name descname">get_occ</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">mo_energy_kpts</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff_kpts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/pyscf/pbc/scf/kghf/#get_occ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.pbc.scf.kghf.get_occ" title="Permalink to this definition">¶</a></dt>
<dd><p>Label the occupancies for each orbital for sampled k-points.</p>
<p>This is a k-point version of scf.hf.SCF.get_occ</p>
</dd></dl>




          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2015-2021, The PySCF Developers.
              
          </div>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>