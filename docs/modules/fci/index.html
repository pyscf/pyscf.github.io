
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>6.10. fci — Full configuration interaction &#8212; PySCF 2.0.0 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/material.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../../_static/favicon-32x32.png"/>
    <link rel="author" title="About these documents" href="../../about/" />
    <link rel="index" title="Index" href="../../genindex/" />
    <link rel="search" title="Search" href="../../search/" /> 
  
   
  
<style type="text/css">
  ul.ablog-archive {
    list-style: none;
    overflow: auto;
    margin-left: 0px;
  }
  ul.ablog-archive li {
    float: left;
    margin-right: 5px;
    font-size: 80%;
  }
  ul.postlist a {
    font-style: italic;
  }
  ul.postlist-style-disc {
    list-style-type: disc;
  }
  ul.postlist-style-none {
    list-style-type: none;
  }
  ul.postlist-style-circle {
    list-style-type: circle;
  }
</style>

  </head>
  <body dir=ltr
        data-md-color-primary=indigo data-md-color-accent=amber>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#modules/fci" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../" title="PySCF 2.0.0 documentation"
           class="md-header-nav__button md-logo">
          
              <img src="../../_static/pyscf-logo-white.svg" height="26"
                   alt="PySCF 2.0.0 documentation logo">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">PySCF 2.0</span>
          <span class="md-header-nav__topic"> 6.10. fci — Full configuration interaction </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../search/" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/pyscf/pyscf/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    PySCF
  </div>
</a>
          </div>
        </div>
      
      
  
  <script src="../../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../../"versions.json"",
        target_loc = "../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
            
            <li class="md-tabs__item"><a href="../../" class="md-tabs__link">Home</a></li>
            
            <li class="md-tabs__item"><a href="../../overview/" class="md-tabs__link">Overview</a></li>
            
            <li class="md-tabs__item"><a href="../../install/" class="md-tabs__link">Install</a></li>
            
            <li class="md-tabs__item"><a href="../../quickstart/" class="md-tabs__link">Quickstart</a></li>
            
            <li class="md-tabs__item"><a href="../../user/" class="md-tabs__link">User Guide</a></li>
            
            <li class="md-tabs__item"><a href="../../pyscf_api_docs/modules/" class="md-tabs__link">API</a></li>
            
            <li class="md-tabs__item"><a href="../../about/" class="md-tabs__link">About</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../" title="PySCF 2.0.0 documentation" class="md-nav__button md-logo">
      
        <img src="../../_static/pyscf-logo-white.svg" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../../"
       title="PySCF 2.0.0 documentation">PySCF 2.0</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/pyscf/pyscf/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    PySCF
  </div>
</a>
    </div>
  
  

  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
    
      <a href="../../overview/" class="md-nav__link">1. Overview</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../install/" class="md-nav__link">2. Install</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../quickstart/" class="md-nav__link">3. Quickstart</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../user/" class="md-nav__link">4. User Guide</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../pyscf_api_docs/pyscf/" class="md-nav__link">5. API</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../interface/" class="md-nav__link">6. Interface</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../about/" class="md-nav__link">7. About</a>
      
    
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
    <label class="md-nav__title" for="__toc">Contents</label>
  <ul class="md-nav__list" data-md-scrollfix="">
        <li class="md-nav__item"><a href="#modules-fci--page-root" class="md-nav__link">6.10. <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code> — Full configuration interaction</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#examples" class="md-nav__link">6.10.1. Examples</a>
        </li>
        <li class="md-nav__item"><a href="#program-reference" class="md-nav__link">6.10.2. Program reference</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#module-pyscf.fci.direct_spin1" class="md-nav__link">6.10.2.1. direct CI</a>
        </li>
        <li class="md-nav__item"><a href="#module-pyscf.fci.cistring" class="md-nav__link">6.10.2.2. cistring</a>
        </li>
        <li class="md-nav__item"><a href="#module-pyscf.fci.spin_op" class="md-nav__link">6.10.2.3. spin operator</a>
        </li>
        <li class="md-nav__item"><a href="#module-pyscf.fci.rdm" class="md-nav__link">6.10.2.4. rdm</a>
        </li>
        <li class="md-nav__item"><a href="#module-pyscf.fci.addons" class="md-nav__link">6.10.2.5. addons</a>
        </li></ul>
            </nav>
        </li></ul>
            </nav>
        </li>
    
<li class="md-nav__item"><a class="md-nav__extra_link" href="../../_sources/modules/fci.rst.txt">Show Source</a> </li>

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
             <div class="section" id="module-pyscf.fci">
<span id="fci-full-configuration-interaction"></span><span id="fci"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code> — Full configuration interaction<a class="headerlink" href="#module-pyscf.fci" title="Permalink to this headline">¶</a></h1>
<dl class="simple">
<dt>Different FCI solvers are implemented to support different type of symmetry.</dt><dd><p>Symmetry</p>
</dd>
</dl>
<p>File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
direct_spin0_symm   Yes           Yes            Yes                Yes
direct_spin1_symm   Yes           No             Yes                Yes
direct_spin0        No            Yes            Yes                Yes
direct_spin1        No            No             Yes                Yes
direct_uhf          No            No             Yes                No
direct_nosym        No            No             No**               Yes</p>
<ul class="simple">
<li><p>Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)</p></li>
</ul>
<p>** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) …</p>
<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">fci</span></code> module implements Full Configuration Interaction. Different
implementations are available for different Hamiltonian and spin symmetries.
One example for FCI calculation on HF molecule:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">fci</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span> <span class="s1">&#39;6-31g&#39;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">myhf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">myhf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">cisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">FCI</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">myhf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">)</span>
<span class="n">cisolver</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/fci/00-simple_fci.py">examples/fci/00-simple_fci.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/fci/01-given_h1e_h2e.py">examples/fci/01-given_h1e_h2e.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/fci/02-selected_ci.py">examples/fci/02-selected_ci.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/fci/10-spin.py">examples/fci/10-spin.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/fci/11-large_ci.py">examples/fci/11-large_ci.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/fci/12-multiple_roots.py">examples/fci/12-multiple_roots.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/fci/13-wfn_symmetry.py">examples/fci/13-wfn_symmetry.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/fci/14-density_matrix.py">examples/fci/14-density_matrix.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/fci/15-FCI_hamiltonian.py">examples/fci/15-FCI_hamiltonian.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/fci/30-h6_scan.py">examples/fci/30-h6_scan.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/fci/31-apply_2nd_quantized_op.py">examples/fci/31-apply_2nd_quantized_op.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/fci/32-wfn_overlap.py">examples/fci/32-wfn_overlap.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/fci/33-rotate_wfn.py">examples/fci/33-rotate_wfn.py</a></p></li>
</ul>
</div>
<div class="section" id="program-reference">
<h2>Program reference<a class="headerlink" href="#program-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-pyscf.fci.direct_spin1">
<span id="direct-ci"></span><h3>direct CI<a class="headerlink" href="#module-pyscf.fci.direct_spin1" title="Permalink to this headline">¶</a></h3>
<p>Full CI solver for spin-free Hamiltonian.  This solver can be used to compute
doublet, triplet,…</p>
<p>The CI wfn are stored as a 2D array [alpha,beta], where each row corresponds
to an alpha string.  For each row (alpha string), there are
total-num-beta-strings of columns.  Each column corresponds to a beta string.</p>
<dl class="simple">
<dt>Different FCI solvers are implemented to support different type of symmetry.</dt><dd><p>Symmetry</p>
</dd>
</dl>
<p>File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
direct_spin0_symm   Yes           Yes            Yes                Yes
direct_spin1_symm   Yes           No             Yes                Yes
direct_spin0        No            Yes            Yes                Yes
direct_spin1        No            No             Yes                Yes
direct_uhf          No            No             Yes                No
direct_nosym        No            No             No**               Yes</p>
<ul class="simple">
<li><p>Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)</p></li>
</ul>
<p>** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) …</p>
<dl class="py attribute">
<dt id="pyscf.fci.direct_spin1.FCI">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">FCI</code><a class="headerlink" href="#pyscf.fci.direct_spin1.FCI" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="../../pyscf_api_docs/pyscf.fci/#pyscf.fci.direct_spin1.FCISolver" title="pyscf.fci.direct_spin1.FCISolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.fci.direct_spin1.FCISolver</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="pyscf.fci.direct_spin1.FCIBase">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">FCIBase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Full CI solver</p>
<dl class="simple">
<dt>Attributes:</dt><dd><dl class="simple">
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code>.</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>Total number of iterations. Default is 100</p>
</dd>
<dt>max_space<span class="classifier">tuple of int</span></dt><dd><p>Davidson iteration space size. Default is 14.</p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>Energy convergence tolerance. Default is 1e-10.</p>
</dd>
<dt>level_shift<span class="classifier">float</span></dt><dd><p>Level shift applied in the preconditioner to avoid singularity.
Default is 1e-3</p>
</dd>
<dt>davidson_only<span class="classifier">bool</span></dt><dd><p>By default, the entire Hamiltonian matrix will be constructed and
diagonalized if the system is small (see attribute pspace_size).
Setting this parameter to True will enforce the eigenvalue
problems being solved by Davidson subspace algorithm.  This flag
should be enabled when initial guess is given or particular spin
symmetry or point-group symmetry is required because the initial
guess or symmetry are completely ignored in the direct diagonlization.</p>
</dd>
<dt>pspace_size<span class="classifier">int</span></dt><dd><p>The dimension of Hamiltonian matrix over which Davidson iteration
algorithm will be used for the eigenvalue problem.  Default is 400.
This is roughly corresponding to a (6e,6o) system.</p>
</dd>
<dt>nroots<span class="classifier">int</span></dt><dd><p>Number of states to be solved.  Default is 1, the ground state.</p>
</dd>
<dt>spin<span class="classifier">int or None</span></dt><dd><p>Spin (2S = nalpha-nbeta) of the system.  If this attribute is None,
spin will be determined by the argument nelec (number of electrons)
of the kernel function.</p>
</dd>
<dt>wfnsym<span class="classifier">str or int</span></dt><dd><p>Symmetry of wavefunction.  It is used only in direct_spin1_symm
and direct_spin0_symm solver.</p>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>eci<span class="classifier">float or a list of float</span></dt><dd><p>FCI energy(ies)</p>
</dd>
<dt>ci<span class="classifier">nparray</span></dt><dd><p>FCI wfn vector(s)</p>
</dd>
<dt>converged<span class="classifier">bool (or a list of bool for multiple roots)</span></dt><dd><p>Whether davidson iteration is converged</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">ao2mo</span><span class="p">,</span> <span class="n">fci</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;Li 0 0 0; Li 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h1</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">get_hcore</span><span class="p">())</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cisolver</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">direct_spin1</span><span class="o">.</span><span class="n">FCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">,</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">cisolver</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">eri</span><span class="p">,</span> <span class="n">h1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mol</span><span class="o">.</span><span class="n">nelec</span><span class="p">,</span> <span class="n">ecore</span><span class="o">=</span><span class="n">mol</span><span class="o">.</span><span class="n">energy_nuc</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">-14.4197890826</span>
</pre></div>
</div>
<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.absorb_h1e">
<code class="sig-name descname">absorb_h1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">fac</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.absorb_h1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.absorb_h1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify 2e Hamiltonian to include 1e Hamiltonian contribution.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.contract_1e">
<code class="sig-name descname">contract_1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f1e</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.contract_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.contract_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 1-electron Hamiltonian with a FCI vector to get a new FCI
vector.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.contract_2e">
<code class="sig-name descname">contract_2e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.contract_2e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.contract_2e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 4-index tensor eri[pqrs] with a FCI vector</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}|output\rangle = E_{pq} E_{rs} eri_{pq,rs} |CI\rangle \\\end{split}\\\begin{split}E_{pq}E_{rs} = E_{pr,qs} + \delta_{qr} E_{ps} \\\end{split}\\E_{pq} = p^+ q + \bar{p}^+ \bar{q}\\E_{pr,qs} = p^+ r^+ s q + \bar{p}^+ r^+ s \bar{q} + ...\end{aligned}\end{align} \]</div>
<p><span class="math notranslate nohighlight">\(p,q,...\)</span> means spin-up orbitals and <span class="math notranslate nohighlight">\(\bar{p}, \bar{q}\)</span> means
spin-down orbitals.</p>
<p>Note the input argument eri is NOT the 2e hamiltonian tensor. 2e hamiltonian is</p>
<div class="math notranslate nohighlight">
\[\begin{split}h2e &amp;= (pq|rs) E_{pr,qs} \\
    &amp;= (pq|rs) (E_{pq}E_{rs} - \delta_{qr} E_{ps}) \\
    &amp;= eri_{pq,rs} E_{pq}E_{rs} \\\end{split}\]</div>
<p>So the relation between eri and hamiltonian (the 2e-integral tensor) is</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (1/Nelec) \sum_q (pq|qs)\]</div>
<p>to restore the symmetry between pq and rs,</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (.5/Nelec) [\sum_q (pq|qs) + \sum_p (pq|rp)]\]</div>
<p>See also <code class="xref py py-func docutils literal notranslate"><span class="pre">direct_spin1.absorb_h1e()</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.energy">
<code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the FCI electronic energy for given Hamiltonian and FCI vector.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.get_init_guess">
<code class="sig-name descname">get_init_guess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">nroots</span></em>, <em class="sig-param"><span class="n">hdiag</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.get_init_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.get_init_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess is the single Slater determinant</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">ci0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lindep</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_cycle</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_space</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nroots</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">davidson_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pspace_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">orbsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wfnsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ecore</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel function is the main driver of a method.  Every method should
define the kernel function as the entry of the calculation.  Note the
return value of kernel function is not strictly defined.  It can be
anything related to the method (such as the energy, the wave-function,
the DFT mesh grids etc.).</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.make_hdiag">
<code class="sig-name descname">make_hdiag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.make_hdiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.make_hdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagonal Hamiltonian for Davidson preconditioner</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-traced one-particle density matrix</p>
<p>dm1[p,q] = &lt;q_alpha^dagger p_alpha&gt; + &lt;q_beta^dagger p_beta&gt;</p>
<p>The convention is based on McWeeney’s book, Eq (5.4.20)
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(‘pq,qp’, h1, rdm1)</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.make_rdm12">
<code class="sig-name descname">make_rdm12</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.make_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.make_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced 1- and 2-particle density matrices.</p>
<dl class="simple">
<dt>1pdm[p,q] = :math:<a href="#id1"><span class="problematic" id="id2">`</span></a>langle <a href="#id27"><span class="problematic" id="id28">q_</span></a>alpha^dagger <a href="#id29"><span class="problematic" id="id30">p_</span></a>alpha rangle +</dt><dd><p>langle <a href="#id31"><span class="problematic" id="id32">q_</span></a>beta^dagger  <a href="#id33"><span class="problematic" id="id34">p_</span></a>beta rangle`;</p>
</dd>
<dt>2pdm[p,q,r,s] = :math:<a href="#id3"><span class="problematic" id="id4">`</span></a>langle <a href="#id35"><span class="problematic" id="id36">p_</span></a>alpha^dagger <a href="#id37"><span class="problematic" id="id38">r_</span></a>alpha^dagger <a href="#id39"><span class="problematic" id="id40">s_</span></a>alpha <a href="#id41"><span class="problematic" id="id42">q_</span></a>alpharangle +</dt><dd><p>langle <a href="#id43"><span class="problematic" id="id44">p_</span></a>beta^dagger  <a href="#id45"><span class="problematic" id="id46">r_</span></a>alpha^dagger <a href="#id47"><span class="problematic" id="id48">s_</span></a>alpha <a href="#id49"><span class="problematic" id="id50">q_</span></a>betarangle +
langle <a href="#id51"><span class="problematic" id="id52">p_</span></a>alpha^dagger <a href="#id53"><span class="problematic" id="id54">r_</span></a>beta^dagger  <a href="#id55"><span class="problematic" id="id56">s_</span></a>beta  <a href="#id57"><span class="problematic" id="id58">q_</span></a>alpharangle +
langle <a href="#id59"><span class="problematic" id="id60">p_</span></a>beta^dagger  <a href="#id61"><span class="problematic" id="id62">r_</span></a>beta^dagger  <a href="#id63"><span class="problematic" id="id64">s_</span></a>beta  <a href="#id65"><span class="problematic" id="id66">q_</span></a>betarangle`.</p>
</dd>
</dl>
<p>Energy should be computed as
E = einsum(‘pq,qp’, h1, 1pdm) + 1/2 * einsum(‘pqrs,pqrs’, eri, 2pdm)
where h1[p,q] = &lt;p|h|q&gt; and eri[p,q,r,s] = (pq|rs)</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.make_rdm12s">
<code class="sig-name descname">make_rdm12s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.make_rdm12s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.make_rdm12s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1- and 2-particle density matrices.
The return values include two lists, a list of 1-particle density matrices
and a list of 2-particle density matrices.  The density matrices are:
(alpha,alpha), (beta,beta) for 1-particle density matrices;
(alpha,alpha,alpha,alpha), (alpha,alpha,beta,beta),
(beta,beta,beta,beta) for 2-particle density matrices.</p>
<p>1pdm[p,q] = <span class="math notranslate nohighlight">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math notranslate nohighlight">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
<p>Energy should be computed as
E = einsum(‘pq,qp’, h1, 1pdm) + 1/2 * einsum(‘pqrs,pqrs’, eri, 2pdm)
where h1[p,q] = &lt;p|h|q&gt; and eri[p,q,r,s] = (pq|rs)</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.make_rdm1s">
<code class="sig-name descname">make_rdm1s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.make_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.make_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta)</p>
<p>dm1[p,q] = &lt;q^dagger p&gt;</p>
<p>The convention is based on McWeeney’s book, Eq (5.4.20).
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(‘pq,qp’, h1, rdm1)</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.make_rdm2">
<code class="sig-name descname">make_rdm2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.make_rdm2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.make_rdm2" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced 2-particle density matrice</p>
<p>NOTE the 2pdm is <span class="math notranslate nohighlight">\(\langle p^\dagger q^\dagger s r\rangle\)</span> but
stored as [p,r,q,s]</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.pspace">
<code class="sig-name descname">pspace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">hdiag</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">np</span><span class="o">=</span><span class="default_value">400</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.pspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.pspace" title="Permalink to this definition">¶</a></dt>
<dd><p>pspace Hamiltonian to improve Davidson preconditioner. See, CPL, 169, 463</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.spin_square">
<code class="sig-name descname">spin_square</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square for RHF-FCI CI wfn only (obtained from spin-degenerated
Hamiltonian)</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.trans_rdm1">
<code class="sig-name descname">trans_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.trans_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.trans_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1-particle transition density matrices.</p>
<dl class="simple">
<dt>1pdm[p,q] = :math:<a href="#id5"><span class="problematic" id="id6">`</span></a>langle <a href="#id67"><span class="problematic" id="id68">q_</span></a>alpha^dagger <a href="#id69"><span class="problematic" id="id70">p_</span></a>alpha rangle</dt><dd><ul class="simple">
<li><p>langle <a href="#id71"><span class="problematic" id="id72">q_</span></a>beta^dagger <a href="#id73"><span class="problematic" id="id74">p_</span></a>beta rangle`</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.trans_rdm12">
<code class="sig-name descname">trans_rdm12</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.trans_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.trans_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1- and 2-particle transition density matrices.</p>
<p>1pdm[p,q] = <span class="math notranslate nohighlight">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math notranslate nohighlight">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.trans_rdm12s">
<code class="sig-name descname">trans_rdm12s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.trans_rdm12s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.trans_rdm12s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1- and 2-particle transition density matrices.
The return values include two lists, a list of 1-particle transition
density matrices and a list of 2-particle transition density matrices.
The density matrices are:
(alpha,alpha), (beta,beta) for 1-particle transition density matrices;
(alpha,alpha,alpha,alpha), (alpha,alpha,beta,beta),
(beta,beta,alpha,alpha), (beta,beta,beta,beta) for 2-particle transition
density matrices.</p>
<p>1pdm[p,q] = <span class="math notranslate nohighlight">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math notranslate nohighlight">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1.FCIBase.trans_rdm1s">
<code class="sig-name descname">trans_rdm1s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCIBase.trans_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCIBase.trans_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated transition 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta).
See also function <a class="reference internal" href="../../pyscf_api_docs/pyscf.fci/#pyscf.fci.direct_spin1.make_rdm1s" title="pyscf.fci.direct_spin1.make_rdm1s"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_rdm1s()</span></code></a></p>
<p>1pdm[p,q] = <span class="math notranslate nohighlight">\(\langle q^\dagger p \rangle\)</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="pyscf.fci.direct_spin1.FCISolver">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">FCISolver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#FCISolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.FCISolver" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.absorb_h1e">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">absorb_h1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">fac</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#absorb_h1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.absorb_h1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify 2e Hamiltonian to include 1e Hamiltonian contribution.</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.contract_1e">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">contract_1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f1e</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#contract_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.contract_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 1-electron Hamiltonian with a FCI vector to get a new FCI
vector.</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.contract_2e">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">contract_2e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#contract_2e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.contract_2e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 4-index tensor eri[pqrs] with a FCI vector</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}|output\rangle = E_{pq} E_{rs} eri_{pq,rs} |CI\rangle \\\end{split}\\\begin{split}E_{pq}E_{rs} = E_{pr,qs} + \delta_{qr} E_{ps} \\\end{split}\\E_{pq} = p^+ q + \bar{p}^+ \bar{q}\\E_{pr,qs} = p^+ r^+ s q + \bar{p}^+ r^+ s \bar{q} + ...\end{aligned}\end{align} \]</div>
<p><span class="math notranslate nohighlight">\(p,q,...\)</span> means spin-up orbitals and <span class="math notranslate nohighlight">\(\bar{p}, \bar{q}\)</span> means
spin-down orbitals.</p>
<p>Note the input argument eri is NOT the 2e hamiltonian tensor. 2e hamiltonian is</p>
<div class="math notranslate nohighlight">
\[\begin{split}h2e &amp;= (pq|rs) E_{pr,qs} \\
    &amp;= (pq|rs) (E_{pq}E_{rs} - \delta_{qr} E_{ps}) \\
    &amp;= eri_{pq,rs} E_{pq}E_{rs} \\\end{split}\]</div>
<p>So the relation between eri and hamiltonian (the 2e-integral tensor) is</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (1/Nelec) \sum_q (pq|qs)\]</div>
<p>to restore the symmetry between pq and rs,</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (.5/Nelec) [\sum_q (pq|qs) + \sum_p (pq|rp)]\]</div>
<p>See also <code class="xref py py-func docutils literal notranslate"><span class="pre">direct_spin1.absorb_h1e()</span></code></p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.energy">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the FCI electronic energy for given Hamiltonian and FCI vector.</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.get_init_guess">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">get_init_guess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">nroots</span></em>, <em class="sig-param"><span class="n">hdiag</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#get_init_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.get_init_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess is the single Slater determinant</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.make_hdiag">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">make_hdiag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#make_hdiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.make_hdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagonal Hamiltonian for Davidson preconditioner</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.make_rdm1">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-traced one-particle density matrix</p>
<p>dm1[p,q] = &lt;q_alpha^dagger p_alpha&gt; + &lt;q_beta^dagger p_beta&gt;</p>
<p>The convention is based on McWeeney’s book, Eq (5.4.20)
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(‘pq,qp’, h1, rdm1)</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.make_rdm12">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">make_rdm12</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#make_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.make_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced 1- and 2-particle density matrices.</p>
<dl class="simple">
<dt>1pdm[p,q] = :math:<a href="#id7"><span class="problematic" id="id8">`</span></a>langle <a href="#id75"><span class="problematic" id="id76">q_</span></a>alpha^dagger <a href="#id77"><span class="problematic" id="id78">p_</span></a>alpha rangle +</dt><dd><p>langle <a href="#id79"><span class="problematic" id="id80">q_</span></a>beta^dagger  <a href="#id81"><span class="problematic" id="id82">p_</span></a>beta rangle`;</p>
</dd>
<dt>2pdm[p,q,r,s] = :math:<a href="#id9"><span class="problematic" id="id10">`</span></a>langle <a href="#id83"><span class="problematic" id="id84">p_</span></a>alpha^dagger <a href="#id85"><span class="problematic" id="id86">r_</span></a>alpha^dagger <a href="#id87"><span class="problematic" id="id88">s_</span></a>alpha <a href="#id89"><span class="problematic" id="id90">q_</span></a>alpharangle +</dt><dd><p>langle <a href="#id91"><span class="problematic" id="id92">p_</span></a>beta^dagger  <a href="#id93"><span class="problematic" id="id94">r_</span></a>alpha^dagger <a href="#id95"><span class="problematic" id="id96">s_</span></a>alpha <a href="#id97"><span class="problematic" id="id98">q_</span></a>betarangle +
langle <a href="#id99"><span class="problematic" id="id100">p_</span></a>alpha^dagger <a href="#id101"><span class="problematic" id="id102">r_</span></a>beta^dagger  <a href="#id103"><span class="problematic" id="id104">s_</span></a>beta  <a href="#id105"><span class="problematic" id="id106">q_</span></a>alpharangle +
langle <a href="#id107"><span class="problematic" id="id108">p_</span></a>beta^dagger  <a href="#id109"><span class="problematic" id="id110">r_</span></a>beta^dagger  <a href="#id111"><span class="problematic" id="id112">s_</span></a>beta  <a href="#id113"><span class="problematic" id="id114">q_</span></a>betarangle`.</p>
</dd>
</dl>
<p>Energy should be computed as
E = einsum(‘pq,qp’, h1, 1pdm) + 1/2 * einsum(‘pqrs,pqrs’, eri, 2pdm)
where h1[p,q] = &lt;p|h|q&gt; and eri[p,q,r,s] = (pq|rs)</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.make_rdm12s">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">make_rdm12s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#make_rdm12s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.make_rdm12s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1- and 2-particle density matrices.
The return values include two lists, a list of 1-particle density matrices
and a list of 2-particle density matrices.  The density matrices are:
(alpha,alpha), (beta,beta) for 1-particle density matrices;
(alpha,alpha,alpha,alpha), (alpha,alpha,beta,beta),
(beta,beta,beta,beta) for 2-particle density matrices.</p>
<p>1pdm[p,q] = <span class="math notranslate nohighlight">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math notranslate nohighlight">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
<p>Energy should be computed as
E = einsum(‘pq,qp’, h1, 1pdm) + 1/2 * einsum(‘pqrs,pqrs’, eri, 2pdm)
where h1[p,q] = &lt;p|h|q&gt; and eri[p,q,r,s] = (pq|rs)</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.make_rdm1s">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">make_rdm1s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#make_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.make_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta)</p>
<p>dm1[p,q] = &lt;q^dagger p&gt;</p>
<p>The convention is based on McWeeney’s book, Eq (5.4.20).
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(‘pq,qp’, h1, rdm1)</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.pspace">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">pspace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">hdiag</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">np</span><span class="o">=</span><span class="default_value">400</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#pspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.pspace" title="Permalink to this definition">¶</a></dt>
<dd><p>pspace Hamiltonian to improve Davidson preconditioner. See, CPL, 169, 463</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.trans_rdm1">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">trans_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#trans_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.trans_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1-particle transition density matrices.</p>
<dl class="simple">
<dt>1pdm[p,q] = :math:<a href="#id11"><span class="problematic" id="id12">`</span></a>langle <a href="#id115"><span class="problematic" id="id116">q_</span></a>alpha^dagger <a href="#id117"><span class="problematic" id="id118">p_</span></a>alpha rangle</dt><dd><ul class="simple">
<li><p>langle <a href="#id119"><span class="problematic" id="id120">q_</span></a>beta^dagger <a href="#id121"><span class="problematic" id="id122">p_</span></a>beta rangle`</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.trans_rdm12">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">trans_rdm12</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#trans_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.trans_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1- and 2-particle transition density matrices.</p>
<p>1pdm[p,q] = <span class="math notranslate nohighlight">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math notranslate nohighlight">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.trans_rdm12s">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">trans_rdm12s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#trans_rdm12s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.trans_rdm12s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1- and 2-particle transition density matrices.
The return values include two lists, a list of 1-particle transition
density matrices and a list of 2-particle transition density matrices.
The density matrices are:
(alpha,alpha), (beta,beta) for 1-particle transition density matrices;
(alpha,alpha,alpha,alpha), (alpha,alpha,beta,beta),
(beta,beta,alpha,alpha), (beta,beta,beta,beta) for 2-particle transition
density matrices.</p>
<p>1pdm[p,q] = <span class="math notranslate nohighlight">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math notranslate nohighlight">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin1.trans_rdm1s">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1.</code><code class="sig-name descname">trans_rdm1s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1/#trans_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1.trans_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated transition 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta).
See also function <a class="reference internal" href="../../pyscf_api_docs/pyscf.fci/#pyscf.fci.direct_spin1.make_rdm1s" title="pyscf.fci.direct_spin1.make_rdm1s"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_rdm1s()</span></code></a></p>
<p>1pdm[p,q] = <span class="math notranslate nohighlight">\(\langle q^\dagger p \rangle\)</span></p>
</dd></dl>

<hr class="docutils" />
<span class="target" id="module-pyscf.fci.direct_spin1_symm"></span><dl class="simple">
<dt>Different FCI solvers are implemented to support different type of symmetry.</dt><dd><p>Symmetry</p>
</dd>
</dl>
<p>File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
direct_spin0_symm   Yes           Yes            Yes                Yes
direct_spin1_symm   Yes           No             Yes                Yes
direct_spin0        No            Yes            Yes                Yes
direct_spin1        No            No             Yes                Yes
direct_uhf          No            No             Yes                No
direct_nosym        No            No             No**               Yes</p>
<ul class="simple">
<li><p>Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)</p></li>
</ul>
<p>** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) …</p>
<dl class="py attribute">
<dt id="pyscf.fci.direct_spin1_symm.FCI">
<code class="sig-prename descclassname">pyscf.fci.direct_spin1_symm.</code><code class="sig-name descname">FCI</code><a class="headerlink" href="#pyscf.fci.direct_spin1_symm.FCI" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="../../pyscf_api_docs/pyscf.fci/#pyscf.fci.direct_spin1_symm.FCISolver" title="pyscf.fci.direct_spin1_symm.FCISolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.fci.direct_spin1_symm.FCISolver</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="pyscf.fci.direct_spin1_symm.FCISolver">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.fci.direct_spin1_symm.</code><code class="sig-name descname">FCISolver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1_symm/#FCISolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1_symm.FCISolver" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="pyscf.fci.direct_spin1_symm.FCISolver.absorb_h1e">
<code class="sig-name descname">absorb_h1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">fac</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1_symm/#FCISolver.absorb_h1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1_symm.FCISolver.absorb_h1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify 2e Hamiltonian to include 1e Hamiltonian contribution.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1_symm.FCISolver.contract_1e">
<code class="sig-name descname">contract_1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f1e</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1_symm/#FCISolver.contract_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1_symm.FCISolver.contract_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 1-electron Hamiltonian with a FCI vector to get a new FCI
vector.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1_symm.FCISolver.contract_2e">
<code class="sig-name descname">contract_2e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">orbsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wfnsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1_symm/#FCISolver.contract_2e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1_symm.FCISolver.contract_2e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 4-index tensor eri[pqrs] with a FCI vector</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}|output\rangle = E_{pq} E_{rs} eri_{pq,rs} |CI\rangle \\\end{split}\\\begin{split}E_{pq}E_{rs} = E_{pr,qs} + \delta_{qr} E_{ps} \\\end{split}\\E_{pq} = p^+ q + \bar{p}^+ \bar{q}\\E_{pr,qs} = p^+ r^+ s q + \bar{p}^+ r^+ s \bar{q} + ...\end{aligned}\end{align} \]</div>
<p><span class="math notranslate nohighlight">\(p,q,...\)</span> means spin-up orbitals and <span class="math notranslate nohighlight">\(\bar{p}, \bar{q}\)</span> means
spin-down orbitals.</p>
<p>Note the input argument eri is NOT the 2e hamiltonian tensor. 2e hamiltonian is</p>
<div class="math notranslate nohighlight">
\[\begin{split}h2e &amp;= (pq|rs) E_{pr,qs} \\
    &amp;= (pq|rs) (E_{pq}E_{rs} - \delta_{qr} E_{ps}) \\
    &amp;= eri_{pq,rs} E_{pq}E_{rs} \\\end{split}\]</div>
<p>So the relation between eri and hamiltonian (the 2e-integral tensor) is</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (1/Nelec) \sum_q (pq|qs)\]</div>
<p>to restore the symmetry between pq and rs,</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (.5/Nelec) [\sum_q (pq|qs) + \sum_p (pq|rp)]\]</div>
<p>See also <code class="xref py py-func docutils literal notranslate"><span class="pre">direct_spin1.absorb_h1e()</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1_symm.FCISolver.get_init_guess">
<code class="sig-name descname">get_init_guess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">nroots</span></em>, <em class="sig-param"><span class="n">hdiag</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1_symm/#FCISolver.get_init_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1_symm.FCISolver.get_init_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess is the single Slater determinant</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1_symm.FCISolver.guess_wfnsym">
<code class="sig-name descname">guess_wfnsym</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">fcivec</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">orbsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wfnsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1_symm/#FCISolver.guess_wfnsym"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1_symm.FCISolver.guess_wfnsym" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess point group symmetry of the FCI wavefunction.  If fcivec is
given, the symmetry of fcivec is used.  Otherwise the symmetry is
based on the HF determinant.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1_symm.FCISolver.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">ci0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lindep</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_cycle</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_space</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nroots</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">davidson_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pspace_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">orbsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wfnsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ecore</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1_symm/#FCISolver.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1_symm.FCISolver.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel function is the main driver of a method.  Every method should
define the kernel function as the entry of the calculation.  Note the
return value of kernel function is not strictly defined.  It can be
anything related to the method (such as the energy, the wave-function,
the DFT mesh grids etc.).</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1_symm.FCISolver.make_hdiag">
<code class="sig-name descname">make_hdiag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1_symm/#FCISolver.make_hdiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1_symm.FCISolver.make_hdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagonal Hamiltonian for Davidson preconditioner</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin1_symm.FCISolver.pspace">
<code class="sig-name descname">pspace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">hdiag</span></em>, <em class="sig-param"><span class="n">np</span><span class="o">=</span><span class="default_value">400</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin1_symm/#FCISolver.pspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin1_symm.FCISolver.pspace" title="Permalink to this definition">¶</a></dt>
<dd><p>pspace Hamiltonian to improve Davidson preconditioner. See, CPL, 169, 463</p>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<span class="target" id="module-pyscf.fci.direct_spin0"></span><p>FCI solver for Singlet state</p>
<dl class="simple">
<dt>Different FCI solvers are implemented to support different type of symmetry.</dt><dd><p>Symmetry</p>
</dd>
</dl>
<p>File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
direct_spin0_symm   Yes           Yes            Yes                Yes
direct_spin1_symm   Yes           No             Yes                Yes
direct_spin0        No            Yes            Yes                Yes
direct_spin1        No            No             Yes                Yes
direct_uhf          No            No             Yes                No
direct_nosym        No            No             No**               Yes</p>
<ul class="simple">
<li><p>Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)</p></li>
</ul>
<p>** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) …</p>
<p>direct_spin0 solver is specified for singlet state. However, calling this
solver sometimes ends up with the error “State not singlet x.xxxxxxe-06” due
to numerical issues. Calling direct_spin1 for singlet state is slightly
slower but more robust than direct_spin0 especially when combining to energy
penalty method (<code class="xref py py-func docutils literal notranslate"><span class="pre">fix_spin_()</span></code>)</p>
<dl class="py attribute">
<dt id="pyscf.fci.direct_spin0.FCI">
<code class="sig-prename descclassname">pyscf.fci.direct_spin0.</code><code class="sig-name descname">FCI</code><a class="headerlink" href="#pyscf.fci.direct_spin0.FCI" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="../../pyscf_api_docs/pyscf.fci/#pyscf.fci.direct_spin0.FCISolver" title="pyscf.fci.direct_spin0.FCISolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.fci.direct_spin0.FCISolver</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="pyscf.fci.direct_spin0.FCISolver">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.fci.direct_spin0.</code><code class="sig-name descname">FCISolver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#FCISolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.FCISolver" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="pyscf.fci.direct_spin0.FCISolver.contract_1e">
<code class="sig-name descname">contract_1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f1e</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#FCISolver.contract_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.FCISolver.contract_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 1-electron Hamiltonian with a FCI vector to get a new FCI
vector.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0.FCISolver.contract_2e">
<code class="sig-name descname">contract_2e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#FCISolver.contract_2e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.FCISolver.contract_2e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 4-index tensor eri[pqrs] with a FCI vector</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}|output\rangle = E_{pq} E_{rs} eri_{pq,rs} |CI\rangle \\\end{split}\\\begin{split}E_{pq}E_{rs} = E_{pr,qs} + \delta_{qr} E_{ps} \\\end{split}\\E_{pq} = p^+ q + \bar{p}^+ \bar{q}\\E_{pr,qs} = p^+ r^+ s q + \bar{p}^+ r^+ s \bar{q} + ...\end{aligned}\end{align} \]</div>
<p><span class="math notranslate nohighlight">\(p,q,...\)</span> means spin-up orbitals and <span class="math notranslate nohighlight">\(\bar{p}, \bar{q}\)</span> means
spin-down orbitals.</p>
<p>Note the input argument eri is NOT the 2e hamiltonian tensor. 2e hamiltonian is</p>
<div class="math notranslate nohighlight">
\[\begin{split}h2e &amp;= (pq|rs) E_{pr,qs} \\
    &amp;= (pq|rs) (E_{pq}E_{rs} - \delta_{qr} E_{ps}) \\
    &amp;= eri_{pq,rs} E_{pq}E_{rs} \\\end{split}\]</div>
<p>So the relation between eri and hamiltonian (the 2e-integral tensor) is</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (1/Nelec) \sum_q (pq|qs)\]</div>
<p>to restore the symmetry between pq and rs,</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (.5/Nelec) [\sum_q (pq|qs) + \sum_p (pq|rp)]\]</div>
<p>See also <code class="xref py py-func docutils literal notranslate"><span class="pre">direct_spin1.absorb_h1e()</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0.FCISolver.energy">
<code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#FCISolver.energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.FCISolver.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the FCI electronic energy for given Hamiltonian and FCI vector.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0.FCISolver.get_init_guess">
<code class="sig-name descname">get_init_guess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">nroots</span></em>, <em class="sig-param"><span class="n">hdiag</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#FCISolver.get_init_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.FCISolver.get_init_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess is the single Slater determinant</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0.FCISolver.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">ci0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lindep</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_cycle</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_space</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nroots</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">davidson_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pspace_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">orbsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wfnsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ecore</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#FCISolver.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.FCISolver.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel function is the main driver of a method.  Every method should
define the kernel function as the entry of the calculation.  Note the
return value of kernel function is not strictly defined.  It can be
anything related to the method (such as the energy, the wave-function,
the DFT mesh grids etc.).</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0.FCISolver.make_hdiag">
<code class="sig-name descname">make_hdiag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#FCISolver.make_hdiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.FCISolver.make_hdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagonal Hamiltonian for Davidson preconditioner</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0.FCISolver.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#FCISolver.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.FCISolver.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-traced one-particle density matrix</p>
<p>dm1[p,q] = &lt;q_alpha^dagger p_alpha&gt; + &lt;q_beta^dagger p_beta&gt;</p>
<p>The convention is based on McWeeney’s book, Eq (5.4.20)
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(‘pq,qp’, h1, rdm1)</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0.FCISolver.make_rdm12">
<code class="sig-name descname">make_rdm12</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#FCISolver.make_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.FCISolver.make_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced 1- and 2-particle density matrices.</p>
<dl class="simple">
<dt>1pdm[p,q] = :math:<a href="#id13"><span class="problematic" id="id14">`</span></a>langle <a href="#id123"><span class="problematic" id="id124">q_</span></a>alpha^dagger <a href="#id125"><span class="problematic" id="id126">p_</span></a>alpha rangle +</dt><dd><p>langle <a href="#id127"><span class="problematic" id="id128">q_</span></a>beta^dagger  <a href="#id129"><span class="problematic" id="id130">p_</span></a>beta rangle`;</p>
</dd>
<dt>2pdm[p,q,r,s] = :math:<a href="#id15"><span class="problematic" id="id16">`</span></a>langle <a href="#id131"><span class="problematic" id="id132">p_</span></a>alpha^dagger <a href="#id133"><span class="problematic" id="id134">r_</span></a>alpha^dagger <a href="#id135"><span class="problematic" id="id136">s_</span></a>alpha <a href="#id137"><span class="problematic" id="id138">q_</span></a>alpharangle +</dt><dd><p>langle <a href="#id139"><span class="problematic" id="id140">p_</span></a>beta^dagger  <a href="#id141"><span class="problematic" id="id142">r_</span></a>alpha^dagger <a href="#id143"><span class="problematic" id="id144">s_</span></a>alpha <a href="#id145"><span class="problematic" id="id146">q_</span></a>betarangle +
langle <a href="#id147"><span class="problematic" id="id148">p_</span></a>alpha^dagger <a href="#id149"><span class="problematic" id="id150">r_</span></a>beta^dagger  <a href="#id151"><span class="problematic" id="id152">s_</span></a>beta  <a href="#id153"><span class="problematic" id="id154">q_</span></a>alpharangle +
langle <a href="#id155"><span class="problematic" id="id156">p_</span></a>beta^dagger  <a href="#id157"><span class="problematic" id="id158">r_</span></a>beta^dagger  <a href="#id159"><span class="problematic" id="id160">s_</span></a>beta  <a href="#id161"><span class="problematic" id="id162">q_</span></a>betarangle`.</p>
</dd>
</dl>
<p>Energy should be computed as
E = einsum(‘pq,qp’, h1, 1pdm) + 1/2 * einsum(‘pqrs,pqrs’, eri, 2pdm)
where h1[p,q] = &lt;p|h|q&gt; and eri[p,q,r,s] = (pq|rs)</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0.FCISolver.make_rdm1s">
<code class="sig-name descname">make_rdm1s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#FCISolver.make_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.FCISolver.make_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta)</p>
<p>dm1[p,q] = &lt;q^dagger p&gt;</p>
<p>The convention is based on McWeeney’s book, Eq (5.4.20).
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(‘pq,qp’, h1, rdm1)</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0.FCISolver.trans_rdm1">
<code class="sig-name descname">trans_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#FCISolver.trans_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.FCISolver.trans_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1-particle transition density matrices.</p>
<dl class="simple">
<dt>1pdm[p,q] = :math:<a href="#id17"><span class="problematic" id="id18">`</span></a>langle <a href="#id163"><span class="problematic" id="id164">q_</span></a>alpha^dagger <a href="#id165"><span class="problematic" id="id166">p_</span></a>alpha rangle</dt><dd><ul class="simple">
<li><p>langle <a href="#id167"><span class="problematic" id="id168">q_</span></a>beta^dagger <a href="#id169"><span class="problematic" id="id170">p_</span></a>beta rangle`</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0.FCISolver.trans_rdm12">
<code class="sig-name descname">trans_rdm12</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#FCISolver.trans_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.FCISolver.trans_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1- and 2-particle transition density matrices.</p>
<p>1pdm[p,q] = <span class="math notranslate nohighlight">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math notranslate nohighlight">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0.FCISolver.trans_rdm1s">
<code class="sig-name descname">trans_rdm1s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#FCISolver.trans_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.FCISolver.trans_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated transition 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta).
See also function <a class="reference internal" href="../../pyscf_api_docs/pyscf.fci/#pyscf.fci.direct_spin0.make_rdm1s" title="pyscf.fci.direct_spin0.make_rdm1s"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_rdm1s()</span></code></a></p>
<p>1pdm[p,q] = <span class="math notranslate nohighlight">\(\langle q^\dagger p \rangle\)</span></p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin0.contract_1e">
<code class="sig-prename descclassname">pyscf.fci.direct_spin0.</code><code class="sig-name descname">contract_1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f1e</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#contract_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.contract_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 1-electron Hamiltonian with a FCI vector to get a new FCI
vector.</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin0.contract_2e">
<code class="sig-prename descclassname">pyscf.fci.direct_spin0.</code><code class="sig-name descname">contract_2e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#contract_2e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.contract_2e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 4-index tensor eri[pqrs] with a FCI vector</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}|output\rangle = E_{pq} E_{rs} eri_{pq,rs} |CI\rangle \\\end{split}\\\begin{split}E_{pq}E_{rs} = E_{pr,qs} + \delta_{qr} E_{ps} \\\end{split}\\E_{pq} = p^+ q + \bar{p}^+ \bar{q}\\E_{pr,qs} = p^+ r^+ s q + \bar{p}^+ r^+ s \bar{q} + ...\end{aligned}\end{align} \]</div>
<p><span class="math notranslate nohighlight">\(p,q,...\)</span> means spin-up orbitals and <span class="math notranslate nohighlight">\(\bar{p}, \bar{q}\)</span> means
spin-down orbitals.</p>
<p>Note the input argument eri is NOT the 2e hamiltonian tensor. 2e hamiltonian is</p>
<div class="math notranslate nohighlight">
\[\begin{split}h2e &amp;= (pq|rs) E_{pr,qs} \\
    &amp;= (pq|rs) (E_{pq}E_{rs} - \delta_{qr} E_{ps}) \\
    &amp;= eri_{pq,rs} E_{pq}E_{rs} \\\end{split}\]</div>
<p>So the relation between eri and hamiltonian (the 2e-integral tensor) is</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (1/Nelec) \sum_q (pq|qs)\]</div>
<p>to restore the symmetry between pq and rs,</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (.5/Nelec) [\sum_q (pq|qs) + \sum_p (pq|rp)]\]</div>
<p>See also <code class="xref py py-func docutils literal notranslate"><span class="pre">direct_spin1.absorb_h1e()</span></code></p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin0.make_hdiag">
<code class="sig-prename descclassname">pyscf.fci.direct_spin0.</code><code class="sig-name descname">make_hdiag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#make_hdiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.make_hdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagonal Hamiltonian for Davidson preconditioner</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin0.make_rdm1">
<code class="sig-prename descclassname">pyscf.fci.direct_spin0.</code><code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-traced one-particle density matrix</p>
<p>dm1[p,q] = &lt;q_alpha^dagger p_alpha&gt; + &lt;q_beta^dagger p_beta&gt;</p>
<p>The convention is based on McWeeney’s book, Eq (5.4.20)
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(‘pq,qp’, h1, rdm1)</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin0.make_rdm12">
<code class="sig-prename descclassname">pyscf.fci.direct_spin0.</code><code class="sig-name descname">make_rdm12</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#make_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.make_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced 1- and 2-particle density matrices.</p>
<dl class="simple">
<dt>1pdm[p,q] = :math:<a href="#id19"><span class="problematic" id="id20">`</span></a>langle <a href="#id171"><span class="problematic" id="id172">q_</span></a>alpha^dagger <a href="#id173"><span class="problematic" id="id174">p_</span></a>alpha rangle +</dt><dd><p>langle <a href="#id175"><span class="problematic" id="id176">q_</span></a>beta^dagger  <a href="#id177"><span class="problematic" id="id178">p_</span></a>beta rangle`;</p>
</dd>
<dt>2pdm[p,q,r,s] = :math:<a href="#id21"><span class="problematic" id="id22">`</span></a>langle <a href="#id179"><span class="problematic" id="id180">p_</span></a>alpha^dagger <a href="#id181"><span class="problematic" id="id182">r_</span></a>alpha^dagger <a href="#id183"><span class="problematic" id="id184">s_</span></a>alpha <a href="#id185"><span class="problematic" id="id186">q_</span></a>alpharangle +</dt><dd><p>langle <a href="#id187"><span class="problematic" id="id188">p_</span></a>beta^dagger  <a href="#id189"><span class="problematic" id="id190">r_</span></a>alpha^dagger <a href="#id191"><span class="problematic" id="id192">s_</span></a>alpha <a href="#id193"><span class="problematic" id="id194">q_</span></a>betarangle +
langle <a href="#id195"><span class="problematic" id="id196">p_</span></a>alpha^dagger <a href="#id197"><span class="problematic" id="id198">r_</span></a>beta^dagger  <a href="#id199"><span class="problematic" id="id200">s_</span></a>beta  <a href="#id201"><span class="problematic" id="id202">q_</span></a>alpharangle +
langle <a href="#id203"><span class="problematic" id="id204">p_</span></a>beta^dagger  <a href="#id205"><span class="problematic" id="id206">r_</span></a>beta^dagger  <a href="#id207"><span class="problematic" id="id208">s_</span></a>beta  <a href="#id209"><span class="problematic" id="id210">q_</span></a>betarangle`.</p>
</dd>
</dl>
<p>Energy should be computed as
E = einsum(‘pq,qp’, h1, 1pdm) + 1/2 * einsum(‘pqrs,pqrs’, eri, 2pdm)
where h1[p,q] = &lt;p|h|q&gt; and eri[p,q,r,s] = (pq|rs)</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin0.make_rdm1s">
<code class="sig-prename descclassname">pyscf.fci.direct_spin0.</code><code class="sig-name descname">make_rdm1s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#make_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.make_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta)</p>
<p>dm1[p,q] = &lt;q^dagger p&gt;</p>
<p>The convention is based on McWeeney’s book, Eq (5.4.20).
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(‘pq,qp’, h1, rdm1)</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin0.trans_rdm1">
<code class="sig-prename descclassname">pyscf.fci.direct_spin0.</code><code class="sig-name descname">trans_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#trans_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.trans_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1-particle transition density matrices.</p>
<dl class="simple">
<dt>1pdm[p,q] = :math:<a href="#id23"><span class="problematic" id="id24">`</span></a>langle <a href="#id211"><span class="problematic" id="id212">q_</span></a>alpha^dagger <a href="#id213"><span class="problematic" id="id214">p_</span></a>alpha rangle</dt><dd><ul class="simple">
<li><p>langle <a href="#id215"><span class="problematic" id="id216">q_</span></a>beta^dagger <a href="#id217"><span class="problematic" id="id218">p_</span></a>beta rangle`</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin0.trans_rdm12">
<code class="sig-prename descclassname">pyscf.fci.direct_spin0.</code><code class="sig-name descname">trans_rdm12</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reorder</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#trans_rdm12"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.trans_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1- and 2-particle transition density matrices.</p>
<p>1pdm[p,q] = <span class="math notranslate nohighlight">\(\langle q^\dagger p\rangle\)</span>;
2pdm[p,q,r,s] = <span class="math notranslate nohighlight">\(\langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.direct_spin0.trans_rdm1s">
<code class="sig-prename descclassname">pyscf.fci.direct_spin0.</code><code class="sig-name descname">trans_rdm1s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0/#trans_rdm1s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0.trans_rdm1s" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin separated transition 1-particle density matrices.
The return values include two density matrices: (alpha,alpha), (beta,beta).
See also function <a class="reference internal" href="../../pyscf_api_docs/pyscf.fci/#pyscf.fci.direct_spin0.make_rdm1s" title="pyscf.fci.direct_spin0.make_rdm1s"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_rdm1s()</span></code></a></p>
<p>1pdm[p,q] = <span class="math notranslate nohighlight">\(\langle q^\dagger p \rangle\)</span></p>
</dd></dl>

<hr class="docutils" />
<span class="target" id="module-pyscf.fci.direct_spin0_symm"></span><dl class="simple">
<dt>Different FCI solvers are implemented to support different type of symmetry.</dt><dd><p>Symmetry</p>
</dd>
</dl>
<p>File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
direct_spin0_symm   Yes           Yes            Yes                Yes
direct_spin1_symm   Yes           No             Yes                Yes
direct_spin0        No            Yes            Yes                Yes
direct_spin1        No            No             Yes                Yes
direct_uhf          No            No             Yes                No
direct_nosym        No            No             No**               Yes</p>
<ul class="simple">
<li><p>Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)</p></li>
</ul>
<p>** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) …</p>
<dl class="py attribute">
<dt id="pyscf.fci.direct_spin0_symm.FCI">
<code class="sig-prename descclassname">pyscf.fci.direct_spin0_symm.</code><code class="sig-name descname">FCI</code><a class="headerlink" href="#pyscf.fci.direct_spin0_symm.FCI" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="../../pyscf_api_docs/pyscf.fci/#pyscf.fci.direct_spin0_symm.FCISolver" title="pyscf.fci.direct_spin0_symm.FCISolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.fci.direct_spin0_symm.FCISolver</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="pyscf.fci.direct_spin0_symm.FCISolver">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.fci.direct_spin0_symm.</code><code class="sig-name descname">FCISolver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0_symm/#FCISolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0_symm.FCISolver" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="pyscf.fci.direct_spin0_symm.FCISolver.absorb_h1e">
<code class="sig-name descname">absorb_h1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">fac</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0_symm/#FCISolver.absorb_h1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0_symm.FCISolver.absorb_h1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify 2e Hamiltonian to include 1e Hamiltonian contribution.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0_symm.FCISolver.contract_1e">
<code class="sig-name descname">contract_1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f1e</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0_symm/#FCISolver.contract_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0_symm.FCISolver.contract_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 1-electron Hamiltonian with a FCI vector to get a new FCI
vector.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0_symm.FCISolver.contract_2e">
<code class="sig-name descname">contract_2e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">orbsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wfnsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0_symm/#FCISolver.contract_2e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0_symm.FCISolver.contract_2e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 4-index tensor eri[pqrs] with a FCI vector</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}|output\rangle = E_{pq} E_{rs} eri_{pq,rs} |CI\rangle \\\end{split}\\\begin{split}E_{pq}E_{rs} = E_{pr,qs} + \delta_{qr} E_{ps} \\\end{split}\\E_{pq} = p^+ q + \bar{p}^+ \bar{q}\\E_{pr,qs} = p^+ r^+ s q + \bar{p}^+ r^+ s \bar{q} + ...\end{aligned}\end{align} \]</div>
<p><span class="math notranslate nohighlight">\(p,q,...\)</span> means spin-up orbitals and <span class="math notranslate nohighlight">\(\bar{p}, \bar{q}\)</span> means
spin-down orbitals.</p>
<p>Note the input argument eri is NOT the 2e hamiltonian tensor. 2e hamiltonian is</p>
<div class="math notranslate nohighlight">
\[\begin{split}h2e &amp;= (pq|rs) E_{pr,qs} \\
    &amp;= (pq|rs) (E_{pq}E_{rs} - \delta_{qr} E_{ps}) \\
    &amp;= eri_{pq,rs} E_{pq}E_{rs} \\\end{split}\]</div>
<p>So the relation between eri and hamiltonian (the 2e-integral tensor) is</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (1/Nelec) \sum_q (pq|qs)\]</div>
<p>to restore the symmetry between pq and rs,</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (.5/Nelec) [\sum_q (pq|qs) + \sum_p (pq|rp)]\]</div>
<p>See also <code class="xref py py-func docutils literal notranslate"><span class="pre">direct_spin1.absorb_h1e()</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0_symm.FCISolver.get_init_guess">
<code class="sig-name descname">get_init_guess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">nroots</span></em>, <em class="sig-param"><span class="n">hdiag</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0_symm/#FCISolver.get_init_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0_symm.FCISolver.get_init_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial guess is the single Slater determinant</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0_symm.FCISolver.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">ci0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">lindep</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_cycle</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_space</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nroots</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">davidson_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pspace_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">orbsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">wfnsym</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ecore</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0_symm/#FCISolver.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0_symm.FCISolver.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel function is the main driver of a method.  Every method should
define the kernel function as the entry of the calculation.  Note the
return value of kernel function is not strictly defined.  It can be
anything related to the method (such as the energy, the wave-function,
the DFT mesh grids etc.).</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0_symm.FCISolver.make_hdiag">
<code class="sig-name descname">make_hdiag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0_symm/#FCISolver.make_hdiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0_symm.FCISolver.make_hdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagonal Hamiltonian for Davidson preconditioner</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_spin0_symm.FCISolver.pspace">
<code class="sig-name descname">pspace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">hdiag</span></em>, <em class="sig-param"><span class="n">np</span><span class="o">=</span><span class="default_value">400</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_spin0_symm/#FCISolver.pspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_spin0_symm.FCISolver.pspace" title="Permalink to this definition">¶</a></dt>
<dd><p>pspace Hamiltonian to improve Davidson preconditioner. See, CPL, 169, 463</p>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<span class="target" id="module-pyscf.fci.direct_uhf"></span><dl class="simple">
<dt>Different FCI solvers are implemented to support different type of symmetry.</dt><dd><p>Symmetry</p>
</dd>
</dl>
<p>File                Point group   Spin singlet   Real hermitian*    Alpha/beta degeneracy
direct_spin0_symm   Yes           Yes            Yes                Yes
direct_spin1_symm   Yes           No             Yes                Yes
direct_spin0        No            Yes            Yes                Yes
direct_spin1        No            No             Yes                Yes
direct_uhf          No            No             Yes                No
direct_nosym        No            No             No**               Yes</p>
<ul class="simple">
<li><p>Real hermitian Hamiltonian implies (ij|kl) = (ji|kl) = (ij|lk) = (ji|lk)</p></li>
</ul>
<p>** Hamiltonian is real but not hermitian, (ij|kl) != (ji|kl) …</p>
<dl class="py attribute">
<dt id="pyscf.fci.direct_uhf.FCI">
<code class="sig-prename descclassname">pyscf.fci.direct_uhf.</code><code class="sig-name descname">FCI</code><a class="headerlink" href="#pyscf.fci.direct_uhf.FCI" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="../../pyscf_api_docs/pyscf.fci/#pyscf.fci.direct_uhf.FCISolver" title="pyscf.fci.direct_uhf.FCISolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.fci.direct_uhf.FCISolver</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="pyscf.fci.direct_uhf.FCISolver">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.fci.direct_uhf.</code><code class="sig-name descname">FCISolver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_uhf/#FCISolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_uhf.FCISolver" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="pyscf.fci.direct_uhf.FCISolver.absorb_h1e">
<code class="sig-name descname">absorb_h1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">fac</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_uhf/#FCISolver.absorb_h1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_uhf.FCISolver.absorb_h1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify 2e Hamiltonian to include 1e Hamiltonian contribution.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_uhf.FCISolver.contract_1e">
<code class="sig-name descname">contract_1e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f1e</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_uhf/#FCISolver.contract_1e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_uhf.FCISolver.contract_1e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 1-electron Hamiltonian with a FCI vector to get a new FCI
vector.</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_uhf.FCISolver.contract_2e">
<code class="sig-name descname">contract_2e</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_uhf/#FCISolver.contract_2e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_uhf.FCISolver.contract_2e" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract the 4-index tensor eri[pqrs] with a FCI vector</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}|output\rangle = E_{pq} E_{rs} eri_{pq,rs} |CI\rangle \\\end{split}\\\begin{split}E_{pq}E_{rs} = E_{pr,qs} + \delta_{qr} E_{ps} \\\end{split}\\E_{pq} = p^+ q + \bar{p}^+ \bar{q}\\E_{pr,qs} = p^+ r^+ s q + \bar{p}^+ r^+ s \bar{q} + ...\end{aligned}\end{align} \]</div>
<p><span class="math notranslate nohighlight">\(p,q,...\)</span> means spin-up orbitals and <span class="math notranslate nohighlight">\(\bar{p}, \bar{q}\)</span> means
spin-down orbitals.</p>
<p>Note the input argument eri is NOT the 2e hamiltonian tensor. 2e hamiltonian is</p>
<div class="math notranslate nohighlight">
\[\begin{split}h2e &amp;= (pq|rs) E_{pr,qs} \\
    &amp;= (pq|rs) (E_{pq}E_{rs} - \delta_{qr} E_{ps}) \\
    &amp;= eri_{pq,rs} E_{pq}E_{rs} \\\end{split}\]</div>
<p>So the relation between eri and hamiltonian (the 2e-integral tensor) is</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (1/Nelec) \sum_q (pq|qs)\]</div>
<p>to restore the symmetry between pq and rs,</p>
<div class="math notranslate nohighlight">
\[eri_{pq,rs} = (pq|rs) - (.5/Nelec) [\sum_q (pq|qs) + \sum_p (pq|rp)]\]</div>
<p>See also <code class="xref py py-func docutils literal notranslate"><span class="pre">direct_spin1.absorb_h1e()</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_uhf.FCISolver.make_hdiag">
<code class="sig-name descname">make_hdiag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_uhf/#FCISolver.make_hdiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_uhf.FCISolver.make_hdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagonal Hamiltonian for Davidson preconditioner</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_uhf.FCISolver.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_uhf/#FCISolver.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_uhf.FCISolver.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-traced one-particle density matrix</p>
<p>dm1[p,q] = &lt;q_alpha^dagger p_alpha&gt; + &lt;q_beta^dagger p_beta&gt;</p>
<p>The convention is based on McWeeney’s book, Eq (5.4.20)
The contraction between 1-particle Hamiltonian and rdm1 is
E = einsum(‘pq,qp’, h1, rdm1)</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_uhf.FCISolver.pspace">
<code class="sig-name descname">pspace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h1e</span></em>, <em class="sig-param"><span class="n">eri</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">hdiag</span></em>, <em class="sig-param"><span class="n">np</span><span class="o">=</span><span class="default_value">400</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_uhf/#FCISolver.pspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_uhf.FCISolver.pspace" title="Permalink to this definition">¶</a></dt>
<dd><p>pspace Hamiltonian to improve Davidson preconditioner. See, CPL, 169, 463</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_uhf.FCISolver.spin_square">
<code class="sig-name descname">spin_square</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_uhf/#FCISolver.spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_uhf.FCISolver.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square for RHF-FCI CI wfn only (obtained from spin-degenerated
Hamiltonian)</p>
</dd></dl>

<dl class="py method">
<dt id="pyscf.fci.direct_uhf.FCISolver.trans_rdm1">
<code class="sig-name descname">trans_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">link_index</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/direct_uhf/#FCISolver.trans_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.direct_uhf.FCISolver.trans_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced transition 1-particle transition density matrices.</p>
<dl class="simple">
<dt>1pdm[p,q] = :math:<a href="#id25"><span class="problematic" id="id26">`</span></a>langle <a href="#id219"><span class="problematic" id="id220">q_</span></a>alpha^dagger <a href="#id221"><span class="problematic" id="id222">p_</span></a>alpha rangle</dt><dd><ul class="simple">
<li><p>langle <a href="#id223"><span class="problematic" id="id224">q_</span></a>beta^dagger <a href="#id225"><span class="problematic" id="id226">p_</span></a>beta rangle`</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pyscf.fci.cistring">
<span id="cistring"></span><h3>cistring<a class="headerlink" href="#module-pyscf.fci.cistring" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="pyscf.fci.cistring.OIndexList">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">OIndexList</code><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#OIndexList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.OIndexList" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.addr2str">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">addr2str</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">addr</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#addr2str"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.addr2str" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert CI determinant address to string</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.addrs2str">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">addrs2str</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">addrs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#addrs2str"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.addrs2str" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of CI determinant address to string</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.gen_cre_str_index">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">gen_cre_str_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orb_list</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#gen_cre_str_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_cre_str_index" title="Permalink to this definition">¶</a></dt>
<dd><p>linkstr_index to map between N electron string to N+1 electron string.
It maps the given string to the address of the string which is generated by
the creation operator.</p>
<p>For given string str0, index[str0] is nvir x 4 array.  Each entry
[i(cre),–,str1,sign] means starting from str0, creating i, to get str1.</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.gen_cre_str_index_o0">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">gen_cre_str_index_o0</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orb_list</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#gen_cre_str_index_o0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_cre_str_index_o0" title="Permalink to this definition">¶</a></dt>
<dd><p>Slow version of gen_cre_str_index function</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.gen_cre_str_index_o1">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">gen_cre_str_index_o1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orb_list</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#gen_cre_str_index_o1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_cre_str_index_o1" title="Permalink to this definition">¶</a></dt>
<dd><p>C implementation of gen_cre_str_index function</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.gen_des_str_index">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">gen_des_str_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orb_list</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#gen_des_str_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_des_str_index" title="Permalink to this definition">¶</a></dt>
<dd><p>linkstr_index to map between N electron string to N-1 electron string.
It maps the given string to the address of the string which is generated by
the annihilation operator.</p>
<p>For given string str0, index[str0] is nvir x 4 array.  Each entry
[–,i(des),str1,sign] means starting from str0, annihilating i, to get str1.</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.gen_des_str_index_o0">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">gen_des_str_index_o0</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orb_list</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#gen_des_str_index_o0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_des_str_index_o0" title="Permalink to this definition">¶</a></dt>
<dd><p>Slow version of gen_des_str_index function</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.gen_des_str_index_o1">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">gen_des_str_index_o1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orb_list</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#gen_des_str_index_o1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_des_str_index_o1" title="Permalink to this definition">¶</a></dt>
<dd><p>C implementation of gen_des_str_index function</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.gen_linkstr_index">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">gen_linkstr_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orb_list</span></em>, <em class="sig-param"><span class="n">nocc</span></em>, <em class="sig-param"><span class="n">strs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tril</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#gen_linkstr_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_linkstr_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Look up table, for the strings relationship in terms of a
creation-annihilating operator pair.</p>
<p>For given string str0, index[str0] is (nocc+nocc*nvir) x 4 array.
The first nocc rows [i(:occ),i(:occ),str0,sign] are occupied-occupied
excitations, which do not change the string. The next nocc*nvir rows
[a(:vir),i(:occ),str1,sign] are occupied-virtual exciations, starting from
str0, annihilating i, creating a, to get str1.</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.gen_linkstr_index_trilidx">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">gen_linkstr_index_trilidx</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orb_list</span></em>, <em class="sig-param"><span class="n">nocc</span></em>, <em class="sig-param"><span class="n">strs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#gen_linkstr_index_trilidx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.gen_linkstr_index_trilidx" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate linkstr_index with the assumption that <span class="math notranslate nohighlight">\(p^+ q|0\rangle\)</span>
where <span class="math notranslate nohighlight">\(p &gt; q\)</span>.
So the resultant link_index has the structure <code class="docutils literal notranslate"><span class="pre">[pq,</span> <span class="pre">*,</span> <span class="pre">str1,</span> <span class="pre">sign]</span></code>.
It is identical to a call to <code class="docutils literal notranslate"><span class="pre">reform_linkstr_index(gen_linkstr_index(...))</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.gen_strings4orblist">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">gen_strings4orblist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orb_list</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.fci.cistring.gen_strings4orblist" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate string from the given orbital list.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>list of int64.  One int64 element represents one string in binary format.
The binary format takes the convention that the one bit stands for one
orbital, bit-1 means occupied and bit-0 means unoccupied.  The lowest
(right-most) bit corresponds to the lowest orbital in the orb_list.</p>
</dd>
</dl>
<p>Exampels:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">bin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">make_strings</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[0b11, 0b101, 0b110, 0b1001, 0b1010, 0b1100]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">bin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">make_strings</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[0b1010, 0b1001, 0b11, 0b1100, 0b110, 0b101]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.make_strings">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">make_strings</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">orb_list</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#make_strings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.make_strings" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate string from the given orbital list.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>list of int64.  One int64 element represents one string in binary format.
The binary format takes the convention that the one bit stands for one
orbital, bit-1 means occupied and bit-0 means unoccupied.  The lowest
(right-most) bit corresponds to the lowest orbital in the orb_list.</p>
</dd>
</dl>
<p>Exampels:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">bin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">make_strings</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[0b11, 0b101, 0b110, 0b1001, 0b1010, 0b1100]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">bin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">make_strings</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[0b1010, 0b1001, 0b11, 0b1100, 0b110, 0b101]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.reform_linkstr_index">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">reform_linkstr_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">link_index</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#reform_linkstr_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.reform_linkstr_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Compress the (a, i) pair index in linkstr_index to a lower triangular
index. The compressed indices can match the 4-fold symmetry of integrals.</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.str2addr">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">str2addr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">string</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#str2addr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.str2addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert string to CI determinant address</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.strs2addr">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">strs2addr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">strings</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#strs2addr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.strs2addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of string to CI determinant address</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.sub_addrs">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">sub_addrs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">orbital_indices</span></em>, <em class="sig-param"><span class="n">sub_nelec</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#sub_addrs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.sub_addrs" title="Permalink to this definition">¶</a></dt>
<dd><p>The addresses of the determinants which include the specified orbital
indices. The size of the returned addresses is equal to the number of
determinants of (norb, nelec) system.</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.cistring.tn_strs">
<code class="sig-prename descclassname">pyscf.fci.cistring.</code><code class="sig-name descname">tn_strs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/cistring/#tn_strs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.cistring.tn_strs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate strings for Tn amplitudes.  Eg n=1 (T1) has nvir*nocc strings,
n=2 (T2) has nvir*(nvir-1)/2 * nocc*(nocc-1)/2 strings.</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.fci.spin_op">
<span id="spin-operator"></span><h3>spin operator<a class="headerlink" href="#module-pyscf.fci.spin_op" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="pyscf.fci.spin_op.contract_ss">
<code class="sig-prename descclassname">pyscf.fci.spin_op.</code><code class="sig-name descname">contract_ss</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/spin_op/#contract_ss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.spin_op.contract_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract spin square operator with FCI wavefunction <span class="math notranslate nohighlight">\(S^2 |CI&gt;\)</span></p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.spin_op.local_spin">
<code class="sig-prename descclassname">pyscf.fci.spin_op.</code><code class="sig-name descname">local_spin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ovlp</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">aolst</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/spin_op/#local_spin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.spin_op.local_spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Local spin expectation value, which is defined as</p>
<p>&lt;CI|(local S^2)|CI&gt;</p>
<p>The local S^2 operator only couples the orbitals specified in aolst. The
cross term which involves the interaction between the local part (in aolst)
and non-local part (not in aolst) is not included. As a result, the value
of local_spin is not additive. In other words, if local_spin is computed
twice with the complementary aolst in the two runs, the summation does not
equal to the S^2 of the entire system.</p>
<p>For a complete list of AOs, the value of local_spin is equivalent to &lt;CI|S^2|CI&gt;</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.spin_op.spin_square">
<code class="sig-prename descclassname">pyscf.fci.spin_op.</code><code class="sig-name descname">spin_square</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ovlp</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/spin_op/#spin_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.spin_op.spin_square" title="Permalink to this definition">¶</a></dt>
<dd><p>General spin square operator.</p>
<p>… math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">CI</span><span class="o">|</span><span class="n">S_</span><span class="o">+*</span><span class="n">S_</span><span class="o">-|</span><span class="n">CI</span><span class="o">&gt;</span> <span class="o">&amp;=</span> <span class="n">n_</span>\<span class="n">alpha</span> <span class="o">+</span> \<span class="n">delta_</span><span class="p">{</span><span class="n">ik</span><span class="p">}</span>\<span class="n">delta_</span><span class="p">{</span><span class="n">jl</span><span class="p">}</span><span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">alpha</span> <span class="n">k</span>\<span class="n">beta</span> <span class="p">,</span><span class="n">j</span>\<span class="n">beta</span> <span class="n">l</span>\<span class="n">alpha</span> <span class="p">}</span> \\
<span class="o">&lt;</span><span class="n">CI</span><span class="o">|</span><span class="n">S_</span><span class="o">-*</span><span class="n">S_</span><span class="o">+|</span><span class="n">CI</span><span class="o">&gt;</span> <span class="o">&amp;=</span> <span class="n">n_</span>\<span class="n">beta</span> <span class="o">+</span> \<span class="n">delta_</span><span class="p">{</span><span class="n">ik</span><span class="p">}</span>\<span class="n">delta_</span><span class="p">{</span><span class="n">jl</span><span class="p">}</span><span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">beta</span> <span class="n">k</span>\<span class="n">alpha</span> <span class="p">,</span><span class="n">j</span>\<span class="n">alpha</span> <span class="n">l</span>\<span class="n">beta</span> <span class="p">}</span> \\
<span class="o">&lt;</span><span class="n">CI</span><span class="o">|</span><span class="n">S_z</span><span class="o">*</span><span class="n">S_z</span><span class="o">|</span><span class="n">CI</span><span class="o">&gt;</span> <span class="o">&amp;=</span> \<span class="n">delta_</span><span class="p">{</span><span class="n">ik</span><span class="p">}</span>\<span class="n">delta_</span><span class="p">{</span><span class="n">jl</span><span class="p">}(</span><span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">alpha</span> <span class="n">k</span>\<span class="n">alpha</span> <span class="p">,</span><span class="n">j</span>\<span class="n">alpha</span> <span class="n">l</span>\<span class="n">alpha</span> <span class="p">}</span>
                 <span class="o">-</span> <span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">alpha</span> <span class="n">k</span>\<span class="n">alpha</span> <span class="p">,</span><span class="n">j</span>\<span class="n">beta</span> <span class="n">l</span>\<span class="n">beta</span> <span class="p">}</span>
                 <span class="o">-</span> <span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">beta</span> <span class="n">k</span>\<span class="n">beta</span> <span class="p">,</span><span class="n">j</span>\<span class="n">alpha</span> <span class="n">l</span>\<span class="n">alpha</span><span class="p">}</span>
                 <span class="o">+</span> <span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">beta</span> <span class="n">k</span>\<span class="n">beta</span> <span class="p">,</span><span class="n">j</span>\<span class="n">beta</span> <span class="n">l</span>\<span class="n">beta</span><span class="p">})</span>
                 <span class="o">+</span> <span class="p">(</span><span class="n">n_</span>\<span class="n">alpha</span><span class="o">+</span><span class="n">n_</span>\<span class="n">beta</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span>
</pre></div>
</div>
<p>Given the overlap betwen non-degenerate alpha and beta orbitals, this
function can compute the expectation value spin square operator for
UHF-FCI wavefunction</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.spin_op.spin_square0">
<code class="sig-prename descclassname">pyscf.fci.spin_op.</code><code class="sig-name descname">spin_square0</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fcivec</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/spin_op/#spin_square0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.spin_op.spin_square0" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin square for RHF-FCI CI wfn only (obtained from spin-degenerated
Hamiltonian)</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.spin_op.spin_square_general">
<code class="sig-prename descclassname">pyscf.fci.spin_op.</code><code class="sig-name descname">spin_square_general</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dm1a</span></em>, <em class="sig-param"><span class="n">dm1b</span></em>, <em class="sig-param"><span class="n">dm2aa</span></em>, <em class="sig-param"><span class="n">dm2ab</span></em>, <em class="sig-param"><span class="n">dm2bb</span></em>, <em class="sig-param"><span class="n">mo_coeff</span></em>, <em class="sig-param"><span class="n">ovlp</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/spin_op/#spin_square_general"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.spin_op.spin_square_general" title="Permalink to this definition">¶</a></dt>
<dd><p>General spin square operator.</p>
<p>… math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">CI</span><span class="o">|</span><span class="n">S_</span><span class="o">+*</span><span class="n">S_</span><span class="o">-|</span><span class="n">CI</span><span class="o">&gt;</span> <span class="o">&amp;=</span> <span class="n">n_</span>\<span class="n">alpha</span> <span class="o">+</span> \<span class="n">delta_</span><span class="p">{</span><span class="n">ik</span><span class="p">}</span>\<span class="n">delta_</span><span class="p">{</span><span class="n">jl</span><span class="p">}</span><span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">alpha</span> <span class="n">k</span>\<span class="n">beta</span> <span class="p">,</span><span class="n">j</span>\<span class="n">beta</span> <span class="n">l</span>\<span class="n">alpha</span> <span class="p">}</span> \\
<span class="o">&lt;</span><span class="n">CI</span><span class="o">|</span><span class="n">S_</span><span class="o">-*</span><span class="n">S_</span><span class="o">+|</span><span class="n">CI</span><span class="o">&gt;</span> <span class="o">&amp;=</span> <span class="n">n_</span>\<span class="n">beta</span> <span class="o">+</span> \<span class="n">delta_</span><span class="p">{</span><span class="n">ik</span><span class="p">}</span>\<span class="n">delta_</span><span class="p">{</span><span class="n">jl</span><span class="p">}</span><span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">beta</span> <span class="n">k</span>\<span class="n">alpha</span> <span class="p">,</span><span class="n">j</span>\<span class="n">alpha</span> <span class="n">l</span>\<span class="n">beta</span> <span class="p">}</span> \\
<span class="o">&lt;</span><span class="n">CI</span><span class="o">|</span><span class="n">S_z</span><span class="o">*</span><span class="n">S_z</span><span class="o">|</span><span class="n">CI</span><span class="o">&gt;</span> <span class="o">&amp;=</span> \<span class="n">delta_</span><span class="p">{</span><span class="n">ik</span><span class="p">}</span>\<span class="n">delta_</span><span class="p">{</span><span class="n">jl</span><span class="p">}(</span><span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">alpha</span> <span class="n">k</span>\<span class="n">alpha</span> <span class="p">,</span><span class="n">j</span>\<span class="n">alpha</span> <span class="n">l</span>\<span class="n">alpha</span> <span class="p">}</span>
                 <span class="o">-</span> <span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">alpha</span> <span class="n">k</span>\<span class="n">alpha</span> <span class="p">,</span><span class="n">j</span>\<span class="n">beta</span> <span class="n">l</span>\<span class="n">beta</span> <span class="p">}</span>
                 <span class="o">-</span> <span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">beta</span> <span class="n">k</span>\<span class="n">beta</span> <span class="p">,</span><span class="n">j</span>\<span class="n">alpha</span> <span class="n">l</span>\<span class="n">alpha</span><span class="p">}</span>
                 <span class="o">+</span> <span class="n">Gamma_</span><span class="p">{</span><span class="n">i</span>\<span class="n">beta</span> <span class="n">k</span>\<span class="n">beta</span> <span class="p">,</span><span class="n">j</span>\<span class="n">beta</span> <span class="n">l</span>\<span class="n">beta</span><span class="p">})</span>
                 <span class="o">+</span> <span class="p">(</span><span class="n">n_</span>\<span class="n">alpha</span><span class="o">+</span><span class="n">n_</span>\<span class="n">beta</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span>
</pre></div>
</div>
<p>Given the overlap betwen non-degenerate alpha and beta orbitals, this
function can compute the expectation value spin square operator for
UHF-FCI wavefunction</p>
</dd></dl>

</div>
<div class="section" id="module-pyscf.fci.rdm">
<span id="rdm"></span><h3>rdm<a class="headerlink" href="#module-pyscf.fci.rdm" title="Permalink to this headline">¶</a></h3>
<p>FCI 1, 2, 3, 4-particle density matrices.</p>
<p>Note the 1-particle density matrix has the same convention as the mean-field
1-particle density matrix (see McWeeney’s book Eq 5.4.20), which is</p>
<blockquote>
<div><p>dm[p,q] = &lt; q^+ p &gt;</p>
</div></blockquote>
<dl class="simple">
<dt>The contraction between 1-particle Hamiltonian and 1-pdm is</dt><dd><p>E = einsum(‘pq,qp’, h1, 1pdm)</p>
</dd>
<dt>Different conventions are used in the high order density matrices:</dt><dd><p>dm[p,q,r,s,…] = &lt; p^+ r^+ … s q &gt;</p>
</dd>
</dl>
<dl class="py function">
<dt id="pyscf.fci.rdm.make_dm123">
<code class="sig-prename descclassname">pyscf.fci.rdm.</code><code class="sig-name descname">make_dm123</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fname</span></em>, <em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/rdm/#make_dm123"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.rdm.make_dm123" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced 1, 2 and 3-particle density matrices.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this function, 2pdm[p,q,r,s] is <span class="math notranslate nohighlight">\(\langle p^\dagger q r^\dagger s\rangle\)</span>;
3pdm[p,q,r,s,t,u] is <span class="math notranslate nohighlight">\(\langle p^\dagger q r^\dagger s t^\dagger u\rangle\)</span>.</p>
<p>After calling reorder_dm123, the 2pdm and 3pdm are transformed to
the normal density matrices:
2pdm[p,r,q,s] = <span class="math notranslate nohighlight">\(\langle p^\dagger q^\dagger s r\rangle\)</span>
3pdm[p,s,q,t,r,u] = <span class="math notranslate nohighlight">\(\langle p^\dagger q^\dagger r^\dagger u t s\rangle\)</span>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.rdm.make_dm1234">
<code class="sig-prename descclassname">pyscf.fci.rdm.</code><code class="sig-name descname">make_dm1234</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fname</span></em>, <em class="sig-param"><span class="n">cibra</span></em>, <em class="sig-param"><span class="n">ciket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/rdm/#make_dm1234"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.rdm.make_dm1234" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin traced 1, 2, 3 and 4-particle density matrices.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this function, 2pdm[p,q,r,s] is <span class="math notranslate nohighlight">\(\langle p^\dagger q r^\dagger s\rangle\)</span>;
3pdm[p,q,r,s,t,u] is <span class="math notranslate nohighlight">\(\langle p^\dagger q r^\dagger s t^\dagger u\rangle\)</span>;
4pdm[p,q,r,s,t,u,v,w] is <span class="math notranslate nohighlight">\(\langle p^\dagger q r^\dagger s t^\dagger u v^\dagger w\rangle\)</span>.</p>
<p>After calling reorder_dm123, the 2pdm and 3pdm are transformed to
the normal density matrices:
2pdm[p,r,q,s] = <span class="math notranslate nohighlight">\(\langle p^\dagger q^\dagger s r\rangle\)</span>
3pdm[p,s,q,t,r,u] = <span class="math notranslate nohighlight">\(\langle p^\dagger q^\dagger r^\dagger u t s\rangle\)</span>.
4pdm[p,t,q,u,r,v,s,w] = <span class="math notranslate nohighlight">\(\langle p^\dagger q^\dagger r^\dagger s^dagger w v u t\rangle\)</span>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-pyscf.fci.addons">
<span id="addons"></span><h3>addons<a class="headerlink" href="#module-pyscf.fci.addons" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="pyscf.fci.addons.cre_a">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">cre_a</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ci0</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">neleca_nelecb</span></em>, <em class="sig-param"><span class="n">ap_id</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#cre_a"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.cre_a" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct (N+1)-electron wavefunction by adding an alpha electron in
the N-electron wavefunction.</p>
<p>… math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span>\<span class="n">rangle</span> <span class="o">=</span> \<span class="n">hat</span><span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="o">^+</span><span class="n">_p</span> <span class="o">|</span><span class="n">N</span>\<span class="n">rangle</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>ci0<span class="classifier">2D array</span></dt><dd><p>CI coefficients, row for alpha strings and column for beta strings.</p>
</dd>
<dt>norb<span class="classifier">int</span></dt><dd><p>Number of orbitals.</p>
</dd>
<dt>(neleca,nelecb)<span class="classifier">(int,int)</span></dt><dd><p>Number of (alpha, beta) electrons of the input CI function</p>
</dd>
<dt>ap_id<span class="classifier">int</span></dt><dd><p>Orbital index (0-based), for the creation operator</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>2D array, row for alpha strings and column for beta strings. Note it
has different number of rows to the input CI coefficients.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.cre_b">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">cre_b</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ci0</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">neleca_nelecb</span></em>, <em class="sig-param"><span class="n">ap_id</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#cre_b"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.cre_b" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct (N+1)-electron wavefunction by adding a beta electron in
the N-electron wavefunction.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>ci0<span class="classifier">2D array</span></dt><dd><p>CI coefficients, row for alpha strings and column for beta strings.</p>
</dd>
<dt>norb<span class="classifier">int</span></dt><dd><p>Number of orbitals.</p>
</dd>
<dt>(neleca,nelecb)<span class="classifier">(int,int)</span></dt><dd><p>Number of (alpha, beta) electrons of the input CI function</p>
</dd>
<dt>ap_id<span class="classifier">int</span></dt><dd><p>Orbital index (0-based), for the creation operator</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>2D array, row for alpha strings and column for beta strings. Note it
has different number of columns to the input CI coefficients.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.cylindrical_init_guess">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">cylindrical_init_guess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mol</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">orbsym</span></em>, <em class="sig-param"><span class="n">wfnsym</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">singlet</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">nroots</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#cylindrical_init_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.cylindrical_init_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>FCI initial guess for system of cylindrical symmetry.
(In testing)</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O; O 1 1.2&#39;</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orbsym</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ci0</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">cylindrical_init_guess</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">orbsym</span><span class="p">,</span> <span class="n">wfnsym</span><span class="o">=</span><span class="mi">10</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ci0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ci0</span> <span class="o">=</span> <span class="n">fci</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">cylindrical_init_guess</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">orbsym</span><span class="p">,</span> <span class="n">wfnsym</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">singlet</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ci0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.des_a">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">des_a</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ci0</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">neleca_nelecb</span></em>, <em class="sig-param"><span class="n">ap_id</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#des_a"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.des_a" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct (N-1)-electron wavefunction by removing an alpha electron from
the N-electron wavefunction.</p>
<p>… math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span>\<span class="n">rangle</span> <span class="o">=</span> \<span class="n">hat</span><span class="p">{</span><span class="n">a</span><span class="p">}</span><span class="n">_p</span> <span class="o">|</span><span class="n">N</span>\<span class="n">rangle</span>
</pre></div>
</div>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>ci0<span class="classifier">2D array</span></dt><dd><p>CI coefficients, row for alpha strings and column for beta strings.</p>
</dd>
<dt>norb<span class="classifier">int</span></dt><dd><p>Number of orbitals.</p>
</dd>
<dt>(neleca,nelecb)<span class="classifier">(int,int)</span></dt><dd><p>Number of (alpha, beta) electrons of the input CI function</p>
</dd>
<dt>ap_id<span class="classifier">int</span></dt><dd><p>Orbital index (0-based), for the annihilation operator</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>2D array, row for alpha strings and column for beta strings.  Note it
has different number of rows to the input CI coefficients</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.des_b">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">des_b</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ci0</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">neleca_nelecb</span></em>, <em class="sig-param"><span class="n">ap_id</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#des_b"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.des_b" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct (N-1)-electron wavefunction by removing a beta electron from
N-electron wavefunction.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>ci0<span class="classifier">2D array</span></dt><dd><p>CI coefficients, row for alpha strings and column for beta strings.</p>
</dd>
<dt>norb<span class="classifier">int</span></dt><dd><p>Number of orbitals.</p>
</dd>
<dt>(neleca,nelecb)<span class="classifier">(int,int)</span></dt><dd><p>Number of (alpha, beta) electrons of the input CI function</p>
</dd>
<dt>ap_id<span class="classifier">int</span></dt><dd><p>Orbital index (0-based), for the annihilation operator</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>2D array, row for alpha strings and column for beta strings. Note it
has different number of columns to the input CI coefficients.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.det_overlap">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">det_overlap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">string1</span></em>, <em class="sig-param"><span class="n">string2</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#det_overlap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.det_overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Determinants overlap on non-orthogonal one-particle basis</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.fix_spin_">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">fix_spin_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fciobj</span></em>, <em class="sig-param"><span class="n">shift</span><span class="o">=</span><span class="default_value">0.2</span></em>, <em class="sig-param"><span class="n">ss</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#fix_spin_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.fix_spin_" title="Permalink to this definition">¶</a></dt>
<dd><p>If FCI solver cannot stay on spin eigenfunction, this function can
add a shift to the states which have wrong spin.</p>
<div class="math notranslate nohighlight">
\[(H + shift*S^2) |\Psi\rangle = E |\Psi\rangle\]</div>
<dl class="simple">
<dt>Args:</dt><dd><p>fciobj : An instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">FCISolver</span></code></p>
</dd>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shift<span class="classifier">float</span></dt><dd><p>Level shift for states which have different spin</p>
</dd>
<dt>ss<span class="classifier">number</span></dt><dd><p>S^2 expection value == s*(s+1)</p>
</dd>
</dl>
</dd>
<dt>Returns</dt><dd><p>A modified FCI object based on fciobj.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.guess_wfnsym">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">guess_wfnsym</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ci</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">orbsym</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#guess_wfnsym"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.guess_wfnsym" title="Permalink to this definition">¶</a></dt>
<dd><p>Guess the wavefunction symmetry based on the non-zero elements in the
given CI coefficients.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>ci<span class="classifier">2D array</span></dt><dd><p>CI coefficients, row for alpha strings and column for beta strings.</p>
</dd>
<dt>norb<span class="classifier">int</span></dt><dd><p>Number of orbitals.</p>
</dd>
<dt>nelec<span class="classifier">int or 2-item list</span></dt><dd><p>Number of electrons, or 2-item list for (alpha, beta) electrons</p>
</dd>
<dt>orbsym<span class="classifier">list of int</span></dt><dd><p>The irrep ID for each orbital.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Irrep ID</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.initguess_triplet">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">initguess_triplet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">binstring</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#initguess_triplet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.initguess_triplet" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a triplet initial guess for FCI solver</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.large_ci">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">large_ci</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ci</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">return_strs</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#large_ci"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.large_ci" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for the largest CI coefficients</p>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.overlap">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">overlap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bra</span></em>, <em class="sig-param"><span class="n">ket</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#overlap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlap between two CI wavefunctions</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>s<span class="classifier">2D array or a list of 2D array</span></dt><dd><p>The overlap matrix of non-orthogonal one-particle basis</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.symm_initguess">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">symm_initguess</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">orbsym</span></em>, <em class="sig-param"><span class="n">wfnsym</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">irrep_nelec</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#symm_initguess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.symm_initguess" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate CI wavefunction initial guess which has the given symmetry.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>norb<span class="classifier">int</span></dt><dd><p>Number of orbitals.</p>
</dd>
<dt>nelec<span class="classifier">int or 2-item list</span></dt><dd><p>Number of electrons, or 2-item list for (alpha, beta) electrons</p>
</dd>
<dt>orbsym<span class="classifier">list of int</span></dt><dd><p>The irrep ID for each orbital.</p>
</dd>
</dl>
</dd>
<dt>Kwags:</dt><dd><dl class="simple">
<dt>wfnsym<span class="classifier">int</span></dt><dd><p>The irrep ID of target symmetry</p>
</dd>
<dt>irrep_nelec<span class="classifier">dict</span></dt><dd><p>Freeze occupancy for certain irreps</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>CI coefficients 2D array which has the target symmetry.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.symmetrize_wfn">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">symmetrize_wfn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ci</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">orbsym</span></em>, <em class="sig-param"><span class="n">wfnsym</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#symmetrize_wfn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.symmetrize_wfn" title="Permalink to this definition">¶</a></dt>
<dd><p>Symmetrize the CI wavefunction by zeroing out the determinants which
do not have the right symmetry.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>ci<span class="classifier">2D array</span></dt><dd><p>CI coefficients, row for alpha strings and column for beta strings.</p>
</dd>
<dt>norb<span class="classifier">int</span></dt><dd><p>Number of orbitals.</p>
</dd>
<dt>nelec<span class="classifier">int or 2-item list</span></dt><dd><p>Number of electrons, or 2-item list for (alpha, beta) electrons</p>
</dd>
<dt>orbsym<span class="classifier">list of int</span></dt><dd><p>The irrep ID for each orbital.</p>
</dd>
</dl>
</dd>
<dt>Kwags:</dt><dd><dl class="simple">
<dt>wfnsym<span class="classifier">int</span></dt><dd><p>The irrep ID of target symmetry</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>2D array which is the symmetrized CI coefficients</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.transform_ci">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">transform_ci</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ci</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#transform_ci"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.transform_ci" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform CI coefficients to the representation in new one-particle basis.
Solving CI problem for Hamiltonian h1, h2 defined in old basis,
CI_old = fci.kernel(h1, h2, …)
Given orbital rotation u, the CI problem can be either solved by
transforming the Hamiltonian, or transforming the coefficients.
CI_new = fci.kernel(u^T*h1*u, …) = transform_ci_for_orbital_rotation(CI_old, u)</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>u<span class="classifier">2D array or a list of 2D array</span></dt><dd><p>the orbital rotation to transform the old one-particle basis to new
one-particle basis. If u is not a squared matrix, the resultant CI
coefficients array may have different shape to the input CI
coefficients.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pyscf.fci.addons.transform_ci_for_orbital_rotation">
<code class="sig-prename descclassname">pyscf.fci.addons.</code><code class="sig-name descname">transform_ci_for_orbital_rotation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ci</span></em>, <em class="sig-param"><span class="n">norb</span></em>, <em class="sig-param"><span class="n">nelec</span></em>, <em class="sig-param"><span class="n">u</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/pyscf/fci/addons/#transform_ci_for_orbital_rotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.fci.addons.transform_ci_for_orbital_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform CI coefficients (dimension conserved) to the representation in
new one-particle basis.  Solving CI problem for Hamiltonian h1, h2 defined
in old basis,
CI_old = fci.kernel(h1, h2, …)
Given orbital rotation u, the CI problem can be either solved by
transforming the Hamiltonian, or transforming the coefficients.
CI_new = fci.kernel(u^T*h1*u, …) = transform_ci_for_orbital_rotation(CI_old, u)</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>u<span class="classifier">a squared 2D array or a list of 2D array</span></dt><dd><p>the orbital rotation to transform the old one-particle basis to new
one-particle basis</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>

<div class="section">
   
</div>

          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2015-2021, The PySCF Developers.
              
          </div>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>