
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>cc — Coupled cluster &#8212; PySCF 2.0.0 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/material.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../_static/favicon-32x32.png"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=indigo data-md-color-accent=amber>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#modules/cc" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../index.html" title="PySCF 2.0.0 documentation"
           class="md-header-nav__button md-logo">
          
              <img src="../_static/pyscf-logo-white.svg" height="26"
                   alt="PySCF 2.0.0 documentation logo">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">PySCF 2.0</span>
          <span class="md-header-nav__topic"> cc — Coupled cluster </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/pyscf/pyscf/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    PySCF
  </div>
</a>
          </div>
        </div>
      
      
  
  <script src="../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../"versions.json"",
        target_loc = "../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
            
            <li class="md-tabs__item"><a href="../index.html" class="md-tabs__link">Home</a></li>
            
            <li class="md-tabs__item"><a href="../overview.html" class="md-tabs__link">Overview</a></li>
            
            <li class="md-tabs__item"><a href="../install.html" class="md-tabs__link">Install</a></li>
            
            <li class="md-tabs__item"><a href="../quickstart.html" class="md-tabs__link">Quickstart</a></li>
            
            <li class="md-tabs__item"><a href="../user.html" class="md-tabs__link">User Guide</a></li>
            
            <li class="md-tabs__item"><a href="../pyscf_api_docs/modules.html" class="md-tabs__link">API</a></li>
            
            <li class="md-tabs__item"><a href="../about.html" class="md-tabs__link">About</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../index.html" title="PySCF 2.0.0 documentation" class="md-nav__button md-logo">
      
        <img src="../_static/pyscf-logo-white.svg" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../index.html"
       title="PySCF 2.0.0 documentation">PySCF 2.0</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/pyscf/pyscf/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    PySCF
  </div>
</a>
    </div>
  
  

  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
    
      <a href="../overview.html" class="md-nav__link">Overview</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../install.html" class="md-nav__link">2. Install</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../quickstart.html" class="md-nav__link">Quickstart</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../user.html" class="md-nav__link">User Guide</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../pyscf_api_docs/pyscf.html" class="md-nav__link">5. API</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../interface.html" class="md-nav__link">6. Interface</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../about.html" class="md-nav__link">7. About</a>
      
    
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
    <label class="md-nav__title" for="__toc">Contents</label>
  <ul class="md-nav__list" data-md-scrollfix="">
        <li class="md-nav__item"><a href="#modules-cc--page-root" class="md-nav__link"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cc</span></code> — Coupled cluster</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#examples" class="md-nav__link">Examples</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#a-general-solver-for-customized-hamiltonian" class="md-nav__link">A general solver for customized Hamiltonian</a>
        </li>
        <li class="md-nav__item"><a href="#using-ccsd-as-casci-active-space-solver" class="md-nav__link">Using CCSD as CASCI active space solver</a>
        </li>
        <li class="md-nav__item"><a href="#gamma-point-ccsd-with-periodic-boundary-condition" class="md-nav__link">Gamma point CCSD with Periodic boundary condition</a>
        </li>
        <li class="md-nav__item"><a href="#ccsd-with-truncated-mos-to-avoid-linear-dependency" class="md-nav__link">CCSD with truncated MOs to avoid linear dependency</a>
        </li>
        <li class="md-nav__item"><a href="#response-and-un-relaxed-ccsd-density-matrix" class="md-nav__link">Response and un-relaxed CCSD density matrix</a>
        </li>
        <li class="md-nav__item"><a href="#reusing-integrals-in-ccsd-and-relevant-calculations" class="md-nav__link">Reusing integrals in CCSD and relevant calculations</a>
        </li>
        <li class="md-nav__item"><a href="#interfering-ccsd-diis" class="md-nav__link">Interfering CCSD-DIIS</a>
        </li>
        <li class="md-nav__item"><a href="#restart-ccsd" class="md-nav__link">Restart CCSD</a>
        </li></ul>
            </nav>
        </li>
        <li class="md-nav__item"><a href="#program-reference" class="md-nav__link">Program reference</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#cc-ccsd-module-and-ccsd-class" class="md-nav__link">cc.ccsd module and CCSD class</a>
        </li>
        <li class="md-nav__item"><a href="#cc-rccsd-and-rccsd-class" class="md-nav__link">cc.rccsd and RCCSD class</a>
        </li>
        <li class="md-nav__item"><a href="#cc-uccsd-and-uccsd-class" class="md-nav__link">cc.uccsd and UCCSD class</a>
        </li>
        <li class="md-nav__item"><a href="#cc-addons" class="md-nav__link">cc.addons</a>
        </li>
        <li class="md-nav__item"><a href="#ccsd-t" class="md-nav__link">CCSD(T)</a>
        </li>
        <li class="md-nav__item"><a href="#ccsd-gradients" class="md-nav__link">CCSD gradients</a>
        </li></ul>
            </nav>
        </li></ul>
            </nav>
        </li>
    
<li class="md-nav__item"><a class="md-nav__extra_link" href="../_sources/modules/cc.rst.txt">Show Source</a> </li>

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  
<span id="cc-coupled-cluster"></span><span id="cc"></span><h1 id="modules-cc--page-root"><a class="reference internal" href="#modules-cc--page-root" title="cc: Coupled cluster energies and properties"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cc</span></code></a> — Coupled cluster<a class="headerlink" href="#modules-cc--page-root" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="#module-cc" title="cc: Coupled cluster energies and properties"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cc</span></code></a> module implements the coupled cluster (CC) model to compute
energies, analytical nuclear gradients, density matrices, excited states, and
relevant properties.</p>
<p>To compute the CC energy, one first needs to perform a mean-field calculation using
the mean-field module <a class="reference internal" href="scf.html#module-scf" title="scf: restricted and unrestricted, closed shell and open shell Hartree-Fock methods"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scf</span></code></a>.  The mean-field object defines the Hamiltonian
and the problem size, which are used to initialize the CC object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'H 0 0 0; F 0 0 1'</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">'ccpvdz'</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>Unrelaxed density matrices are evaluated in the MO basis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dm1</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="n">dm2</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm2</span><span class="p">()</span>
</pre></div>
</div>
<p>The CCSD(T) energy can be obtained by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="kn">import</span> <span class="n">ccsd_t</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ccsd_t</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Gradients are available:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="kn">import</span> <span class="n">ccsd_grad</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">grad</span>
<span class="n">grad_e</span> <span class="o">=</span> <span class="n">ccsd_grad</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">)</span>
<span class="n">grad_n</span> <span class="o">=</span> <span class="n">grad</span><span class="o">.</span><span class="n">grad_nuc</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">grad</span> <span class="o">=</span> <span class="n">grad_e</span> <span class="o">+</span> <span class="n">grad_nuc</span>
</pre></div>
</div>
<p>Excited states can be calculated with ionization potential (IP), electron affinity (EA),
and electronic excitation (EE) equation-of-motion (EOM) CCSD:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">RCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">e_ip</span><span class="p">,</span> <span class="n">c_ip</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ipccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e_ea</span><span class="p">,</span> <span class="n">c_ea</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eaccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e_ee</span><span class="p">,</span> <span class="n">c_ee</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eeccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">UCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">e_ip</span><span class="p">,</span> <span class="n">c_ip</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ipccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e_ea</span><span class="p">,</span> <span class="n">c_ea</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eaccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">e_ee</span><span class="p">,</span> <span class="n">c_ee</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">eeccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>All CC methods have two implementations.  One is simple and highly readable (suffixed
by <code class="docutils literal notranslate"><span class="pre">_slow</span></code> in the filename) and the other is extensively optimized for
computational efficiency.
All code in the <code class="docutils literal notranslate"><span class="pre">_slow</span></code> versions is structured as close as
possible to the formulas documented in the literature.  Pure Python/numpy
data structures and functions are used so that explicit memory management is avoided.
It is easy to make modifications or develop new methods based on the slow
implementations.</p>
<p>The computationally efficient (outcore) version is the default implementation
for the CC module.  In this implementation, the CPU usage, memory footprint,
memory efficiency, and IO overhead are carefully considered.  To keep a small
memory footprint, most integral tensors are stored on disk.  IO is one of the
main bottlenecks in this implementation.  Two techniques are used to reduce
the IO overhead.  One is the asynchronized IO to overlap the computation and
reading/writing of the 4-index tensors.  The other is AO-driven for the
contraction of T2 and <code class="docutils literal notranslate"><span class="pre">(vv|vv)</span></code> integrals in CCSD and CCSD-lambda functions.
These techniques allow the CC module to efficiently handle medium-sized
systems.  In a test system with 25 occupied orbitals and 1500 virtual orbitals, each
CCSD iteration takes about 2.5 hours.  The program does not automatically
switch to AO-driven CCSD for large systems.  The user must manually set the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">direct</span></code> attribute to enable an AO-driven CCSD calculation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">direct</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>Some of the CC methods have an efficient incore implementation, where
all tensors are held in memory.  The incore implementation reduces the IO overhead
and optimizes certain formulas to gain the best FLOPS.  It is about 30% faster
than the outcore implementation.  Depending on the available memory, the incore
code can be used for systems with up to approximately 250 orbitals.</p>
<p>Point group symmetry is not considered in the CCSD programs, but it is used in
the CCSD(T) code to gain the best performance.</p>
<p>Arbitrary frozen orbitals (not limited to frozen core) are supported
by the CCSD, CCSD(T), density matrices, and EOM-CCSD modules, but not in
the analytical CCSD gradient module.</p>

<h2 id="examples">Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/00-simple_ccsd.py">examples/cc/00-simple_ccsd.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/00-simple_ccsd_t.py">examples/cc/00-simple_ccsd_t.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/01-density_matrix.py">examples/cc/01-density_matrix.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/01-lambda.py">examples/cc/01-lambda.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/10-ao_direct_ccsd.py">examples/cc/10-ao_direct_ccsd.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/11-frozen_core.py">examples/cc/11-frozen_core.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/12-reuse_integrals.py">examples/cc/12-reuse_integrals.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/13-standalone_ccsd_t.py">examples/cc/13-standalone_ccsd_t.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/14-ccsd_diis.py">examples/cc/14-ccsd_diis.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/15-incore_mo_ccsd_t.py">examples/cc/15-incore_mo_ccsd_t.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/20-ip_ea_eom_ccsd.py">examples/cc/20-ip_ea_eom_ccsd.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/21-dfccsd.py">examples/cc/21-dfccsd.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/22-fnoccsd.py">examples/cc/22-fnoccsd.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/31-remove_linear_dep.py">examples/cc/31-remove_linear_dep.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/32-restart.py">examples/cc/32-restart.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/40-ccsd_custom_hamiltonian.py">examples/cc/40-ccsd_custom_hamiltonian.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/41-ccsd_custom_hamiltonian_noscf.py">examples/cc/41-ccsd_custom_hamiltonian_noscf.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/42-as_casci_fcisolver.py">examples/cc/42-as_casci_fcisolver.py</a></p></li>
<li><p><a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/cc/43-ccd.py">examples/cc/43-ccd.py</a></p></li>
</ul>
<p>This section documents some examples about how to effectively use the CCSD
module, and how to incorporate the CCSD solver with other PySCF functions to
perform advanced simulations.</p>

<h3 id="a-general-solver-for-customized-hamiltonian">A general solver for customized Hamiltonian<a class="headerlink" href="#a-general-solver-for-customized-hamiltonian" title="Permalink to this headline">¶</a></h3>
<p>The CC module is not limited to molecular systems.  The program is implemented as
a general solver for arbitrary Hamiltonians.  It allows users to overwrite the
default molecular Hamiltonian with their own effective Hamiltonians.  In this
example, we create a Hubbard model and feed its Hamiltonian to the CCSD module.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">'''</span>
<span class="sd">Six-site 1D U/t=2 Hubbard-like model system with PBC at half filling.</span>
<span class="sd">The model is gapped at the mean-field level</span>
<span class="sd">'''</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">ao2mo</span><span class="p">,</span> <span class="n">cc</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">=</span> <span class="n">n</span>
<span class="c1"># Setting incore_anyway=True to ensure the customized Hamiltonian (the _eri</span>
<span class="c1"># attribute) to be used in the post-HF calculations.  Without this parameter,</span>
<span class="c1"># some post-HF method (particularly in the MO integral transformation) may</span>
<span class="c1"># ignore the customized Hamiltonian if memory is not enough.</span>
<span class="n">mol</span><span class="o">.</span><span class="n">incore_anyway</span> <span class="o">=</span> <span class="kc">True</span>

<span class="n">h1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">h1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
<span class="n">h1</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
<span class="n">eri</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">eri</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">get_hcore</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">h1</span>
<span class="n">mf</span><span class="o">.</span><span class="n">get_ovlp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">_eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">eri</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>


<span class="c1"># In PySCF, the customized Hamiltonian needs to be created once in mf object.</span>
<span class="c1"># The Hamiltonian will be used everywhere whenever possible.  Here, the model</span>
<span class="c1"># Hamiltonian is passed to CCSD object via the mf object.</span>

<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">RCCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">e</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ipccsd</span><span class="p">(</span><span class="n">nroots</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>


<h3 id="using-ccsd-as-casci-active-space-solver">Using CCSD as CASCI active space solver<a class="headerlink" href="#using-ccsd-as-casci-active-space-solver" title="Permalink to this headline">¶</a></h3>
<p>CCSD program can be wrapped as a Full CI solver, which can be combined with the
CASCI solver to approximate the multi-configuration calculation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">'''</span>
<span class="sd">Using the CCSD method as the active space solver to compute an approximate</span>
<span class="sd">CASCI energy.</span>

<span class="sd">See also 42-oo_ccd.py</span>

<span class="sd">A wrapper is required to adapt the CCSD solver to CASCI fcisolver interface.</span>
<span class="sd">Inside the wrapper function, the CCSD code is the same as the example</span>
<span class="sd">40-ccsd_with_given_hamiltonian.py</span>
<span class="sd">'''</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">ao2mo</span><span class="p">,</span> <span class="n">mcscf</span>

<span class="k">class</span> <span class="nc">AsFCISolver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">,</span> <span class="n">ci0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ecore</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">fakemol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nelec</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nelec</span><span class="p">)</span>
        <span class="n">fakemol</span><span class="o">.</span><span class="n">nelectron</span> <span class="o">=</span> <span class="n">nelec</span>
        <span class="n">fake_hf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">fakemol</span><span class="p">)</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">_eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">restore</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">h2</span><span class="p">,</span> <span class="n">norb</span><span class="p">)</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">get_hcore</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">h1</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">get_ovlp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">norb</span><span class="p">)</span>
        <span class="n">fake_hf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">fake_hf</span><span class="p">)</span>
        <span class="n">eris</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">()</span>
        <span class="n">e_corr</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>
        <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">solve_lambda</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>
        <span class="n">e_tot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">e_tot</span> <span class="o">+</span> <span class="n">ecore</span>
        <span class="k">return</span> <span class="n">e_tot</span><span class="p">,</span> <span class="n">CCSDAmplitudesAsCIWfn</span><span class="p">([</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">make_rdm1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">):</span>
        <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">fake_ci</span><span class="o">.</span><span class="n">cc_amplitues</span>
        <span class="n">dm1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">ao_repr</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dm1</span>

    <span class="k">def</span> <span class="nf">make_rdm12</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">):</span>
        <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">fake_ci</span><span class="o">.</span><span class="n">cc_amplitues</span>
        <span class="n">dm2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm2</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">ao_repr</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">(</span><span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">),</span> <span class="n">dm2</span>

    <span class="k">def</span> <span class="nf">spin_square</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fake_ci</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>

<span class="k">class</span> <span class="nc">CCSDAmplitudesAsCIWfn</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cc_amplitues</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cc_amplitues</span> <span class="o">=</span> <span class="n">cc_amplitues</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">'H 0 0 0; F 0 0 1.2'</span><span class="p">,</span>
            <span class="n">basis</span> <span class="o">=</span> <span class="s1">'ccpvdz'</span><span class="p">,</span>
            <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">norb</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">nelec</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="n">nelec</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">AsFCISolver</span><span class="p">()</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

</pre></div>
</div>


<h3 id="gamma-point-ccsd-with-periodic-boundary-condition">Gamma point CCSD with Periodic boundary condition<a class="headerlink" href="#gamma-point-ccsd-with-periodic-boundary-condition" title="Permalink to this headline">¶</a></h3>
<p>Integrals in Gamma point of periodic Hartree-Fock calculation are all real.
You can feed the integrals into any pyscf molecular module using the same
operations as the above example.  However, the interface between PBC code and
molecular code are more compatible.  You can treat the crystal object and the
molecule object in the same manner.  In this example, you can pass the PBC mean
field method to CC module to have the gamma point CCSD correlation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">'''</span>
<span class="sd">Gamma point post-HF calculation needs only real integrals.</span>
<span class="sd">Methods implemented in finite-size system can be directly used here without</span>
<span class="sd">any modification.</span>
<span class="sd">'''</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf.pbc</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>

<span class="n">cell</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mf">3.5668</span><span class="p">,</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">'''C     0.      0.      0.    </span>
<span class="s1">              C     0.8917  0.8917  0.8917</span>
<span class="s1">              C     1.7834  1.7834  0.    </span>
<span class="s1">              C     2.6751  2.6751  0.8917</span>
<span class="s1">              C     1.7834  0.      1.7834</span>
<span class="s1">              C     2.6751  0.8917  2.6751</span>
<span class="s1">              C     0.      1.7834  1.7834</span>
<span class="s1">              C     0.8917  2.6751  2.6751'''</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">'6-31g'</span><span class="p">,</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">density_fit</span><span class="p">()</span>
<span class="n">mf</span><span class="o">.</span><span class="n">with_df</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># Import CC, TDDFT module from the molecular implementations</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">cc</span><span class="p">,</span> <span class="n">tddft</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="n">mytd</span> <span class="o">=</span> <span class="n">tddft</span><span class="o">.</span><span class="n">TDHF</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mytd</span><span class="o">.</span><span class="n">nstates</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">mytd</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>


<h3 id="ccsd-with-truncated-mos-to-avoid-linear-dependency">CCSD with truncated MOs to avoid linear dependency<a class="headerlink" href="#ccsd-with-truncated-mos-to-avoid-linear-dependency" title="Permalink to this headline">¶</a></h3>
<p>It is common to have linear dependence when one wants to systematically enlarge
the AO basis set to approach complete basis set limit.  The numerical
instability usually has noticeable effects on the CCSD convergence.  An
effective way to remove this negative effects is to truncate the AO sets and
allow the MO orbitals being less than AO functions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">'''</span>
<span class="sd">:func:`scf.addons.remove_linear_dep_` discards the small eigenvalues of overlap</span>
<span class="sd">matrix.  This reduces the number of MOs from 50 to 49.  The problem size of</span>
<span class="sd">the following CCSD method is 49.</span>
<span class="sd">'''</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'H'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)]</span>
<span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="s1">'ccpvdz'</span>
<span class="n">mol</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">remove_linear_dep_</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

</pre></div>
</div>


<h3 id="response-and-un-relaxed-ccsd-density-matrix">Response and un-relaxed CCSD density matrix<a class="headerlink" href="#response-and-un-relaxed-ccsd-density-matrix" title="Permalink to this headline">¶</a></h3>
<p>CCSD has two kinds of one-particle density matrices.  The (second order)
un-relaxed density matrix and the (relaxed) response density matrix.  The
<code class="xref py py-func docutils literal notranslate"><span class="pre">CCSD.make_rdm1()</span></code> function computes the un-relaxed density matrix which is
associated to the regular CCSD energy formula.  The response density is mainly
used to compute the first order response quantities eg the analytical nuclear
gradients.  It is not recommended to use the response density matrix for
population analysis.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1">#</span>
<span class="c1"># Author: Qiming Sun &lt;osirpt.sun@gmail.com&gt;</span>
<span class="c1">#</span>

<span class="sd">'''</span>
<span class="sd">CCSD and CCSD(T) density matrices</span>
<span class="sd">'''</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">ao2mo</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">'H 0 0 0; F 0 0 1.1'</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">'ccpvdz'</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># CCSD density matrix in MO basis</span>
<span class="c1">#</span>
<span class="n">dm1</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="n">dm2</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">make_rdm2</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># CCSD energy based on density matrices</span>
<span class="c1">#</span>
<span class="n">h1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">'pi,pq,qj-&gt;ij'</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">mf</span><span class="o">.</span><span class="n">get_hcore</span><span class="p">(),</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">)</span>
<span class="n">nmo</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">eri</span> <span class="o">=</span> <span class="n">ao2mo</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">nmo</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">'pq,qp'</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">dm1</span><span class="p">)</span>
<span class="c1"># Note dm2 is transposed to simplify its contraction to integrals</span>
<span class="n">E</span><span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">'pqrs,pqrs'</span><span class="p">,</span> <span class="n">eri</span><span class="p">,</span> <span class="n">dm2</span><span class="p">)</span> <span class="o">*</span> <span class="o">.</span><span class="mi">5</span>
<span class="n">E</span><span class="o">+=</span> <span class="n">mol</span><span class="o">.</span><span class="n">energy_nuc</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'E(CCSD) = </span><span class="si">%s</span><span class="s1">, reference </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">e_tot</span><span class="p">))</span>


<span class="c1"># When plotting CCSD density on grids, CCSD density matrices need to be</span>
<span class="c1"># transformed to AO basis representation.</span>
<span class="n">dm1_ao</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">'pi,ij,qj-&gt;pq'</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>

<span class="kn">from</span> <span class="nn">pyscf.tools</span> <span class="kn">import</span> <span class="n">cubegen</span>
<span class="n">cubegen</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="s1">'rho_ccsd.cube'</span><span class="p">,</span> <span class="n">dm1_ao</span><span class="p">)</span>


<span class="c1">###</span>
<span class="c1">#</span>
<span class="c1"># Compute CCSD(T) density matrices with ccsd_t-slow implementation</span>
<span class="c1"># (as of pyscf v1.7)</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="kn">import</span> <span class="n">ccsd_t_lambda_slow</span> <span class="k">as</span> <span class="n">ccsd_t_lambda</span>
<span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="kn">import</span> <span class="n">ccsd_t_rdm_slow</span> <span class="k">as</span> <span class="n">ccsd_t_rdm</span>
<span class="n">eris</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">()</span>
<span class="n">conv</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">ccsd_t_lambda</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">eris</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">t1</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">t2</span><span class="p">)</span>
<span class="n">dm1</span> <span class="o">=</span> <span class="n">ccsd_t_rdm</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">t1</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>
<span class="n">dm2</span> <span class="o">=</span> <span class="n">ccsd_t_rdm</span><span class="o">.</span><span class="n">make_rdm2</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">t1</span><span class="p">,</span> <span class="n">mycc</span><span class="o">.</span><span class="n">t2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>

</pre></div>
</div>


<h3 id="reusing-integrals-in-ccsd-and-relevant-calculations">Reusing integrals in CCSD and relevant calculations<a class="headerlink" href="#reusing-integrals-in-ccsd-and-relevant-calculations" title="Permalink to this headline">¶</a></h3>
<p>By default the CCSD solver and the relevant CCSD lambda solver, CCSD(T), CCSD
gradients program generate MO integrals in their own runtime.  But in most
scenario, the same MO integrals can be generated once and reused in the four
modules.  To remove the overhead of recomputing MO integrals, the three module
support user to feed MO integrals.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1">#</span>
<span class="c1"># Author: Qiming Sun &lt;osirpt.sun@gmail.com&gt;</span>
<span class="c1">#</span>

<span class="sd">'''</span>
<span class="sd">To avoid recomputing AO to MO integral transformation, integrals for CCSD,</span>
<span class="sd">CCSD(T), CCSD lambda equation etc can be reused.</span>
<span class="sd">'''</span>

<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="s1">'H 0 0 0; F 0 0 1.1'</span><span class="p">,</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">'ccpvdz'</span><span class="p">)</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># CCSD module allows you feed MO integrals</span>
<span class="c1">#</span>
<span class="n">eris</span> <span class="o">=</span> <span class="n">mycc</span><span class="o">.</span><span class="n">ao2mo</span><span class="p">()</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># The same MO integrals can be used in CCSD lambda equation</span>
<span class="c1">#</span>
<span class="n">mycc</span><span class="o">.</span><span class="n">solve_lambda</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># CCSD(T) module requires the same integrals used by CCSD module</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">pyscf.cc</span> <span class="kn">import</span> <span class="n">ccsd_t</span>
<span class="n">ccsd_t</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">mycc</span><span class="p">,</span> <span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># CCSD gradients need zeroth order MO integrals when solving the "relaxed"</span>
<span class="c1"># 1-particle density matrix.</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">pyscf.grad.ccsd</span> <span class="kn">import</span> <span class="n">Gradients</span>
<span class="n">grad_e</span> <span class="o">=</span> <span class="n">Gradients</span><span class="p">(</span><span class="n">mycc</span><span class="p">)</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">eris</span><span class="o">=</span><span class="n">eris</span><span class="p">)</span>  <span class="c1"># The electronic part only</span>

</pre></div>
</div>


<h3 id="interfering-ccsd-diis">Interfering CCSD-DIIS<a class="headerlink" href="#interfering-ccsd-diis" title="Permalink to this headline">¶</a></h3>


<h3 id="restart-ccsd">Restart CCSD<a class="headerlink" href="#restart-ccsd" title="Permalink to this headline">¶</a></h3>



<h2 id="program-reference">Program reference<a class="headerlink" href="#program-reference" title="Permalink to this headline">¶</a></h2>

<h3 id="cc-ccsd-module-and-ccsd-class">cc.ccsd module and CCSD class<a class="headerlink" href="#cc-ccsd-module-and-ccsd-class" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#id0" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.ccsd.CCSD</span></code></a> class is the object to hold the restricted CCSD environment
attributes and results.  The environment attributes are the parameters to
control the runtime behavior of the CCSD module, e.g. the convergence criteria, DIIS
parameters, and so on.  After the ground state CCSD calculation, correlation
energy, <code class="docutils literal notranslate"><span class="pre">T1</span></code> and <code class="docutils literal notranslate"><span class="pre">T2</span></code> amplitudes are stored in the CCSD object.
This class supports the calculation of CCSD 1- and 2-particle density matrices.</p>
<dl class="py class">
<dt id="pyscf.cc.ccsd.CCSD">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">CCSD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">frozen</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#CCSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD" title="Permalink to this definition">¶</a></dt>
<dd><p>restricted CCSD</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-7.</p>
</dd>
<dt>conv_tol_normt<span class="classifier">float</span></dt><dd><p>converge threshold for norm(t1,t2).  Default is 1e-5.</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  Default is 50.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  Default is 6.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 0.</p>
</dd>
<dt>iterative_damping<span class="classifier">float</span></dt><dd><p>The self consistent damping parameter.</p>
</dd>
<dt>direct<span class="classifier">bool</span></dt><dd><p>AO-direct CCSD. Default is False.</p>
</dd>
<dt>async_io<span class="classifier">bool</span></dt><dd><p>Allow for asynchronous function execution. Default is True.</p>
</dd>
<dt>incore_complete<span class="classifier">bool</span></dt><dd><p>Avoid all I/O (also for DIIS). Default is False.</p>
</dd>
<dt>level_shift<span class="classifier">float</span></dt><dd><p>A shift on virtual orbital energies to stablize the CCSD iteration</p>
</dd>
<dt>frozen<span class="classifier">int or list</span></dt><dd><p>If integer is given, the inner-most orbitals are frozen from CC
amplitudes.  Given the orbital indices (0-based) in a list, both
occupied and virtual orbitals can be frozen in CC calculation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">'H 0 0 0; F 0 0 1.1'</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="s1">'ccpvdz'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals and 3 high lying unoccupied orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>CCSD converged or not</p>
</dd>
<dt>e_corr<span class="classifier">float</span></dt><dd><p>CCSD correlation correction</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total CCSD energy (HF + correlation)</p>
</dd>
<dt>t1, t2 :</dt><dd><p>T amplitudes t1[i,a], t2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
<dt>l1, l2 :</dt><dd><p>Lambda amplitudes l1[i,a], l2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>
<span class="target" id="module-pyscf.cc.ccsd"></span><p>RCCSD for real integrals
8-fold permutation symmetry has been used
(ij|kl) = (ji|kl) = (kl|ij) = …</p>
<dl class="py attribute">
<dt id="pyscf.cc.ccsd.CC">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">CC</code><a class="headerlink" href="#pyscf.cc.ccsd.CC" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#id0" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.ccsd.CCSD</span></code></a></p>
</dd></dl>
<dl class="py class">
<dt id="id0">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">CCSD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">frozen</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#CCSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>restricted CCSD</p>
<dl>
<dt>Attributes:</dt><dd><dl>
<dt>verbose<span class="classifier">int</span></dt><dd><p>Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd>
<dt>max_memory<span class="classifier">float or int</span></dt><dd><p>Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd>
<dt>conv_tol<span class="classifier">float</span></dt><dd><p>converge threshold.  Default is 1e-7.</p>
</dd>
<dt>conv_tol_normt<span class="classifier">float</span></dt><dd><p>converge threshold for norm(t1,t2).  Default is 1e-5.</p>
</dd>
<dt>max_cycle<span class="classifier">int</span></dt><dd><p>max number of iterations.  Default is 50.</p>
</dd>
<dt>diis_space<span class="classifier">int</span></dt><dd><p>DIIS space size.  Default is 6.</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 0.</p>
</dd>
<dt>iterative_damping<span class="classifier">float</span></dt><dd><p>The self consistent damping parameter.</p>
</dd>
<dt>direct<span class="classifier">bool</span></dt><dd><p>AO-direct CCSD. Default is False.</p>
</dd>
<dt>async_io<span class="classifier">bool</span></dt><dd><p>Allow for asynchronous function execution. Default is True.</p>
</dd>
<dt>incore_complete<span class="classifier">bool</span></dt><dd><p>Avoid all I/O (also for DIIS). Default is False.</p>
</dd>
<dt>level_shift<span class="classifier">float</span></dt><dd><p>A shift on virtual orbital energies to stablize the CCSD iteration</p>
</dd>
<dt>frozen<span class="classifier">int or list</span></dt><dd><p>If integer is given, the inner-most orbitals are frozen from CC
amplitudes.  Given the orbital indices (0-based) in a list, both
occupied and virtual orbitals can be frozen in CC calculation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">'H 0 0 0; F 0 0 1.1'</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="s1">'ccpvdz'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals and 3 high lying unoccupied orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
<p>Saved results</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>CCSD converged or not</p>
</dd>
<dt>e_corr<span class="classifier">float</span></dt><dd><p>CCSD correlation correction</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total CCSD energy (HF + correlation)</p>
</dd>
<dt>t1, t2 :</dt><dd><p>T amplitudes t1[i,a], t2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
<dt>l1, l2 :</dt><dd><p>Lambda amplitudes l1[i,a], l2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
</dl>
</div></blockquote>
<dl class="py method">
<dt id="pyscf.cc.ccsd.CCSD.EOMEA_Ta">
<code class="sig-name descname">EOMEA_Ta</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.EOMEA_Ta" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for EOM EACCSD(T)*(a) method by Matthews and Stanton.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.ccsd.CCSD.EOMIP_Ta">
<code class="sig-name descname">EOMIP_Ta</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.EOMIP_Ta" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for EOM IPCCSD(T)*(a) method by Matthews and Stanton.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.ccsd.CCSD.as_scanner">
<code class="sig-name descname">as_scanner</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.as_scanner" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating a scanner/solver for CCSD PES.</p>
<p>The returned solver is a function. This function requires one argument
“mol” as input and returns total CCSD energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
CCSD and the underlying SCF objects (conv_tol, max_memory etc) are
automatically applied in the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, …) during calculation.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'H 0 0 0; F 0 0 1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cc_scanner</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'H 0 0 0; F 0 0 1.1'</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'H 0 0 0; F 0 0 1.5'</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.ccsd.CCSD.energy">
<code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eris</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>CCSD correlation energy</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.ccsd.CCSD.get_frozen_mask">
<code class="sig-name descname">get_frozen_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.get_frozen_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Get boolean mask for the restricted reference orbitals.</p>
<p>In the returned boolean (mask) array of frozen orbital indices, the
element is False if it corresonds to the frozen orbital.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.ccsd.CCSD.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eris</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#CCSD.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel function is the main driver of a method.  Every method should
define the kernel function as the entry of the calculation.  Note the
return value of kernel function is not strictly defined.  It can be
anything related to the method (such as the energy, the wave-function,
the DFT mesh grids etc.).</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.ccsd.CCSD.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ao_repr</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#CCSD.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-relaxed 1-particle density matrix in MO space</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.ccsd.CCSD.make_rdm2">
<code class="sig-name descname">make_rdm2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ao_repr</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#CCSD.make_rdm2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.make_rdm2" title="Permalink to this definition">¶</a></dt>
<dd><p>2-particle density matrix in MO space.  The density matrix is
stored as</p>
<p>dm2[p,r,q,s] = &lt;p^+ q^+ s r&gt;</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.ccsd.CCSD.restore_from_diis_">
<code class="sig-name descname">restore_from_diis_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">diis_file</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.ccsd.CCSD.restore_from_diis_" title="Permalink to this definition">¶</a></dt>
<dd><p>Reuse an existed DIIS object in the CCSD calculation.</p>
<p>The CCSD amplitudes will be restored from the DIIS object to generate t1
and t2 amplitudes. The t1/t2 amplitudes of the CCSD object will be
overwritten by the generated t1 and t2 amplitudes. The amplitudes vector
and error vector will be reused in the CCSD calculation.</p>
</dd></dl>
</dd></dl>
<dl class="py attribute">
<dt id="pyscf.cc.ccsd.RCCSD">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">RCCSD</code><a class="headerlink" href="#pyscf.cc.ccsd.RCCSD" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#id0" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.ccsd.CCSD</span></code></a></p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.cc.ccsd.as_scanner">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">as_scanner</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cc</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#as_scanner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.as_scanner" title="Permalink to this definition">¶</a></dt>
<dd><p>Generating a scanner/solver for CCSD PES.</p>
<p>The returned solver is a function. This function requires one argument
“mol” as input and returns total CCSD energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
CCSD and the underlying SCF objects (conv_tol, max_memory etc) are
automatically applied in the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, …) during calculation.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">cc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'H 0 0 0; F 0 0 1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cc_scanner</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'H 0 0 0; F 0 0 1.1'</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e_tot</span> <span class="o">=</span> <span class="n">cc_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">'H 0 0 0; F 0 0 1.5'</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="pyscf.cc.ccsd.energy">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mycc</span></em>, <em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eris</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>CCSD correlation energy</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.cc.ccsd.get_d1_diagnostic">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">get_d1_diagnostic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#get_d1_diagnostic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.get_d1_diagnostic" title="Permalink to this definition">¶</a></dt>
<dd><p>D1 diagnostic given in</p>
<p>Janssen, et. al Chem. Phys. Lett. 290 (1998) 423</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.cc.ccsd.get_d2_diagnostic">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">get_d2_diagnostic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#get_d2_diagnostic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.get_d2_diagnostic" title="Permalink to this definition">¶</a></dt>
<dd><p>D2 diagnostic given in</p>
<blockquote>
<div><p>Nielsen, et. al Chem. Phys. Lett. 310 (1999) 568</p>
</div></blockquote>
<p>Note: This is currently only defined in the literature for restricted
closed-shell systems.</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.cc.ccsd.get_t1_diagnostic">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">get_t1_diagnostic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#get_t1_diagnostic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.get_t1_diagnostic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the t1 amplitude norm, normalized by number of correlated electrons.</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.cc.ccsd.restore_from_diis_">
<code class="sig-prename descclassname">pyscf.cc.ccsd.</code><code class="sig-name descname">restore_from_diis_</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mycc</span></em>, <em class="sig-param"><span class="n">diis_file</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/ccsd.html#restore_from_diis_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.ccsd.restore_from_diis_" title="Permalink to this definition">¶</a></dt>
<dd><p>Reuse an existed DIIS object in the CCSD calculation.</p>
<p>The CCSD amplitudes will be restored from the DIIS object to generate t1
and t2 amplitudes. The t1/t2 amplitudes of the CCSD object will be
overwritten by the generated t1 and t2 amplitudes. The amplitudes vector
and error vector will be reused in the CCSD calculation.</p>
</dd></dl>


<h3 id="cc-rccsd-and-rccsd-class">cc.rccsd and RCCSD class<a class="headerlink" href="#cc-rccsd-and-rccsd-class" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#id1" title="pyscf.cc.rccsd.RCCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.rccsd.RCCSD</span></code></a> is also a class for restricted CCSD calculations, but
different to the <a class="reference internal" href="#id0" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.ccsd.CCSD</span></code></a> class.  It uses different formula
to compute the ground state CCSD solution.  Although slower than the
implmentation in the <a class="reference internal" href="#id0" title="pyscf.cc.ccsd.CCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.ccsd.CCSD</span></code></a> class, it supports the system
with complex integrals.  Another difference is that this class supports EOM-CCSD
methods, including EOM-IP-CCSD, EOM-EA-CCSD, EOM-EE-CCSD, EOM-SF-CCSD.</p>
<dl class="py class">
<dt id="pyscf.cc.rccsd.RCCSD">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.cc.rccsd.</code><code class="sig-name descname">RCCSD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">frozen</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/rccsd.html#RCCSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD" title="Permalink to this definition">¶</a></dt>
<dd><p>restricted CCSD with IP-EOM, EA-EOM, EE-EOM, and SF-EOM capabilities</p>
<p>Ground-state CCSD is performed in optimized ccsd.CCSD and EOM is performed here.</p>
</dd></dl>
<span class="target" id="module-pyscf.cc.rccsd"></span><p>Restricted CCSD implementation which supports both real and complex integrals.
The 4-index integrals are saved on disk entirely (without using any symmetry).
This code is slower than the pyscf.cc.ccsd implementation.</p>
<p>Note MO integrals are treated in chemist’s notation</p>
<p>Ref: Hirata et al., J. Chem. Phys. 120, 2581 (2004)</p>
<dl class="py class">
<dt id="id1">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.cc.rccsd.</code><code class="sig-name descname">RCCSD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">frozen</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/rccsd.html#RCCSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id1" title="Permalink to this definition">¶</a></dt>
<dd><p>restricted CCSD with IP-EOM, EA-EOM, EE-EOM, and SF-EOM capabilities</p>
<p>Ground-state CCSD is performed in optimized ccsd.CCSD and EOM is performed here.</p>
<dl class="py method">
<dt id="pyscf.cc.rccsd.RCCSD.ccsd">
<code class="sig-name descname">ccsd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eris</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mbpt2</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/rccsd.html#RCCSD.ccsd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD.ccsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Ground-state CCSD.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mbpt2<span class="classifier">bool</span></dt><dd><p>Use one-shot MBPT2 approximation to CCSD.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.rccsd.RCCSD.energy">
<code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eris</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>RCCSD correlation energy</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.rccsd.RCCSD.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eris</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mbpt2</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/rccsd.html#RCCSD.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.RCCSD.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel function is the main driver of a method.  Every method should
define the kernel function as the entry of the calculation.  Note the
return value of kernel function is not strictly defined.  It can be
anything related to the method (such as the energy, the wave-function,
the DFT mesh grids etc.).</p>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.cc.rccsd.energy">
<code class="sig-prename descclassname">pyscf.cc.rccsd.</code><code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cc</span></em>, <em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eris</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/rccsd.html#energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.rccsd.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>RCCSD correlation energy</p>
</dd></dl>


<h3 id="cc-uccsd-and-uccsd-class">cc.uccsd and UCCSD class<a class="headerlink" href="#cc-uccsd-and-uccsd-class" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#id2" title="pyscf.cc.uccsd.UCCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.uccsd.UCCSD</span></code></a> class supports the CCSD calculation based on UHF
wavefunction as well as the ROHF wavefunction.  Besides the ground state UCCSD calculation,
UCCSD lambda equation, 1-particle and 2-particle density matrices, EOM-IP-CCSD,
EOM-EA-CCSD, EOM-EE-CCSD are all available in this class.  Note this class does
not support complex integrals.</p>
<dl class="py class">
<dt id="pyscf.cc.uccsd.UCCSD">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.cc.uccsd.</code><code class="sig-name descname">UCCSD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">frozen</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#UCCSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<span class="target" id="module-pyscf.cc.uccsd"></span><p>UCCSD with spatial integrals</p>
<dl class="py attribute">
<dt id="pyscf.cc.uccsd.CCSD">
<code class="sig-prename descclassname">pyscf.cc.uccsd.</code><code class="sig-name descname">CCSD</code><a class="headerlink" href="#pyscf.cc.uccsd.CCSD" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#id2" title="pyscf.cc.uccsd.UCCSD"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyscf.cc.uccsd.UCCSD</span></code></a></p>
</dd></dl>
<dl class="py class">
<dt id="id2">
<em class="property">class </em><code class="sig-prename descclassname">pyscf.cc.uccsd.</code><code class="sig-name descname">UCCSD</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mf</span></em>, <em class="sig-param"><span class="n">frozen</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_coeff</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mo_occ</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#UCCSD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#id2" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="pyscf.cc.uccsd.UCCSD.ccsd">
<code class="sig-name descname">ccsd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eris</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mbpt2</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#UCCSD.ccsd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD.ccsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Ground-state unrestricted (U)CCSD.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mbpt2<span class="classifier">bool</span></dt><dd><p>Use one-shot MBPT2 approximation to CCSD.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.uccsd.UCCSD.energy">
<code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eris</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>UCCSD correlation energy</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.uccsd.UCCSD.get_frozen_mask">
<code class="sig-name descname">get_frozen_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD.get_frozen_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Get boolean mask for the unrestricted reference orbitals.</p>
<p>In the returned boolean (mask) array of frozen orbital indices, the
element is False if it corresonds to the frozen orbital.</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.uccsd.UCCSD.kernel">
<code class="sig-name descname">kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eris</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mbpt2</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#UCCSD.kernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Kernel function is the main driver of a method.  Every method should
define the kernel function as the entry of the calculation.  Note the
return value of kernel function is not strictly defined.  It can be
anything related to the method (such as the energy, the wave-function,
the DFT mesh grids etc.).</p>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.uccsd.UCCSD.make_rdm1">
<code class="sig-name descname">make_rdm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ao_repr</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#UCCSD.make_rdm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-relaxed 1-particle density matrix in MO space</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>dm1a, dm1b</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="pyscf.cc.uccsd.UCCSD.make_rdm2">
<code class="sig-name descname">make_rdm2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">l2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ao_repr</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#UCCSD.make_rdm2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.UCCSD.make_rdm2" title="Permalink to this definition">¶</a></dt>
<dd><p>2-particle density matrix in spin-oribital basis.</p>
</dd></dl>
</dd></dl>
<dl class="py function">
<dt id="pyscf.cc.uccsd.energy">
<code class="sig-prename descclassname">pyscf.cc.uccsd.</code><code class="sig-name descname">energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cc</span></em>, <em class="sig-param"><span class="n">t1</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t2</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eris</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/uccsd.html#energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.uccsd.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>UCCSD correlation energy</p>
</dd></dl>


<h3 id="cc-addons">cc.addons<a class="headerlink" href="#cc-addons" title="Permalink to this headline">¶</a></h3>
<p>Helper functions for CCSD, RCCSD and UCCSD modules are implemented in
<code class="xref py py-mod docutils literal notranslate"><span class="pre">cc.addons</span></code></p>
<span class="target" id="module-pyscf.cc.addons"></span><dl class="py function">
<dt id="pyscf.cc.addons.spatial2spin">
<code class="sig-prename descclassname">pyscf.cc.addons.</code><code class="sig-name descname">spatial2spin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tx</span></em>, <em class="sig-param"><span class="n">orbspin</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/pyscf/cc/addons.html#spatial2spin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pyscf.cc.addons.spatial2spin" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert T1/T2 of spatial orbital representation to T1/T2 of
spin-orbital representation</p>
</dd></dl>
<dl class="py function">
<dt id="pyscf.cc.addons.spatial2spinorb">
<code class="sig-prename descclassname">pyscf.cc.addons.</code><code class="sig-name descname">spatial2spinorb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tx</span></em>, <em class="sig-param"><span class="n">orbspin</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyscf.cc.addons.spatial2spinorb" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert T1/T2 of spatial orbital representation to T1/T2 of
spin-orbital representation</p>
</dd></dl>


<h3 id="ccsd-t">CCSD(T)<a class="headerlink" href="#ccsd-t" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-pyscf.cc.ccsd_t"></span><p>RHF-CCSD(T) for real integrals</p>


<h3 id="ccsd-gradients">CCSD gradients<a class="headerlink" href="#ccsd-gradients" title="Permalink to this headline">¶</a></h3>





          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2015-2021, The PySCF Developers.
              
          </div>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 3.4.3.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>